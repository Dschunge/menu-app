
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Hotel
 * 
 */
export type Hotel = $Result.DefaultSelection<Prisma.$HotelPayload>
/**
 * Model Amenities
 * 
 */
export type Amenities = $Result.DefaultSelection<Prisma.$AmenitiesPayload>
/**
 * Model TourPriceCategory
 * 
 */
export type TourPriceCategory = $Result.DefaultSelection<Prisma.$TourPriceCategoryPayload>
/**
 * Model Tour
 * 
 */
export type Tour = $Result.DefaultSelection<Prisma.$TourPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model SpaPriceCategory
 * 
 */
export type SpaPriceCategory = $Result.DefaultSelection<Prisma.$SpaPriceCategoryPayload>
/**
 * Model Spa
 * 
 */
export type Spa = $Result.DefaultSelection<Prisma.$SpaPayload>
/**
 * Model TVChannels
 * 
 */
export type TVChannels = $Result.DefaultSelection<Prisma.$TVChannelsPayload>
/**
 * Model Restaurant
 * 
 */
export type Restaurant = $Result.DefaultSelection<Prisma.$RestaurantPayload>
/**
 * Model Menu
 * 
 */
export type Menu = $Result.DefaultSelection<Prisma.$MenuPayload>
/**
 * Model Table
 * 
 */
export type Table = $Result.DefaultSelection<Prisma.$TablePayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Reservation
 * 
 */
export type Reservation = $Result.DefaultSelection<Prisma.$ReservationPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Subcategory
 * 
 */
export type Subcategory = $Result.DefaultSelection<Prisma.$SubcategoryPayload>
/**
 * Model SubSubcategory
 * 
 */
export type SubSubcategory = $Result.DefaultSelection<Prisma.$SubSubcategoryPayload>
/**
 * Model Dish
 * 
 */
export type Dish = $Result.DefaultSelection<Prisma.$DishPayload>
/**
 * Model OpeningHours
 * 
 */
export type OpeningHours = $Result.DefaultSelection<Prisma.$OpeningHoursPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AMENITIESTYPE: {
  HOTEL: 'HOTEL',
  ROOM: 'ROOM'
};

export type AMENITIESTYPE = (typeof AMENITIESTYPE)[keyof typeof AMENITIESTYPE]


export const RECURRINGPATTERN: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY'
};

export type RECURRINGPATTERN = (typeof RECURRINGPATTERN)[keyof typeof RECURRINGPATTERN]


export const TVCHANNELTYPE: {
  STANDARD: 'STANDARD',
  HD: 'HD'
};

export type TVCHANNELTYPE = (typeof TVCHANNELTYPE)[keyof typeof TVCHANNELTYPE]


export const TVChannelLanguages: {
  ENGLISH: 'ENGLISH',
  SPANISH: 'SPANISH',
  BOTH: 'BOTH'
};

export type TVChannelLanguages = (typeof TVChannelLanguages)[keyof typeof TVChannelLanguages]


export const ReservationStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED',
  NO_SHOW: 'NO_SHOW'
};

export type ReservationStatus = (typeof ReservationStatus)[keyof typeof ReservationStatus]

}

export type AMENITIESTYPE = $Enums.AMENITIESTYPE

export const AMENITIESTYPE: typeof $Enums.AMENITIESTYPE

export type RECURRINGPATTERN = $Enums.RECURRINGPATTERN

export const RECURRINGPATTERN: typeof $Enums.RECURRINGPATTERN

export type TVCHANNELTYPE = $Enums.TVCHANNELTYPE

export const TVCHANNELTYPE: typeof $Enums.TVCHANNELTYPE

export type TVChannelLanguages = $Enums.TVChannelLanguages

export const TVChannelLanguages: typeof $Enums.TVChannelLanguages

export type ReservationStatus = $Enums.ReservationStatus

export const ReservationStatus: typeof $Enums.ReservationStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Hotels
 * const hotels = await prisma.hotel.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Hotels
   * const hotels = await prisma.hotel.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.hotel`: Exposes CRUD operations for the **Hotel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hotels
    * const hotels = await prisma.hotel.findMany()
    * ```
    */
  get hotel(): Prisma.HotelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.amenities`: Exposes CRUD operations for the **Amenities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Amenities
    * const amenities = await prisma.amenities.findMany()
    * ```
    */
  get amenities(): Prisma.AmenitiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tourPriceCategory`: Exposes CRUD operations for the **TourPriceCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TourPriceCategories
    * const tourPriceCategories = await prisma.tourPriceCategory.findMany()
    * ```
    */
  get tourPriceCategory(): Prisma.TourPriceCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tour`: Exposes CRUD operations for the **Tour** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tours
    * const tours = await prisma.tour.findMany()
    * ```
    */
  get tour(): Prisma.TourDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.spaPriceCategory`: Exposes CRUD operations for the **SpaPriceCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpaPriceCategories
    * const spaPriceCategories = await prisma.spaPriceCategory.findMany()
    * ```
    */
  get spaPriceCategory(): Prisma.SpaPriceCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.spa`: Exposes CRUD operations for the **Spa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Spas
    * const spas = await prisma.spa.findMany()
    * ```
    */
  get spa(): Prisma.SpaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tVChannels`: Exposes CRUD operations for the **TVChannels** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TVChannels
    * const tVChannels = await prisma.tVChannels.findMany()
    * ```
    */
  get tVChannels(): Prisma.TVChannelsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.restaurant`: Exposes CRUD operations for the **Restaurant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Restaurants
    * const restaurants = await prisma.restaurant.findMany()
    * ```
    */
  get restaurant(): Prisma.RestaurantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menu`: Exposes CRUD operations for the **Menu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Menus
    * const menus = await prisma.menu.findMany()
    * ```
    */
  get menu(): Prisma.MenuDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.table`: Exposes CRUD operations for the **Table** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tables
    * const tables = await prisma.table.findMany()
    * ```
    */
  get table(): Prisma.TableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reservation`: Exposes CRUD operations for the **Reservation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservations
    * const reservations = await prisma.reservation.findMany()
    * ```
    */
  get reservation(): Prisma.ReservationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subcategory`: Exposes CRUD operations for the **Subcategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subcategories
    * const subcategories = await prisma.subcategory.findMany()
    * ```
    */
  get subcategory(): Prisma.SubcategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subSubcategory`: Exposes CRUD operations for the **SubSubcategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubSubcategories
    * const subSubcategories = await prisma.subSubcategory.findMany()
    * ```
    */
  get subSubcategory(): Prisma.SubSubcategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dish`: Exposes CRUD operations for the **Dish** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dishes
    * const dishes = await prisma.dish.findMany()
    * ```
    */
  get dish(): Prisma.DishDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.openingHours`: Exposes CRUD operations for the **OpeningHours** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OpeningHours
    * const openingHours = await prisma.openingHours.findMany()
    * ```
    */
  get openingHours(): Prisma.OpeningHoursDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Hotel: 'Hotel',
    Amenities: 'Amenities',
    TourPriceCategory: 'TourPriceCategory',
    Tour: 'Tour',
    Activity: 'Activity',
    SpaPriceCategory: 'SpaPriceCategory',
    Spa: 'Spa',
    TVChannels: 'TVChannels',
    Restaurant: 'Restaurant',
    Menu: 'Menu',
    Table: 'Table',
    Customer: 'Customer',
    Reservation: 'Reservation',
    Category: 'Category',
    Subcategory: 'Subcategory',
    SubSubcategory: 'SubSubcategory',
    Dish: 'Dish',
    OpeningHours: 'OpeningHours'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "hotel" | "amenities" | "tourPriceCategory" | "tour" | "activity" | "spaPriceCategory" | "spa" | "tVChannels" | "restaurant" | "menu" | "table" | "customer" | "reservation" | "category" | "subcategory" | "subSubcategory" | "dish" | "openingHours"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Hotel: {
        payload: Prisma.$HotelPayload<ExtArgs>
        fields: Prisma.HotelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          findFirst: {
            args: Prisma.HotelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          findMany: {
            args: Prisma.HotelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>[]
          }
          create: {
            args: Prisma.HotelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          createMany: {
            args: Prisma.HotelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>[]
          }
          delete: {
            args: Prisma.HotelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          update: {
            args: Prisma.HotelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          deleteMany: {
            args: Prisma.HotelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HotelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>[]
          }
          upsert: {
            args: Prisma.HotelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          aggregate: {
            args: Prisma.HotelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotel>
          }
          groupBy: {
            args: Prisma.HotelGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelCountArgs<ExtArgs>
            result: $Utils.Optional<HotelCountAggregateOutputType> | number
          }
        }
      }
      Amenities: {
        payload: Prisma.$AmenitiesPayload<ExtArgs>
        fields: Prisma.AmenitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmenitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmenitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          findFirst: {
            args: Prisma.AmenitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmenitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          findMany: {
            args: Prisma.AmenitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>[]
          }
          create: {
            args: Prisma.AmenitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          createMany: {
            args: Prisma.AmenitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AmenitiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>[]
          }
          delete: {
            args: Prisma.AmenitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          update: {
            args: Prisma.AmenitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          deleteMany: {
            args: Prisma.AmenitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmenitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AmenitiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>[]
          }
          upsert: {
            args: Prisma.AmenitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          aggregate: {
            args: Prisma.AmenitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmenities>
          }
          groupBy: {
            args: Prisma.AmenitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmenitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmenitiesCountArgs<ExtArgs>
            result: $Utils.Optional<AmenitiesCountAggregateOutputType> | number
          }
        }
      }
      TourPriceCategory: {
        payload: Prisma.$TourPriceCategoryPayload<ExtArgs>
        fields: Prisma.TourPriceCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TourPriceCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPriceCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TourPriceCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPriceCategoryPayload>
          }
          findFirst: {
            args: Prisma.TourPriceCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPriceCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TourPriceCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPriceCategoryPayload>
          }
          findMany: {
            args: Prisma.TourPriceCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPriceCategoryPayload>[]
          }
          create: {
            args: Prisma.TourPriceCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPriceCategoryPayload>
          }
          createMany: {
            args: Prisma.TourPriceCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TourPriceCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPriceCategoryPayload>[]
          }
          delete: {
            args: Prisma.TourPriceCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPriceCategoryPayload>
          }
          update: {
            args: Prisma.TourPriceCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPriceCategoryPayload>
          }
          deleteMany: {
            args: Prisma.TourPriceCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TourPriceCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TourPriceCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPriceCategoryPayload>[]
          }
          upsert: {
            args: Prisma.TourPriceCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPriceCategoryPayload>
          }
          aggregate: {
            args: Prisma.TourPriceCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTourPriceCategory>
          }
          groupBy: {
            args: Prisma.TourPriceCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TourPriceCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TourPriceCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<TourPriceCategoryCountAggregateOutputType> | number
          }
        }
      }
      Tour: {
        payload: Prisma.$TourPayload<ExtArgs>
        fields: Prisma.TourFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TourFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TourFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          findFirst: {
            args: Prisma.TourFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TourFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          findMany: {
            args: Prisma.TourFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>[]
          }
          create: {
            args: Prisma.TourCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          createMany: {
            args: Prisma.TourCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TourCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>[]
          }
          delete: {
            args: Prisma.TourDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          update: {
            args: Prisma.TourUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          deleteMany: {
            args: Prisma.TourDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TourUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TourUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>[]
          }
          upsert: {
            args: Prisma.TourUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          aggregate: {
            args: Prisma.TourAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTour>
          }
          groupBy: {
            args: Prisma.TourGroupByArgs<ExtArgs>
            result: $Utils.Optional<TourGroupByOutputType>[]
          }
          count: {
            args: Prisma.TourCountArgs<ExtArgs>
            result: $Utils.Optional<TourCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      SpaPriceCategory: {
        payload: Prisma.$SpaPriceCategoryPayload<ExtArgs>
        fields: Prisma.SpaPriceCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpaPriceCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaPriceCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpaPriceCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaPriceCategoryPayload>
          }
          findFirst: {
            args: Prisma.SpaPriceCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaPriceCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpaPriceCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaPriceCategoryPayload>
          }
          findMany: {
            args: Prisma.SpaPriceCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaPriceCategoryPayload>[]
          }
          create: {
            args: Prisma.SpaPriceCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaPriceCategoryPayload>
          }
          createMany: {
            args: Prisma.SpaPriceCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpaPriceCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaPriceCategoryPayload>[]
          }
          delete: {
            args: Prisma.SpaPriceCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaPriceCategoryPayload>
          }
          update: {
            args: Prisma.SpaPriceCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaPriceCategoryPayload>
          }
          deleteMany: {
            args: Prisma.SpaPriceCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpaPriceCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpaPriceCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaPriceCategoryPayload>[]
          }
          upsert: {
            args: Prisma.SpaPriceCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaPriceCategoryPayload>
          }
          aggregate: {
            args: Prisma.SpaPriceCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpaPriceCategory>
          }
          groupBy: {
            args: Prisma.SpaPriceCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpaPriceCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpaPriceCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<SpaPriceCategoryCountAggregateOutputType> | number
          }
        }
      }
      Spa: {
        payload: Prisma.$SpaPayload<ExtArgs>
        fields: Prisma.SpaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaPayload>
          }
          findFirst: {
            args: Prisma.SpaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaPayload>
          }
          findMany: {
            args: Prisma.SpaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaPayload>[]
          }
          create: {
            args: Prisma.SpaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaPayload>
          }
          createMany: {
            args: Prisma.SpaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaPayload>[]
          }
          delete: {
            args: Prisma.SpaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaPayload>
          }
          update: {
            args: Prisma.SpaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaPayload>
          }
          deleteMany: {
            args: Prisma.SpaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaPayload>[]
          }
          upsert: {
            args: Prisma.SpaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaPayload>
          }
          aggregate: {
            args: Prisma.SpaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpa>
          }
          groupBy: {
            args: Prisma.SpaGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpaGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpaCountArgs<ExtArgs>
            result: $Utils.Optional<SpaCountAggregateOutputType> | number
          }
        }
      }
      TVChannels: {
        payload: Prisma.$TVChannelsPayload<ExtArgs>
        fields: Prisma.TVChannelsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TVChannelsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVChannelsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TVChannelsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVChannelsPayload>
          }
          findFirst: {
            args: Prisma.TVChannelsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVChannelsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TVChannelsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVChannelsPayload>
          }
          findMany: {
            args: Prisma.TVChannelsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVChannelsPayload>[]
          }
          create: {
            args: Prisma.TVChannelsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVChannelsPayload>
          }
          createMany: {
            args: Prisma.TVChannelsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TVChannelsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVChannelsPayload>[]
          }
          delete: {
            args: Prisma.TVChannelsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVChannelsPayload>
          }
          update: {
            args: Prisma.TVChannelsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVChannelsPayload>
          }
          deleteMany: {
            args: Prisma.TVChannelsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TVChannelsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TVChannelsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVChannelsPayload>[]
          }
          upsert: {
            args: Prisma.TVChannelsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TVChannelsPayload>
          }
          aggregate: {
            args: Prisma.TVChannelsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTVChannels>
          }
          groupBy: {
            args: Prisma.TVChannelsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TVChannelsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TVChannelsCountArgs<ExtArgs>
            result: $Utils.Optional<TVChannelsCountAggregateOutputType> | number
          }
        }
      }
      Restaurant: {
        payload: Prisma.$RestaurantPayload<ExtArgs>
        fields: Prisma.RestaurantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RestaurantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RestaurantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          findFirst: {
            args: Prisma.RestaurantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RestaurantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          findMany: {
            args: Prisma.RestaurantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>[]
          }
          create: {
            args: Prisma.RestaurantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          createMany: {
            args: Prisma.RestaurantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RestaurantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>[]
          }
          delete: {
            args: Prisma.RestaurantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          update: {
            args: Prisma.RestaurantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          deleteMany: {
            args: Prisma.RestaurantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RestaurantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RestaurantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>[]
          }
          upsert: {
            args: Prisma.RestaurantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantPayload>
          }
          aggregate: {
            args: Prisma.RestaurantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRestaurant>
          }
          groupBy: {
            args: Prisma.RestaurantGroupByArgs<ExtArgs>
            result: $Utils.Optional<RestaurantGroupByOutputType>[]
          }
          count: {
            args: Prisma.RestaurantCountArgs<ExtArgs>
            result: $Utils.Optional<RestaurantCountAggregateOutputType> | number
          }
        }
      }
      Menu: {
        payload: Prisma.$MenuPayload<ExtArgs>
        fields: Prisma.MenuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          findFirst: {
            args: Prisma.MenuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          findMany: {
            args: Prisma.MenuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          create: {
            args: Prisma.MenuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          createMany: {
            args: Prisma.MenuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenuCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          delete: {
            args: Prisma.MenuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          update: {
            args: Prisma.MenuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          deleteMany: {
            args: Prisma.MenuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenuUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          upsert: {
            args: Prisma.MenuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          aggregate: {
            args: Prisma.MenuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenu>
          }
          groupBy: {
            args: Prisma.MenuGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenuCountArgs<ExtArgs>
            result: $Utils.Optional<MenuCountAggregateOutputType> | number
          }
        }
      }
      Table: {
        payload: Prisma.$TablePayload<ExtArgs>
        fields: Prisma.TableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          findFirst: {
            args: Prisma.TableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          findMany: {
            args: Prisma.TableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>[]
          }
          create: {
            args: Prisma.TableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          createMany: {
            args: Prisma.TableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>[]
          }
          delete: {
            args: Prisma.TableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          update: {
            args: Prisma.TableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          deleteMany: {
            args: Prisma.TableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>[]
          }
          upsert: {
            args: Prisma.TableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          aggregate: {
            args: Prisma.TableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTable>
          }
          groupBy: {
            args: Prisma.TableGroupByArgs<ExtArgs>
            result: $Utils.Optional<TableGroupByOutputType>[]
          }
          count: {
            args: Prisma.TableCountArgs<ExtArgs>
            result: $Utils.Optional<TableCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Reservation: {
        payload: Prisma.$ReservationPayload<ExtArgs>
        fields: Prisma.ReservationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReservationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReservationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findFirst: {
            args: Prisma.ReservationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReservationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findMany: {
            args: Prisma.ReservationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          create: {
            args: Prisma.ReservationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          createMany: {
            args: Prisma.ReservationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReservationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          delete: {
            args: Prisma.ReservationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          update: {
            args: Prisma.ReservationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          deleteMany: {
            args: Prisma.ReservationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReservationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReservationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          upsert: {
            args: Prisma.ReservationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          aggregate: {
            args: Prisma.ReservationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReservation>
          }
          groupBy: {
            args: Prisma.ReservationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReservationCountArgs<ExtArgs>
            result: $Utils.Optional<ReservationCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Subcategory: {
        payload: Prisma.$SubcategoryPayload<ExtArgs>
        fields: Prisma.SubcategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubcategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubcategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          findFirst: {
            args: Prisma.SubcategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubcategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          findMany: {
            args: Prisma.SubcategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>[]
          }
          create: {
            args: Prisma.SubcategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          createMany: {
            args: Prisma.SubcategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubcategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>[]
          }
          delete: {
            args: Prisma.SubcategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          update: {
            args: Prisma.SubcategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          deleteMany: {
            args: Prisma.SubcategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubcategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubcategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>[]
          }
          upsert: {
            args: Prisma.SubcategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          aggregate: {
            args: Prisma.SubcategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubcategory>
          }
          groupBy: {
            args: Prisma.SubcategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubcategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubcategoryCountArgs<ExtArgs>
            result: $Utils.Optional<SubcategoryCountAggregateOutputType> | number
          }
        }
      }
      SubSubcategory: {
        payload: Prisma.$SubSubcategoryPayload<ExtArgs>
        fields: Prisma.SubSubcategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubSubcategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubSubcategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubSubcategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubSubcategoryPayload>
          }
          findFirst: {
            args: Prisma.SubSubcategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubSubcategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubSubcategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubSubcategoryPayload>
          }
          findMany: {
            args: Prisma.SubSubcategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubSubcategoryPayload>[]
          }
          create: {
            args: Prisma.SubSubcategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubSubcategoryPayload>
          }
          createMany: {
            args: Prisma.SubSubcategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubSubcategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubSubcategoryPayload>[]
          }
          delete: {
            args: Prisma.SubSubcategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubSubcategoryPayload>
          }
          update: {
            args: Prisma.SubSubcategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubSubcategoryPayload>
          }
          deleteMany: {
            args: Prisma.SubSubcategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubSubcategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubSubcategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubSubcategoryPayload>[]
          }
          upsert: {
            args: Prisma.SubSubcategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubSubcategoryPayload>
          }
          aggregate: {
            args: Prisma.SubSubcategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubSubcategory>
          }
          groupBy: {
            args: Prisma.SubSubcategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubSubcategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubSubcategoryCountArgs<ExtArgs>
            result: $Utils.Optional<SubSubcategoryCountAggregateOutputType> | number
          }
        }
      }
      Dish: {
        payload: Prisma.$DishPayload<ExtArgs>
        fields: Prisma.DishFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DishFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DishFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>
          }
          findFirst: {
            args: Prisma.DishFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DishFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>
          }
          findMany: {
            args: Prisma.DishFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>[]
          }
          create: {
            args: Prisma.DishCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>
          }
          createMany: {
            args: Prisma.DishCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DishCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>[]
          }
          delete: {
            args: Prisma.DishDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>
          }
          update: {
            args: Prisma.DishUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>
          }
          deleteMany: {
            args: Prisma.DishDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DishUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DishUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>[]
          }
          upsert: {
            args: Prisma.DishUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>
          }
          aggregate: {
            args: Prisma.DishAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDish>
          }
          groupBy: {
            args: Prisma.DishGroupByArgs<ExtArgs>
            result: $Utils.Optional<DishGroupByOutputType>[]
          }
          count: {
            args: Prisma.DishCountArgs<ExtArgs>
            result: $Utils.Optional<DishCountAggregateOutputType> | number
          }
        }
      }
      OpeningHours: {
        payload: Prisma.$OpeningHoursPayload<ExtArgs>
        fields: Prisma.OpeningHoursFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpeningHoursFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpeningHoursPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpeningHoursFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpeningHoursPayload>
          }
          findFirst: {
            args: Prisma.OpeningHoursFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpeningHoursPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpeningHoursFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpeningHoursPayload>
          }
          findMany: {
            args: Prisma.OpeningHoursFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpeningHoursPayload>[]
          }
          create: {
            args: Prisma.OpeningHoursCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpeningHoursPayload>
          }
          createMany: {
            args: Prisma.OpeningHoursCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OpeningHoursCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpeningHoursPayload>[]
          }
          delete: {
            args: Prisma.OpeningHoursDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpeningHoursPayload>
          }
          update: {
            args: Prisma.OpeningHoursUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpeningHoursPayload>
          }
          deleteMany: {
            args: Prisma.OpeningHoursDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpeningHoursUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OpeningHoursUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpeningHoursPayload>[]
          }
          upsert: {
            args: Prisma.OpeningHoursUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpeningHoursPayload>
          }
          aggregate: {
            args: Prisma.OpeningHoursAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpeningHours>
          }
          groupBy: {
            args: Prisma.OpeningHoursGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpeningHoursGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpeningHoursCountArgs<ExtArgs>
            result: $Utils.Optional<OpeningHoursCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    hotel?: HotelOmit
    amenities?: AmenitiesOmit
    tourPriceCategory?: TourPriceCategoryOmit
    tour?: TourOmit
    activity?: ActivityOmit
    spaPriceCategory?: SpaPriceCategoryOmit
    spa?: SpaOmit
    tVChannels?: TVChannelsOmit
    restaurant?: RestaurantOmit
    menu?: MenuOmit
    table?: TableOmit
    customer?: CustomerOmit
    reservation?: ReservationOmit
    category?: CategoryOmit
    subcategory?: SubcategoryOmit
    subSubcategory?: SubSubcategoryOmit
    dish?: DishOmit
    openingHours?: OpeningHoursOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type HotelCountOutputType
   */

  export type HotelCountOutputType = {
    activities: number
    tours: number
    spa: number
    amenities: number
    tvchannels: number
  }

  export type HotelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | HotelCountOutputTypeCountActivitiesArgs
    tours?: boolean | HotelCountOutputTypeCountToursArgs
    spa?: boolean | HotelCountOutputTypeCountSpaArgs
    amenities?: boolean | HotelCountOutputTypeCountAmenitiesArgs
    tvchannels?: boolean | HotelCountOutputTypeCountTvchannelsArgs
  }

  // Custom InputTypes
  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCountOutputType
     */
    select?: HotelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountToursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountSpaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountAmenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenitiesWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountTvchannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TVChannelsWhereInput
  }


  /**
   * Count Type TourCountOutputType
   */

  export type TourCountOutputType = {
    pricecategory: number
  }

  export type TourCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pricecategory?: boolean | TourCountOutputTypeCountPricecategoryArgs
  }

  // Custom InputTypes
  /**
   * TourCountOutputType without action
   */
  export type TourCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourCountOutputType
     */
    select?: TourCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TourCountOutputType without action
   */
  export type TourCountOutputTypeCountPricecategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourPriceCategoryWhereInput
  }


  /**
   * Count Type SpaCountOutputType
   */

  export type SpaCountOutputType = {
    pricecategory: number
  }

  export type SpaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pricecategory?: boolean | SpaCountOutputTypeCountPricecategoryArgs
  }

  // Custom InputTypes
  /**
   * SpaCountOutputType without action
   */
  export type SpaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaCountOutputType
     */
    select?: SpaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpaCountOutputType without action
   */
  export type SpaCountOutputTypeCountPricecategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaPriceCategoryWhereInput
  }


  /**
   * Count Type RestaurantCountOutputType
   */

  export type RestaurantCountOutputType = {
    categories: number
    dishes: number
    menus: number
    tables: number
    reservations: number
    openingHours: number
  }

  export type RestaurantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | RestaurantCountOutputTypeCountCategoriesArgs
    dishes?: boolean | RestaurantCountOutputTypeCountDishesArgs
    menus?: boolean | RestaurantCountOutputTypeCountMenusArgs
    tables?: boolean | RestaurantCountOutputTypeCountTablesArgs
    reservations?: boolean | RestaurantCountOutputTypeCountReservationsArgs
    openingHours?: boolean | RestaurantCountOutputTypeCountOpeningHoursArgs
  }

  // Custom InputTypes
  /**
   * RestaurantCountOutputType without action
   */
  export type RestaurantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantCountOutputType
     */
    select?: RestaurantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RestaurantCountOutputType without action
   */
  export type RestaurantCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * RestaurantCountOutputType without action
   */
  export type RestaurantCountOutputTypeCountDishesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DishWhereInput
  }

  /**
   * RestaurantCountOutputType without action
   */
  export type RestaurantCountOutputTypeCountMenusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuWhereInput
  }

  /**
   * RestaurantCountOutputType without action
   */
  export type RestaurantCountOutputTypeCountTablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableWhereInput
  }

  /**
   * RestaurantCountOutputType without action
   */
  export type RestaurantCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * RestaurantCountOutputType without action
   */
  export type RestaurantCountOutputTypeCountOpeningHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpeningHoursWhereInput
  }


  /**
   * Count Type MenuCountOutputType
   */

  export type MenuCountOutputType = {
    dishes: number
  }

  export type MenuCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dishes?: boolean | MenuCountOutputTypeCountDishesArgs
  }

  // Custom InputTypes
  /**
   * MenuCountOutputType without action
   */
  export type MenuCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuCountOutputType
     */
    select?: MenuCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MenuCountOutputType without action
   */
  export type MenuCountOutputTypeCountDishesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DishWhereInput
  }


  /**
   * Count Type TableCountOutputType
   */

  export type TableCountOutputType = {
    reservations: number
  }

  export type TableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservations?: boolean | TableCountOutputTypeCountReservationsArgs
  }

  // Custom InputTypes
  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableCountOutputType
     */
    select?: TableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    reservations: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservations?: boolean | CustomerCountOutputTypeCountReservationsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    dishes: number
    subcategories: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dishes?: boolean | CategoryCountOutputTypeCountDishesArgs
    subcategories?: boolean | CategoryCountOutputTypeCountSubcategoriesArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountDishesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DishWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountSubcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubcategoryWhereInput
  }


  /**
   * Count Type SubcategoryCountOutputType
   */

  export type SubcategoryCountOutputType = {
    dishes: number
    subSubcategories: number
  }

  export type SubcategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dishes?: boolean | SubcategoryCountOutputTypeCountDishesArgs
    subSubcategories?: boolean | SubcategoryCountOutputTypeCountSubSubcategoriesArgs
  }

  // Custom InputTypes
  /**
   * SubcategoryCountOutputType without action
   */
  export type SubcategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubcategoryCountOutputType
     */
    select?: SubcategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubcategoryCountOutputType without action
   */
  export type SubcategoryCountOutputTypeCountDishesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DishWhereInput
  }

  /**
   * SubcategoryCountOutputType without action
   */
  export type SubcategoryCountOutputTypeCountSubSubcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubSubcategoryWhereInput
  }


  /**
   * Count Type SubSubcategoryCountOutputType
   */

  export type SubSubcategoryCountOutputType = {
    dishes: number
  }

  export type SubSubcategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dishes?: boolean | SubSubcategoryCountOutputTypeCountDishesArgs
  }

  // Custom InputTypes
  /**
   * SubSubcategoryCountOutputType without action
   */
  export type SubSubcategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubSubcategoryCountOutputType
     */
    select?: SubSubcategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubSubcategoryCountOutputType without action
   */
  export type SubSubcategoryCountOutputTypeCountDishesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DishWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Hotel
   */

  export type AggregateHotel = {
    _count: HotelCountAggregateOutputType | null
    _avg: HotelAvgAggregateOutputType | null
    _sum: HotelSumAggregateOutputType | null
    _min: HotelMinAggregateOutputType | null
    _max: HotelMaxAggregateOutputType | null
  }

  export type HotelAvgAggregateOutputType = {
    lat: number | null
    lng: number | null
  }

  export type HotelSumAggregateOutputType = {
    lat: number | null
    lng: number | null
  }

  export type HotelMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    description_esp: string | null
    image: string | null
    country: string | null
    state: string | null
    city: string | null
    locationDescription: string | null
    locationDescription_esp: string | null
    lat: number | null
    lng: number | null
    phone: string | null
    phone_reservation: string | null
    phone_tollfree: string | null
    email: string | null
    website: string | null
    facebook: string | null
    tripadvisor: string | null
    instagram: string | null
    youtube: string | null
    whatsapp: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    description_esp: string | null
    image: string | null
    country: string | null
    state: string | null
    city: string | null
    locationDescription: string | null
    locationDescription_esp: string | null
    lat: number | null
    lng: number | null
    phone: string | null
    phone_reservation: string | null
    phone_tollfree: string | null
    email: string | null
    website: string | null
    facebook: string | null
    tripadvisor: string | null
    instagram: string | null
    youtube: string | null
    whatsapp: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelCountAggregateOutputType = {
    id: number
    name: number
    description: number
    description_esp: number
    image: number
    country: number
    state: number
    city: number
    locationDescription: number
    locationDescription_esp: number
    images: number
    videos: number
    lat: number
    lng: number
    phone: number
    phone_reservation: number
    phone_tollfree: number
    email: number
    website: number
    facebook: number
    tripadvisor: number
    instagram: number
    youtube: number
    whatsapp: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HotelAvgAggregateInputType = {
    lat?: true
    lng?: true
  }

  export type HotelSumAggregateInputType = {
    lat?: true
    lng?: true
  }

  export type HotelMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    description_esp?: true
    image?: true
    country?: true
    state?: true
    city?: true
    locationDescription?: true
    locationDescription_esp?: true
    lat?: true
    lng?: true
    phone?: true
    phone_reservation?: true
    phone_tollfree?: true
    email?: true
    website?: true
    facebook?: true
    tripadvisor?: true
    instagram?: true
    youtube?: true
    whatsapp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    description_esp?: true
    image?: true
    country?: true
    state?: true
    city?: true
    locationDescription?: true
    locationDescription_esp?: true
    lat?: true
    lng?: true
    phone?: true
    phone_reservation?: true
    phone_tollfree?: true
    email?: true
    website?: true
    facebook?: true
    tripadvisor?: true
    instagram?: true
    youtube?: true
    whatsapp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    description_esp?: true
    image?: true
    country?: true
    state?: true
    city?: true
    locationDescription?: true
    locationDescription_esp?: true
    images?: true
    videos?: true
    lat?: true
    lng?: true
    phone?: true
    phone_reservation?: true
    phone_tollfree?: true
    email?: true
    website?: true
    facebook?: true
    tripadvisor?: true
    instagram?: true
    youtube?: true
    whatsapp?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HotelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hotel to aggregate.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hotels
    **/
    _count?: true | HotelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelMaxAggregateInputType
  }

  export type GetHotelAggregateType<T extends HotelAggregateArgs> = {
        [P in keyof T & keyof AggregateHotel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotel[P]>
      : GetScalarType<T[P], AggregateHotel[P]>
  }




  export type HotelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelWhereInput
    orderBy?: HotelOrderByWithAggregationInput | HotelOrderByWithAggregationInput[]
    by: HotelScalarFieldEnum[] | HotelScalarFieldEnum
    having?: HotelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelCountAggregateInputType | true
    _avg?: HotelAvgAggregateInputType
    _sum?: HotelSumAggregateInputType
    _min?: HotelMinAggregateInputType
    _max?: HotelMaxAggregateInputType
  }

  export type HotelGroupByOutputType = {
    id: string
    name: string
    description: string
    description_esp: string
    image: string
    country: string
    state: string
    city: string
    locationDescription: string
    locationDescription_esp: string
    images: string[]
    videos: string[]
    lat: number
    lng: number
    phone: string
    phone_reservation: string | null
    phone_tollfree: string | null
    email: string
    website: string
    facebook: string | null
    tripadvisor: string | null
    instagram: string | null
    youtube: string | null
    whatsapp: string | null
    createdAt: Date
    updatedAt: Date
    _count: HotelCountAggregateOutputType | null
    _avg: HotelAvgAggregateOutputType | null
    _sum: HotelSumAggregateOutputType | null
    _min: HotelMinAggregateOutputType | null
    _max: HotelMaxAggregateOutputType | null
  }

  type GetHotelGroupByPayload<T extends HotelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelGroupByOutputType[P]>
            : GetScalarType<T[P], HotelGroupByOutputType[P]>
        }
      >
    >


  export type HotelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    locationDescription?: boolean
    locationDescription_esp?: boolean
    images?: boolean
    videos?: boolean
    lat?: boolean
    lng?: boolean
    phone?: boolean
    phone_reservation?: boolean
    phone_tollfree?: boolean
    email?: boolean
    website?: boolean
    facebook?: boolean
    tripadvisor?: boolean
    instagram?: boolean
    youtube?: boolean
    whatsapp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    activities?: boolean | Hotel$activitiesArgs<ExtArgs>
    tours?: boolean | Hotel$toursArgs<ExtArgs>
    spa?: boolean | Hotel$spaArgs<ExtArgs>
    amenities?: boolean | Hotel$amenitiesArgs<ExtArgs>
    tvchannels?: boolean | Hotel$tvchannelsArgs<ExtArgs>
    _count?: boolean | HotelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotel"]>

  export type HotelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    locationDescription?: boolean
    locationDescription_esp?: boolean
    images?: boolean
    videos?: boolean
    lat?: boolean
    lng?: boolean
    phone?: boolean
    phone_reservation?: boolean
    phone_tollfree?: boolean
    email?: boolean
    website?: boolean
    facebook?: boolean
    tripadvisor?: boolean
    instagram?: boolean
    youtube?: boolean
    whatsapp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hotel"]>

  export type HotelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    locationDescription?: boolean
    locationDescription_esp?: boolean
    images?: boolean
    videos?: boolean
    lat?: boolean
    lng?: boolean
    phone?: boolean
    phone_reservation?: boolean
    phone_tollfree?: boolean
    email?: boolean
    website?: boolean
    facebook?: boolean
    tripadvisor?: boolean
    instagram?: boolean
    youtube?: boolean
    whatsapp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hotel"]>

  export type HotelSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    locationDescription?: boolean
    locationDescription_esp?: boolean
    images?: boolean
    videos?: boolean
    lat?: boolean
    lng?: boolean
    phone?: boolean
    phone_reservation?: boolean
    phone_tollfree?: boolean
    email?: boolean
    website?: boolean
    facebook?: boolean
    tripadvisor?: boolean
    instagram?: boolean
    youtube?: boolean
    whatsapp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HotelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "description_esp" | "image" | "country" | "state" | "city" | "locationDescription" | "locationDescription_esp" | "images" | "videos" | "lat" | "lng" | "phone" | "phone_reservation" | "phone_tollfree" | "email" | "website" | "facebook" | "tripadvisor" | "instagram" | "youtube" | "whatsapp" | "createdAt" | "updatedAt", ExtArgs["result"]["hotel"]>
  export type HotelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | Hotel$activitiesArgs<ExtArgs>
    tours?: boolean | Hotel$toursArgs<ExtArgs>
    spa?: boolean | Hotel$spaArgs<ExtArgs>
    amenities?: boolean | Hotel$amenitiesArgs<ExtArgs>
    tvchannels?: boolean | Hotel$tvchannelsArgs<ExtArgs>
    _count?: boolean | HotelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type HotelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HotelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hotel"
    objects: {
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      tours: Prisma.$TourPayload<ExtArgs>[]
      spa: Prisma.$SpaPayload<ExtArgs>[]
      amenities: Prisma.$AmenitiesPayload<ExtArgs>[]
      tvchannels: Prisma.$TVChannelsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      description_esp: string
      image: string
      country: string
      state: string
      city: string
      locationDescription: string
      locationDescription_esp: string
      images: string[]
      videos: string[]
      lat: number
      lng: number
      phone: string
      phone_reservation: string | null
      phone_tollfree: string | null
      email: string
      website: string
      facebook: string | null
      tripadvisor: string | null
      instagram: string | null
      youtube: string | null
      whatsapp: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hotel"]>
    composites: {}
  }

  type HotelGetPayload<S extends boolean | null | undefined | HotelDefaultArgs> = $Result.GetResult<Prisma.$HotelPayload, S>

  type HotelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: HotelCountAggregateInputType | true
    }

  export interface HotelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hotel'], meta: { name: 'Hotel' } }
    /**
     * Find zero or one Hotel that matches the filter.
     * @param {HotelFindUniqueArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelFindUniqueArgs>(args: SelectSubset<T, HotelFindUniqueArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hotel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelFindUniqueOrThrowArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hotel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindFirstArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelFindFirstArgs>(args?: SelectSubset<T, HotelFindFirstArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hotel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindFirstOrThrowArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hotels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hotels
     * const hotels = await prisma.hotel.findMany()
     * 
     * // Get first 10 Hotels
     * const hotels = await prisma.hotel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelWithIdOnly = await prisma.hotel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelFindManyArgs>(args?: SelectSubset<T, HotelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hotel.
     * @param {HotelCreateArgs} args - Arguments to create a Hotel.
     * @example
     * // Create one Hotel
     * const Hotel = await prisma.hotel.create({
     *   data: {
     *     // ... data to create a Hotel
     *   }
     * })
     * 
     */
    create<T extends HotelCreateArgs>(args: SelectSubset<T, HotelCreateArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hotels.
     * @param {HotelCreateManyArgs} args - Arguments to create many Hotels.
     * @example
     * // Create many Hotels
     * const hotel = await prisma.hotel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelCreateManyArgs>(args?: SelectSubset<T, HotelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hotels and returns the data saved in the database.
     * @param {HotelCreateManyAndReturnArgs} args - Arguments to create many Hotels.
     * @example
     * // Create many Hotels
     * const hotel = await prisma.hotel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hotels and only return the `id`
     * const hotelWithIdOnly = await prisma.hotel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Hotel.
     * @param {HotelDeleteArgs} args - Arguments to delete one Hotel.
     * @example
     * // Delete one Hotel
     * const Hotel = await prisma.hotel.delete({
     *   where: {
     *     // ... filter to delete one Hotel
     *   }
     * })
     * 
     */
    delete<T extends HotelDeleteArgs>(args: SelectSubset<T, HotelDeleteArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hotel.
     * @param {HotelUpdateArgs} args - Arguments to update one Hotel.
     * @example
     * // Update one Hotel
     * const hotel = await prisma.hotel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelUpdateArgs>(args: SelectSubset<T, HotelUpdateArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hotels.
     * @param {HotelDeleteManyArgs} args - Arguments to filter Hotels to delete.
     * @example
     * // Delete a few Hotels
     * const { count } = await prisma.hotel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelDeleteManyArgs>(args?: SelectSubset<T, HotelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hotels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hotels
     * const hotel = await prisma.hotel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelUpdateManyArgs>(args: SelectSubset<T, HotelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hotels and returns the data updated in the database.
     * @param {HotelUpdateManyAndReturnArgs} args - Arguments to update many Hotels.
     * @example
     * // Update many Hotels
     * const hotel = await prisma.hotel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Hotels and only return the `id`
     * const hotelWithIdOnly = await prisma.hotel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HotelUpdateManyAndReturnArgs>(args: SelectSubset<T, HotelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Hotel.
     * @param {HotelUpsertArgs} args - Arguments to update or create a Hotel.
     * @example
     * // Update or create a Hotel
     * const hotel = await prisma.hotel.upsert({
     *   create: {
     *     // ... data to create a Hotel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hotel we want to update
     *   }
     * })
     */
    upsert<T extends HotelUpsertArgs>(args: SelectSubset<T, HotelUpsertArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hotels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCountArgs} args - Arguments to filter Hotels to count.
     * @example
     * // Count the number of Hotels
     * const count = await prisma.hotel.count({
     *   where: {
     *     // ... the filter for the Hotels we want to count
     *   }
     * })
    **/
    count<T extends HotelCountArgs>(
      args?: Subset<T, HotelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hotel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelAggregateArgs>(args: Subset<T, HotelAggregateArgs>): Prisma.PrismaPromise<GetHotelAggregateType<T>>

    /**
     * Group by Hotel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelGroupByArgs['orderBy'] }
        : { orderBy?: HotelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hotel model
   */
  readonly fields: HotelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hotel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activities<T extends Hotel$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tours<T extends Hotel$toursArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$toursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    spa<T extends Hotel$spaArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$spaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    amenities<T extends Hotel$amenitiesArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$amenitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tvchannels<T extends Hotel$tvchannelsArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$tvchannelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TVChannelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hotel model
   */
  interface HotelFieldRefs {
    readonly id: FieldRef<"Hotel", 'String'>
    readonly name: FieldRef<"Hotel", 'String'>
    readonly description: FieldRef<"Hotel", 'String'>
    readonly description_esp: FieldRef<"Hotel", 'String'>
    readonly image: FieldRef<"Hotel", 'String'>
    readonly country: FieldRef<"Hotel", 'String'>
    readonly state: FieldRef<"Hotel", 'String'>
    readonly city: FieldRef<"Hotel", 'String'>
    readonly locationDescription: FieldRef<"Hotel", 'String'>
    readonly locationDescription_esp: FieldRef<"Hotel", 'String'>
    readonly images: FieldRef<"Hotel", 'String[]'>
    readonly videos: FieldRef<"Hotel", 'String[]'>
    readonly lat: FieldRef<"Hotel", 'Int'>
    readonly lng: FieldRef<"Hotel", 'Int'>
    readonly phone: FieldRef<"Hotel", 'String'>
    readonly phone_reservation: FieldRef<"Hotel", 'String'>
    readonly phone_tollfree: FieldRef<"Hotel", 'String'>
    readonly email: FieldRef<"Hotel", 'String'>
    readonly website: FieldRef<"Hotel", 'String'>
    readonly facebook: FieldRef<"Hotel", 'String'>
    readonly tripadvisor: FieldRef<"Hotel", 'String'>
    readonly instagram: FieldRef<"Hotel", 'String'>
    readonly youtube: FieldRef<"Hotel", 'String'>
    readonly whatsapp: FieldRef<"Hotel", 'String'>
    readonly createdAt: FieldRef<"Hotel", 'DateTime'>
    readonly updatedAt: FieldRef<"Hotel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Hotel findUnique
   */
  export type HotelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where: HotelWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Hotel findUniqueOrThrow
   */
  export type HotelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where: HotelWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Hotel findFirst
   */
  export type HotelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hotels.
     */
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Hotel findFirstOrThrow
   */
  export type HotelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hotels.
     */
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Hotel findMany
   */
  export type HotelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotels to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Hotel create
   */
  export type HotelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The data needed to create a Hotel.
     */
    data: XOR<HotelCreateInput, HotelUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Hotel createMany
   */
  export type HotelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hotels.
     */
    data: HotelCreateManyInput | HotelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hotel createManyAndReturn
   */
  export type HotelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * The data used to create many Hotels.
     */
    data: HotelCreateManyInput | HotelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hotel update
   */
  export type HotelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The data needed to update a Hotel.
     */
    data: XOR<HotelUpdateInput, HotelUncheckedUpdateInput>
    /**
     * Choose, which Hotel to update.
     */
    where: HotelWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Hotel updateMany
   */
  export type HotelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hotels.
     */
    data: XOR<HotelUpdateManyMutationInput, HotelUncheckedUpdateManyInput>
    /**
     * Filter which Hotels to update
     */
    where?: HotelWhereInput
    /**
     * Limit how many Hotels to update.
     */
    limit?: number
  }

  /**
   * Hotel updateManyAndReturn
   */
  export type HotelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * The data used to update Hotels.
     */
    data: XOR<HotelUpdateManyMutationInput, HotelUncheckedUpdateManyInput>
    /**
     * Filter which Hotels to update
     */
    where?: HotelWhereInput
    /**
     * Limit how many Hotels to update.
     */
    limit?: number
  }

  /**
   * Hotel upsert
   */
  export type HotelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The filter to search for the Hotel to update in case it exists.
     */
    where: HotelWhereUniqueInput
    /**
     * In case the Hotel found by the `where` argument doesn't exist, create a new Hotel with this data.
     */
    create: XOR<HotelCreateInput, HotelUncheckedCreateInput>
    /**
     * In case the Hotel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelUpdateInput, HotelUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Hotel delete
   */
  export type HotelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter which Hotel to delete.
     */
    where: HotelWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Hotel deleteMany
   */
  export type HotelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hotels to delete
     */
    where?: HotelWhereInput
    /**
     * Limit how many Hotels to delete.
     */
    limit?: number
  }

  /**
   * Hotel.activities
   */
  export type Hotel$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Hotel.tours
   */
  export type Hotel$toursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tour
     */
    omit?: TourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    where?: TourWhereInput
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    cursor?: TourWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
  }

  /**
   * Hotel.spa
   */
  export type Hotel$spaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spa
     */
    select?: SpaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spa
     */
    omit?: SpaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaInclude<ExtArgs> | null
    where?: SpaWhereInput
    orderBy?: SpaOrderByWithRelationInput | SpaOrderByWithRelationInput[]
    cursor?: SpaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpaScalarFieldEnum | SpaScalarFieldEnum[]
  }

  /**
   * Hotel.amenities
   */
  export type Hotel$amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesInclude<ExtArgs> | null
    where?: AmenitiesWhereInput
    orderBy?: AmenitiesOrderByWithRelationInput | AmenitiesOrderByWithRelationInput[]
    cursor?: AmenitiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AmenitiesScalarFieldEnum | AmenitiesScalarFieldEnum[]
  }

  /**
   * Hotel.tvchannels
   */
  export type Hotel$tvchannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVChannels
     */
    select?: TVChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVChannels
     */
    omit?: TVChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVChannelsInclude<ExtArgs> | null
    where?: TVChannelsWhereInput
    orderBy?: TVChannelsOrderByWithRelationInput | TVChannelsOrderByWithRelationInput[]
    cursor?: TVChannelsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TVChannelsScalarFieldEnum | TVChannelsScalarFieldEnum[]
  }

  /**
   * Hotel without action
   */
  export type HotelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
  }


  /**
   * Model Amenities
   */

  export type AggregateAmenities = {
    _count: AmenitiesCountAggregateOutputType | null
    _min: AmenitiesMinAggregateOutputType | null
    _max: AmenitiesMaxAggregateOutputType | null
  }

  export type AmenitiesMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    image: string | null
    amenitiestype: $Enums.AMENITIESTYPE | null
    hotelId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmenitiesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    image: string | null
    amenitiestype: $Enums.AMENITIESTYPE | null
    hotelId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmenitiesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    icon: number
    image: number
    amenitiestype: number
    hotelId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AmenitiesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    image?: true
    amenitiestype?: true
    hotelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmenitiesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    image?: true
    amenitiestype?: true
    hotelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmenitiesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    image?: true
    amenitiestype?: true
    hotelId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AmenitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenities to aggregate.
     */
    where?: AmenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenitiesOrderByWithRelationInput | AmenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Amenities
    **/
    _count?: true | AmenitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmenitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmenitiesMaxAggregateInputType
  }

  export type GetAmenitiesAggregateType<T extends AmenitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateAmenities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmenities[P]>
      : GetScalarType<T[P], AggregateAmenities[P]>
  }




  export type AmenitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenitiesWhereInput
    orderBy?: AmenitiesOrderByWithAggregationInput | AmenitiesOrderByWithAggregationInput[]
    by: AmenitiesScalarFieldEnum[] | AmenitiesScalarFieldEnum
    having?: AmenitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmenitiesCountAggregateInputType | true
    _min?: AmenitiesMinAggregateInputType
    _max?: AmenitiesMaxAggregateInputType
  }

  export type AmenitiesGroupByOutputType = {
    id: string
    name: string
    description: string
    icon: string
    image: string
    amenitiestype: $Enums.AMENITIESTYPE
    hotelId: string
    createdAt: Date
    updatedAt: Date
    _count: AmenitiesCountAggregateOutputType | null
    _min: AmenitiesMinAggregateOutputType | null
    _max: AmenitiesMaxAggregateOutputType | null
  }

  type GetAmenitiesGroupByPayload<T extends AmenitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmenitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmenitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmenitiesGroupByOutputType[P]>
            : GetScalarType<T[P], AmenitiesGroupByOutputType[P]>
        }
      >
    >


  export type AmenitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    image?: boolean
    amenitiestype?: boolean
    hotelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Hotel?: boolean | Amenities$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["amenities"]>

  export type AmenitiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    image?: boolean
    amenitiestype?: boolean
    hotelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Hotel?: boolean | Amenities$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["amenities"]>

  export type AmenitiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    image?: boolean
    amenitiestype?: boolean
    hotelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Hotel?: boolean | Amenities$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["amenities"]>

  export type AmenitiesSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    image?: boolean
    amenitiestype?: boolean
    hotelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AmenitiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "icon" | "image" | "amenitiestype" | "hotelId" | "createdAt" | "updatedAt", ExtArgs["result"]["amenities"]>
  export type AmenitiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | Amenities$HotelArgs<ExtArgs>
  }
  export type AmenitiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | Amenities$HotelArgs<ExtArgs>
  }
  export type AmenitiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | Amenities$HotelArgs<ExtArgs>
  }

  export type $AmenitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Amenities"
    objects: {
      Hotel: Prisma.$HotelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      icon: string
      image: string
      amenitiestype: $Enums.AMENITIESTYPE
      hotelId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["amenities"]>
    composites: {}
  }

  type AmenitiesGetPayload<S extends boolean | null | undefined | AmenitiesDefaultArgs> = $Result.GetResult<Prisma.$AmenitiesPayload, S>

  type AmenitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmenitiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AmenitiesCountAggregateInputType | true
    }

  export interface AmenitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Amenities'], meta: { name: 'Amenities' } }
    /**
     * Find zero or one Amenities that matches the filter.
     * @param {AmenitiesFindUniqueArgs} args - Arguments to find a Amenities
     * @example
     * // Get one Amenities
     * const amenities = await prisma.amenities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmenitiesFindUniqueArgs>(args: SelectSubset<T, AmenitiesFindUniqueArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Amenities that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmenitiesFindUniqueOrThrowArgs} args - Arguments to find a Amenities
     * @example
     * // Get one Amenities
     * const amenities = await prisma.amenities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmenitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, AmenitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesFindFirstArgs} args - Arguments to find a Amenities
     * @example
     * // Get one Amenities
     * const amenities = await prisma.amenities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmenitiesFindFirstArgs>(args?: SelectSubset<T, AmenitiesFindFirstArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesFindFirstOrThrowArgs} args - Arguments to find a Amenities
     * @example
     * // Get one Amenities
     * const amenities = await prisma.amenities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmenitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, AmenitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Amenities
     * const amenities = await prisma.amenities.findMany()
     * 
     * // Get first 10 Amenities
     * const amenities = await prisma.amenities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amenitiesWithIdOnly = await prisma.amenities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmenitiesFindManyArgs>(args?: SelectSubset<T, AmenitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Amenities.
     * @param {AmenitiesCreateArgs} args - Arguments to create a Amenities.
     * @example
     * // Create one Amenities
     * const Amenities = await prisma.amenities.create({
     *   data: {
     *     // ... data to create a Amenities
     *   }
     * })
     * 
     */
    create<T extends AmenitiesCreateArgs>(args: SelectSubset<T, AmenitiesCreateArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Amenities.
     * @param {AmenitiesCreateManyArgs} args - Arguments to create many Amenities.
     * @example
     * // Create many Amenities
     * const amenities = await prisma.amenities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmenitiesCreateManyArgs>(args?: SelectSubset<T, AmenitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Amenities and returns the data saved in the database.
     * @param {AmenitiesCreateManyAndReturnArgs} args - Arguments to create many Amenities.
     * @example
     * // Create many Amenities
     * const amenities = await prisma.amenities.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Amenities and only return the `id`
     * const amenitiesWithIdOnly = await prisma.amenities.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AmenitiesCreateManyAndReturnArgs>(args?: SelectSubset<T, AmenitiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Amenities.
     * @param {AmenitiesDeleteArgs} args - Arguments to delete one Amenities.
     * @example
     * // Delete one Amenities
     * const Amenities = await prisma.amenities.delete({
     *   where: {
     *     // ... filter to delete one Amenities
     *   }
     * })
     * 
     */
    delete<T extends AmenitiesDeleteArgs>(args: SelectSubset<T, AmenitiesDeleteArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Amenities.
     * @param {AmenitiesUpdateArgs} args - Arguments to update one Amenities.
     * @example
     * // Update one Amenities
     * const amenities = await prisma.amenities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmenitiesUpdateArgs>(args: SelectSubset<T, AmenitiesUpdateArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Amenities.
     * @param {AmenitiesDeleteManyArgs} args - Arguments to filter Amenities to delete.
     * @example
     * // Delete a few Amenities
     * const { count } = await prisma.amenities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmenitiesDeleteManyArgs>(args?: SelectSubset<T, AmenitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Amenities
     * const amenities = await prisma.amenities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmenitiesUpdateManyArgs>(args: SelectSubset<T, AmenitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amenities and returns the data updated in the database.
     * @param {AmenitiesUpdateManyAndReturnArgs} args - Arguments to update many Amenities.
     * @example
     * // Update many Amenities
     * const amenities = await prisma.amenities.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Amenities and only return the `id`
     * const amenitiesWithIdOnly = await prisma.amenities.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AmenitiesUpdateManyAndReturnArgs>(args: SelectSubset<T, AmenitiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Amenities.
     * @param {AmenitiesUpsertArgs} args - Arguments to update or create a Amenities.
     * @example
     * // Update or create a Amenities
     * const amenities = await prisma.amenities.upsert({
     *   create: {
     *     // ... data to create a Amenities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Amenities we want to update
     *   }
     * })
     */
    upsert<T extends AmenitiesUpsertArgs>(args: SelectSubset<T, AmenitiesUpsertArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesCountArgs} args - Arguments to filter Amenities to count.
     * @example
     * // Count the number of Amenities
     * const count = await prisma.amenities.count({
     *   where: {
     *     // ... the filter for the Amenities we want to count
     *   }
     * })
    **/
    count<T extends AmenitiesCountArgs>(
      args?: Subset<T, AmenitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmenitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmenitiesAggregateArgs>(args: Subset<T, AmenitiesAggregateArgs>): Prisma.PrismaPromise<GetAmenitiesAggregateType<T>>

    /**
     * Group by Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmenitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmenitiesGroupByArgs['orderBy'] }
        : { orderBy?: AmenitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmenitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmenitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Amenities model
   */
  readonly fields: AmenitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Amenities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmenitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Hotel<T extends Amenities$HotelArgs<ExtArgs> = {}>(args?: Subset<T, Amenities$HotelArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Amenities model
   */
  interface AmenitiesFieldRefs {
    readonly id: FieldRef<"Amenities", 'String'>
    readonly name: FieldRef<"Amenities", 'String'>
    readonly description: FieldRef<"Amenities", 'String'>
    readonly icon: FieldRef<"Amenities", 'String'>
    readonly image: FieldRef<"Amenities", 'String'>
    readonly amenitiestype: FieldRef<"Amenities", 'AMENITIESTYPE'>
    readonly hotelId: FieldRef<"Amenities", 'String'>
    readonly createdAt: FieldRef<"Amenities", 'DateTime'>
    readonly updatedAt: FieldRef<"Amenities", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Amenities findUnique
   */
  export type AmenitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where: AmenitiesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Amenities findUniqueOrThrow
   */
  export type AmenitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where: AmenitiesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Amenities findFirst
   */
  export type AmenitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where?: AmenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenitiesOrderByWithRelationInput | AmenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenitiesScalarFieldEnum | AmenitiesScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Amenities findFirstOrThrow
   */
  export type AmenitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where?: AmenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenitiesOrderByWithRelationInput | AmenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenitiesScalarFieldEnum | AmenitiesScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Amenities findMany
   */
  export type AmenitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where?: AmenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenitiesOrderByWithRelationInput | AmenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Amenities.
     */
    cursor?: AmenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    distinct?: AmenitiesScalarFieldEnum | AmenitiesScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Amenities create
   */
  export type AmenitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * The data needed to create a Amenities.
     */
    data: XOR<AmenitiesCreateInput, AmenitiesUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Amenities createMany
   */
  export type AmenitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Amenities.
     */
    data: AmenitiesCreateManyInput | AmenitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Amenities createManyAndReturn
   */
  export type AmenitiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * The data used to create many Amenities.
     */
    data: AmenitiesCreateManyInput | AmenitiesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Amenities update
   */
  export type AmenitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * The data needed to update a Amenities.
     */
    data: XOR<AmenitiesUpdateInput, AmenitiesUncheckedUpdateInput>
    /**
     * Choose, which Amenities to update.
     */
    where: AmenitiesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Amenities updateMany
   */
  export type AmenitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Amenities.
     */
    data: XOR<AmenitiesUpdateManyMutationInput, AmenitiesUncheckedUpdateManyInput>
    /**
     * Filter which Amenities to update
     */
    where?: AmenitiesWhereInput
    /**
     * Limit how many Amenities to update.
     */
    limit?: number
  }

  /**
   * Amenities updateManyAndReturn
   */
  export type AmenitiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * The data used to update Amenities.
     */
    data: XOR<AmenitiesUpdateManyMutationInput, AmenitiesUncheckedUpdateManyInput>
    /**
     * Filter which Amenities to update
     */
    where?: AmenitiesWhereInput
    /**
     * Limit how many Amenities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Amenities upsert
   */
  export type AmenitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * The filter to search for the Amenities to update in case it exists.
     */
    where: AmenitiesWhereUniqueInput
    /**
     * In case the Amenities found by the `where` argument doesn't exist, create a new Amenities with this data.
     */
    create: XOR<AmenitiesCreateInput, AmenitiesUncheckedCreateInput>
    /**
     * In case the Amenities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmenitiesUpdateInput, AmenitiesUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Amenities delete
   */
  export type AmenitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * Filter which Amenities to delete.
     */
    where: AmenitiesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Amenities deleteMany
   */
  export type AmenitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenities to delete
     */
    where?: AmenitiesWhereInput
    /**
     * Limit how many Amenities to delete.
     */
    limit?: number
  }

  /**
   * Amenities.Hotel
   */
  export type Amenities$HotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    where?: HotelWhereInput
  }

  /**
   * Amenities without action
   */
  export type AmenitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesInclude<ExtArgs> | null
  }


  /**
   * Model TourPriceCategory
   */

  export type AggregateTourPriceCategory = {
    _count: TourPriceCategoryCountAggregateOutputType | null
    _avg: TourPriceCategoryAvgAggregateOutputType | null
    _sum: TourPriceCategorySumAggregateOutputType | null
    _min: TourPriceCategoryMinAggregateOutputType | null
    _max: TourPriceCategoryMaxAggregateOutputType | null
  }

  export type TourPriceCategoryAvgAggregateOutputType = {
    sku: number | null
    price: number | null
  }

  export type TourPriceCategorySumAggregateOutputType = {
    sku: number | null
    price: number | null
  }

  export type TourPriceCategoryMinAggregateOutputType = {
    id: string | null
    sku: number | null
    price: number | null
    description: string | null
    description_esp: string | null
    tourId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TourPriceCategoryMaxAggregateOutputType = {
    id: string | null
    sku: number | null
    price: number | null
    description: string | null
    description_esp: string | null
    tourId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TourPriceCategoryCountAggregateOutputType = {
    id: number
    sku: number
    price: number
    description: number
    description_esp: number
    tourId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TourPriceCategoryAvgAggregateInputType = {
    sku?: true
    price?: true
  }

  export type TourPriceCategorySumAggregateInputType = {
    sku?: true
    price?: true
  }

  export type TourPriceCategoryMinAggregateInputType = {
    id?: true
    sku?: true
    price?: true
    description?: true
    description_esp?: true
    tourId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TourPriceCategoryMaxAggregateInputType = {
    id?: true
    sku?: true
    price?: true
    description?: true
    description_esp?: true
    tourId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TourPriceCategoryCountAggregateInputType = {
    id?: true
    sku?: true
    price?: true
    description?: true
    description_esp?: true
    tourId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TourPriceCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TourPriceCategory to aggregate.
     */
    where?: TourPriceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourPriceCategories to fetch.
     */
    orderBy?: TourPriceCategoryOrderByWithRelationInput | TourPriceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TourPriceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourPriceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourPriceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TourPriceCategories
    **/
    _count?: true | TourPriceCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TourPriceCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TourPriceCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TourPriceCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TourPriceCategoryMaxAggregateInputType
  }

  export type GetTourPriceCategoryAggregateType<T extends TourPriceCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTourPriceCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTourPriceCategory[P]>
      : GetScalarType<T[P], AggregateTourPriceCategory[P]>
  }




  export type TourPriceCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourPriceCategoryWhereInput
    orderBy?: TourPriceCategoryOrderByWithAggregationInput | TourPriceCategoryOrderByWithAggregationInput[]
    by: TourPriceCategoryScalarFieldEnum[] | TourPriceCategoryScalarFieldEnum
    having?: TourPriceCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TourPriceCategoryCountAggregateInputType | true
    _avg?: TourPriceCategoryAvgAggregateInputType
    _sum?: TourPriceCategorySumAggregateInputType
    _min?: TourPriceCategoryMinAggregateInputType
    _max?: TourPriceCategoryMaxAggregateInputType
  }

  export type TourPriceCategoryGroupByOutputType = {
    id: string
    sku: number
    price: number
    description: string
    description_esp: string
    tourId: string
    createdAt: Date
    updatedAt: Date
    _count: TourPriceCategoryCountAggregateOutputType | null
    _avg: TourPriceCategoryAvgAggregateOutputType | null
    _sum: TourPriceCategorySumAggregateOutputType | null
    _min: TourPriceCategoryMinAggregateOutputType | null
    _max: TourPriceCategoryMaxAggregateOutputType | null
  }

  type GetTourPriceCategoryGroupByPayload<T extends TourPriceCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TourPriceCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TourPriceCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TourPriceCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], TourPriceCategoryGroupByOutputType[P]>
        }
      >
    >


  export type TourPriceCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    price?: boolean
    description?: boolean
    description_esp?: boolean
    tourId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Tour?: boolean | TourPriceCategory$TourArgs<ExtArgs>
  }, ExtArgs["result"]["tourPriceCategory"]>

  export type TourPriceCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    price?: boolean
    description?: boolean
    description_esp?: boolean
    tourId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Tour?: boolean | TourPriceCategory$TourArgs<ExtArgs>
  }, ExtArgs["result"]["tourPriceCategory"]>

  export type TourPriceCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    price?: boolean
    description?: boolean
    description_esp?: boolean
    tourId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Tour?: boolean | TourPriceCategory$TourArgs<ExtArgs>
  }, ExtArgs["result"]["tourPriceCategory"]>

  export type TourPriceCategorySelectScalar = {
    id?: boolean
    sku?: boolean
    price?: boolean
    description?: boolean
    description_esp?: boolean
    tourId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TourPriceCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sku" | "price" | "description" | "description_esp" | "tourId" | "createdAt" | "updatedAt", ExtArgs["result"]["tourPriceCategory"]>
  export type TourPriceCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tour?: boolean | TourPriceCategory$TourArgs<ExtArgs>
  }
  export type TourPriceCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tour?: boolean | TourPriceCategory$TourArgs<ExtArgs>
  }
  export type TourPriceCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tour?: boolean | TourPriceCategory$TourArgs<ExtArgs>
  }

  export type $TourPriceCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TourPriceCategory"
    objects: {
      Tour: Prisma.$TourPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sku: number
      price: number
      description: string
      description_esp: string
      tourId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tourPriceCategory"]>
    composites: {}
  }

  type TourPriceCategoryGetPayload<S extends boolean | null | undefined | TourPriceCategoryDefaultArgs> = $Result.GetResult<Prisma.$TourPriceCategoryPayload, S>

  type TourPriceCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TourPriceCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: TourPriceCategoryCountAggregateInputType | true
    }

  export interface TourPriceCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TourPriceCategory'], meta: { name: 'TourPriceCategory' } }
    /**
     * Find zero or one TourPriceCategory that matches the filter.
     * @param {TourPriceCategoryFindUniqueArgs} args - Arguments to find a TourPriceCategory
     * @example
     * // Get one TourPriceCategory
     * const tourPriceCategory = await prisma.tourPriceCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TourPriceCategoryFindUniqueArgs>(args: SelectSubset<T, TourPriceCategoryFindUniqueArgs<ExtArgs>>): Prisma__TourPriceCategoryClient<$Result.GetResult<Prisma.$TourPriceCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TourPriceCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TourPriceCategoryFindUniqueOrThrowArgs} args - Arguments to find a TourPriceCategory
     * @example
     * // Get one TourPriceCategory
     * const tourPriceCategory = await prisma.tourPriceCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TourPriceCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, TourPriceCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TourPriceCategoryClient<$Result.GetResult<Prisma.$TourPriceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TourPriceCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourPriceCategoryFindFirstArgs} args - Arguments to find a TourPriceCategory
     * @example
     * // Get one TourPriceCategory
     * const tourPriceCategory = await prisma.tourPriceCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TourPriceCategoryFindFirstArgs>(args?: SelectSubset<T, TourPriceCategoryFindFirstArgs<ExtArgs>>): Prisma__TourPriceCategoryClient<$Result.GetResult<Prisma.$TourPriceCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TourPriceCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourPriceCategoryFindFirstOrThrowArgs} args - Arguments to find a TourPriceCategory
     * @example
     * // Get one TourPriceCategory
     * const tourPriceCategory = await prisma.tourPriceCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TourPriceCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, TourPriceCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TourPriceCategoryClient<$Result.GetResult<Prisma.$TourPriceCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TourPriceCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourPriceCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TourPriceCategories
     * const tourPriceCategories = await prisma.tourPriceCategory.findMany()
     * 
     * // Get first 10 TourPriceCategories
     * const tourPriceCategories = await prisma.tourPriceCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tourPriceCategoryWithIdOnly = await prisma.tourPriceCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TourPriceCategoryFindManyArgs>(args?: SelectSubset<T, TourPriceCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourPriceCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TourPriceCategory.
     * @param {TourPriceCategoryCreateArgs} args - Arguments to create a TourPriceCategory.
     * @example
     * // Create one TourPriceCategory
     * const TourPriceCategory = await prisma.tourPriceCategory.create({
     *   data: {
     *     // ... data to create a TourPriceCategory
     *   }
     * })
     * 
     */
    create<T extends TourPriceCategoryCreateArgs>(args: SelectSubset<T, TourPriceCategoryCreateArgs<ExtArgs>>): Prisma__TourPriceCategoryClient<$Result.GetResult<Prisma.$TourPriceCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TourPriceCategories.
     * @param {TourPriceCategoryCreateManyArgs} args - Arguments to create many TourPriceCategories.
     * @example
     * // Create many TourPriceCategories
     * const tourPriceCategory = await prisma.tourPriceCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TourPriceCategoryCreateManyArgs>(args?: SelectSubset<T, TourPriceCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TourPriceCategories and returns the data saved in the database.
     * @param {TourPriceCategoryCreateManyAndReturnArgs} args - Arguments to create many TourPriceCategories.
     * @example
     * // Create many TourPriceCategories
     * const tourPriceCategory = await prisma.tourPriceCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TourPriceCategories and only return the `id`
     * const tourPriceCategoryWithIdOnly = await prisma.tourPriceCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TourPriceCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, TourPriceCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourPriceCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TourPriceCategory.
     * @param {TourPriceCategoryDeleteArgs} args - Arguments to delete one TourPriceCategory.
     * @example
     * // Delete one TourPriceCategory
     * const TourPriceCategory = await prisma.tourPriceCategory.delete({
     *   where: {
     *     // ... filter to delete one TourPriceCategory
     *   }
     * })
     * 
     */
    delete<T extends TourPriceCategoryDeleteArgs>(args: SelectSubset<T, TourPriceCategoryDeleteArgs<ExtArgs>>): Prisma__TourPriceCategoryClient<$Result.GetResult<Prisma.$TourPriceCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TourPriceCategory.
     * @param {TourPriceCategoryUpdateArgs} args - Arguments to update one TourPriceCategory.
     * @example
     * // Update one TourPriceCategory
     * const tourPriceCategory = await prisma.tourPriceCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TourPriceCategoryUpdateArgs>(args: SelectSubset<T, TourPriceCategoryUpdateArgs<ExtArgs>>): Prisma__TourPriceCategoryClient<$Result.GetResult<Prisma.$TourPriceCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TourPriceCategories.
     * @param {TourPriceCategoryDeleteManyArgs} args - Arguments to filter TourPriceCategories to delete.
     * @example
     * // Delete a few TourPriceCategories
     * const { count } = await prisma.tourPriceCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TourPriceCategoryDeleteManyArgs>(args?: SelectSubset<T, TourPriceCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TourPriceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourPriceCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TourPriceCategories
     * const tourPriceCategory = await prisma.tourPriceCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TourPriceCategoryUpdateManyArgs>(args: SelectSubset<T, TourPriceCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TourPriceCategories and returns the data updated in the database.
     * @param {TourPriceCategoryUpdateManyAndReturnArgs} args - Arguments to update many TourPriceCategories.
     * @example
     * // Update many TourPriceCategories
     * const tourPriceCategory = await prisma.tourPriceCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TourPriceCategories and only return the `id`
     * const tourPriceCategoryWithIdOnly = await prisma.tourPriceCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TourPriceCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, TourPriceCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourPriceCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TourPriceCategory.
     * @param {TourPriceCategoryUpsertArgs} args - Arguments to update or create a TourPriceCategory.
     * @example
     * // Update or create a TourPriceCategory
     * const tourPriceCategory = await prisma.tourPriceCategory.upsert({
     *   create: {
     *     // ... data to create a TourPriceCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TourPriceCategory we want to update
     *   }
     * })
     */
    upsert<T extends TourPriceCategoryUpsertArgs>(args: SelectSubset<T, TourPriceCategoryUpsertArgs<ExtArgs>>): Prisma__TourPriceCategoryClient<$Result.GetResult<Prisma.$TourPriceCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TourPriceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourPriceCategoryCountArgs} args - Arguments to filter TourPriceCategories to count.
     * @example
     * // Count the number of TourPriceCategories
     * const count = await prisma.tourPriceCategory.count({
     *   where: {
     *     // ... the filter for the TourPriceCategories we want to count
     *   }
     * })
    **/
    count<T extends TourPriceCategoryCountArgs>(
      args?: Subset<T, TourPriceCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TourPriceCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TourPriceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourPriceCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TourPriceCategoryAggregateArgs>(args: Subset<T, TourPriceCategoryAggregateArgs>): Prisma.PrismaPromise<GetTourPriceCategoryAggregateType<T>>

    /**
     * Group by TourPriceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourPriceCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TourPriceCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TourPriceCategoryGroupByArgs['orderBy'] }
        : { orderBy?: TourPriceCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TourPriceCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTourPriceCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TourPriceCategory model
   */
  readonly fields: TourPriceCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TourPriceCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TourPriceCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Tour<T extends TourPriceCategory$TourArgs<ExtArgs> = {}>(args?: Subset<T, TourPriceCategory$TourArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TourPriceCategory model
   */
  interface TourPriceCategoryFieldRefs {
    readonly id: FieldRef<"TourPriceCategory", 'String'>
    readonly sku: FieldRef<"TourPriceCategory", 'Int'>
    readonly price: FieldRef<"TourPriceCategory", 'Int'>
    readonly description: FieldRef<"TourPriceCategory", 'String'>
    readonly description_esp: FieldRef<"TourPriceCategory", 'String'>
    readonly tourId: FieldRef<"TourPriceCategory", 'String'>
    readonly createdAt: FieldRef<"TourPriceCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"TourPriceCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TourPriceCategory findUnique
   */
  export type TourPriceCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourPriceCategory
     */
    select?: TourPriceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourPriceCategory
     */
    omit?: TourPriceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourPriceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TourPriceCategory to fetch.
     */
    where: TourPriceCategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TourPriceCategory findUniqueOrThrow
   */
  export type TourPriceCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourPriceCategory
     */
    select?: TourPriceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourPriceCategory
     */
    omit?: TourPriceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourPriceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TourPriceCategory to fetch.
     */
    where: TourPriceCategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TourPriceCategory findFirst
   */
  export type TourPriceCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourPriceCategory
     */
    select?: TourPriceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourPriceCategory
     */
    omit?: TourPriceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourPriceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TourPriceCategory to fetch.
     */
    where?: TourPriceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourPriceCategories to fetch.
     */
    orderBy?: TourPriceCategoryOrderByWithRelationInput | TourPriceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TourPriceCategories.
     */
    cursor?: TourPriceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourPriceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourPriceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TourPriceCategories.
     */
    distinct?: TourPriceCategoryScalarFieldEnum | TourPriceCategoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TourPriceCategory findFirstOrThrow
   */
  export type TourPriceCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourPriceCategory
     */
    select?: TourPriceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourPriceCategory
     */
    omit?: TourPriceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourPriceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TourPriceCategory to fetch.
     */
    where?: TourPriceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourPriceCategories to fetch.
     */
    orderBy?: TourPriceCategoryOrderByWithRelationInput | TourPriceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TourPriceCategories.
     */
    cursor?: TourPriceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourPriceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourPriceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TourPriceCategories.
     */
    distinct?: TourPriceCategoryScalarFieldEnum | TourPriceCategoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TourPriceCategory findMany
   */
  export type TourPriceCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourPriceCategory
     */
    select?: TourPriceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourPriceCategory
     */
    omit?: TourPriceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourPriceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TourPriceCategories to fetch.
     */
    where?: TourPriceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TourPriceCategories to fetch.
     */
    orderBy?: TourPriceCategoryOrderByWithRelationInput | TourPriceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TourPriceCategories.
     */
    cursor?: TourPriceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TourPriceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TourPriceCategories.
     */
    skip?: number
    distinct?: TourPriceCategoryScalarFieldEnum | TourPriceCategoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TourPriceCategory create
   */
  export type TourPriceCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourPriceCategory
     */
    select?: TourPriceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourPriceCategory
     */
    omit?: TourPriceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourPriceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a TourPriceCategory.
     */
    data: XOR<TourPriceCategoryCreateInput, TourPriceCategoryUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TourPriceCategory createMany
   */
  export type TourPriceCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TourPriceCategories.
     */
    data: TourPriceCategoryCreateManyInput | TourPriceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TourPriceCategory createManyAndReturn
   */
  export type TourPriceCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourPriceCategory
     */
    select?: TourPriceCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TourPriceCategory
     */
    omit?: TourPriceCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many TourPriceCategories.
     */
    data: TourPriceCategoryCreateManyInput | TourPriceCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourPriceCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TourPriceCategory update
   */
  export type TourPriceCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourPriceCategory
     */
    select?: TourPriceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourPriceCategory
     */
    omit?: TourPriceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourPriceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a TourPriceCategory.
     */
    data: XOR<TourPriceCategoryUpdateInput, TourPriceCategoryUncheckedUpdateInput>
    /**
     * Choose, which TourPriceCategory to update.
     */
    where: TourPriceCategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TourPriceCategory updateMany
   */
  export type TourPriceCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TourPriceCategories.
     */
    data: XOR<TourPriceCategoryUpdateManyMutationInput, TourPriceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which TourPriceCategories to update
     */
    where?: TourPriceCategoryWhereInput
    /**
     * Limit how many TourPriceCategories to update.
     */
    limit?: number
  }

  /**
   * TourPriceCategory updateManyAndReturn
   */
  export type TourPriceCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourPriceCategory
     */
    select?: TourPriceCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TourPriceCategory
     */
    omit?: TourPriceCategoryOmit<ExtArgs> | null
    /**
     * The data used to update TourPriceCategories.
     */
    data: XOR<TourPriceCategoryUpdateManyMutationInput, TourPriceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which TourPriceCategories to update
     */
    where?: TourPriceCategoryWhereInput
    /**
     * Limit how many TourPriceCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourPriceCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TourPriceCategory upsert
   */
  export type TourPriceCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourPriceCategory
     */
    select?: TourPriceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourPriceCategory
     */
    omit?: TourPriceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourPriceCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the TourPriceCategory to update in case it exists.
     */
    where: TourPriceCategoryWhereUniqueInput
    /**
     * In case the TourPriceCategory found by the `where` argument doesn't exist, create a new TourPriceCategory with this data.
     */
    create: XOR<TourPriceCategoryCreateInput, TourPriceCategoryUncheckedCreateInput>
    /**
     * In case the TourPriceCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TourPriceCategoryUpdateInput, TourPriceCategoryUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TourPriceCategory delete
   */
  export type TourPriceCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourPriceCategory
     */
    select?: TourPriceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourPriceCategory
     */
    omit?: TourPriceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourPriceCategoryInclude<ExtArgs> | null
    /**
     * Filter which TourPriceCategory to delete.
     */
    where: TourPriceCategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TourPriceCategory deleteMany
   */
  export type TourPriceCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TourPriceCategories to delete
     */
    where?: TourPriceCategoryWhereInput
    /**
     * Limit how many TourPriceCategories to delete.
     */
    limit?: number
  }

  /**
   * TourPriceCategory.Tour
   */
  export type TourPriceCategory$TourArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tour
     */
    omit?: TourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    where?: TourWhereInput
  }

  /**
   * TourPriceCategory without action
   */
  export type TourPriceCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourPriceCategory
     */
    select?: TourPriceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourPriceCategory
     */
    omit?: TourPriceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourPriceCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Tour
   */

  export type AggregateTour = {
    _count: TourCountAggregateOutputType | null
    _avg: TourAvgAggregateOutputType | null
    _sum: TourSumAggregateOutputType | null
    _min: TourMinAggregateOutputType | null
    _max: TourMaxAggregateOutputType | null
  }

  export type TourAvgAggregateOutputType = {
    price: number | null
    priceKids: number | null
    discount: number | null
    maxPeople: number | null
    minPeople: number | null
    minAge: number | null
    duration: number | null
  }

  export type TourSumAggregateOutputType = {
    price: number | null
    priceKids: number | null
    discount: number | null
    maxPeople: number | null
    minPeople: number | null
    minAge: number | null
    duration: number | null
  }

  export type TourMinAggregateOutputType = {
    id: string | null
    name: string | null
    name_esp: string | null
    description: string | null
    description_esp: string | null
    image: string | null
    hotelId: string | null
    price: number | null
    priceKids: number | null
    category: string | null
    offer: boolean | null
    discount: number | null
    whattobring: string | null
    pickuptime: Date | null
    maxPeople: number | null
    minPeople: number | null
    minAge: number | null
    bestSeller: boolean | null
    priceInfo: string | null
    location: string | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TourMaxAggregateOutputType = {
    id: string | null
    name: string | null
    name_esp: string | null
    description: string | null
    description_esp: string | null
    image: string | null
    hotelId: string | null
    price: number | null
    priceKids: number | null
    category: string | null
    offer: boolean | null
    discount: number | null
    whattobring: string | null
    pickuptime: Date | null
    maxPeople: number | null
    minPeople: number | null
    minAge: number | null
    bestSeller: boolean | null
    priceInfo: string | null
    location: string | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TourCountAggregateOutputType = {
    id: number
    name: number
    name_esp: number
    description: number
    description_esp: number
    image: number
    hotelId: number
    price: number
    priceKids: number
    category: number
    offer: number
    discount: number
    whattobring: number
    included: number
    pickuptime: number
    maxPeople: number
    minPeople: number
    minAge: number
    bestSeller: number
    priceInfo: number
    location: number
    offered: number
    duration: number
    videos: number
    images: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TourAvgAggregateInputType = {
    price?: true
    priceKids?: true
    discount?: true
    maxPeople?: true
    minPeople?: true
    minAge?: true
    duration?: true
  }

  export type TourSumAggregateInputType = {
    price?: true
    priceKids?: true
    discount?: true
    maxPeople?: true
    minPeople?: true
    minAge?: true
    duration?: true
  }

  export type TourMinAggregateInputType = {
    id?: true
    name?: true
    name_esp?: true
    description?: true
    description_esp?: true
    image?: true
    hotelId?: true
    price?: true
    priceKids?: true
    category?: true
    offer?: true
    discount?: true
    whattobring?: true
    pickuptime?: true
    maxPeople?: true
    minPeople?: true
    minAge?: true
    bestSeller?: true
    priceInfo?: true
    location?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TourMaxAggregateInputType = {
    id?: true
    name?: true
    name_esp?: true
    description?: true
    description_esp?: true
    image?: true
    hotelId?: true
    price?: true
    priceKids?: true
    category?: true
    offer?: true
    discount?: true
    whattobring?: true
    pickuptime?: true
    maxPeople?: true
    minPeople?: true
    minAge?: true
    bestSeller?: true
    priceInfo?: true
    location?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TourCountAggregateInputType = {
    id?: true
    name?: true
    name_esp?: true
    description?: true
    description_esp?: true
    image?: true
    hotelId?: true
    price?: true
    priceKids?: true
    category?: true
    offer?: true
    discount?: true
    whattobring?: true
    included?: true
    pickuptime?: true
    maxPeople?: true
    minPeople?: true
    minAge?: true
    bestSeller?: true
    priceInfo?: true
    location?: true
    offered?: true
    duration?: true
    videos?: true
    images?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TourAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tour to aggregate.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tours
    **/
    _count?: true | TourCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TourAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TourSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TourMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TourMaxAggregateInputType
  }

  export type GetTourAggregateType<T extends TourAggregateArgs> = {
        [P in keyof T & keyof AggregateTour]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTour[P]>
      : GetScalarType<T[P], AggregateTour[P]>
  }




  export type TourGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourWhereInput
    orderBy?: TourOrderByWithAggregationInput | TourOrderByWithAggregationInput[]
    by: TourScalarFieldEnum[] | TourScalarFieldEnum
    having?: TourScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TourCountAggregateInputType | true
    _avg?: TourAvgAggregateInputType
    _sum?: TourSumAggregateInputType
    _min?: TourMinAggregateInputType
    _max?: TourMaxAggregateInputType
  }

  export type TourGroupByOutputType = {
    id: string
    name: string
    name_esp: string
    description: string
    description_esp: string
    image: string
    hotelId: string
    price: number
    priceKids: number
    category: string
    offer: boolean
    discount: number
    whattobring: string
    included: string[]
    pickuptime: Date
    maxPeople: number
    minPeople: number
    minAge: number
    bestSeller: boolean
    priceInfo: string
    location: string
    offered: string[]
    duration: number
    videos: string[]
    images: string[]
    createdAt: Date
    updatedAt: Date
    _count: TourCountAggregateOutputType | null
    _avg: TourAvgAggregateOutputType | null
    _sum: TourSumAggregateOutputType | null
    _min: TourMinAggregateOutputType | null
    _max: TourMaxAggregateOutputType | null
  }

  type GetTourGroupByPayload<T extends TourGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TourGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TourGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TourGroupByOutputType[P]>
            : GetScalarType<T[P], TourGroupByOutputType[P]>
        }
      >
    >


  export type TourSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    hotelId?: boolean
    price?: boolean
    priceKids?: boolean
    category?: boolean
    offer?: boolean
    discount?: boolean
    whattobring?: boolean
    included?: boolean
    pickuptime?: boolean
    maxPeople?: boolean
    minPeople?: boolean
    minAge?: boolean
    bestSeller?: boolean
    priceInfo?: boolean
    location?: boolean
    offered?: boolean
    duration?: boolean
    videos?: boolean
    images?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pricecategory?: boolean | Tour$pricecategoryArgs<ExtArgs>
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
    _count?: boolean | TourCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tour"]>

  export type TourSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    hotelId?: boolean
    price?: boolean
    priceKids?: boolean
    category?: boolean
    offer?: boolean
    discount?: boolean
    whattobring?: boolean
    included?: boolean
    pickuptime?: boolean
    maxPeople?: boolean
    minPeople?: boolean
    minAge?: boolean
    bestSeller?: boolean
    priceInfo?: boolean
    location?: boolean
    offered?: boolean
    duration?: boolean
    videos?: boolean
    images?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tour"]>

  export type TourSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    hotelId?: boolean
    price?: boolean
    priceKids?: boolean
    category?: boolean
    offer?: boolean
    discount?: boolean
    whattobring?: boolean
    included?: boolean
    pickuptime?: boolean
    maxPeople?: boolean
    minPeople?: boolean
    minAge?: boolean
    bestSeller?: boolean
    priceInfo?: boolean
    location?: boolean
    offered?: boolean
    duration?: boolean
    videos?: boolean
    images?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tour"]>

  export type TourSelectScalar = {
    id?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    hotelId?: boolean
    price?: boolean
    priceKids?: boolean
    category?: boolean
    offer?: boolean
    discount?: boolean
    whattobring?: boolean
    included?: boolean
    pickuptime?: boolean
    maxPeople?: boolean
    minPeople?: boolean
    minAge?: boolean
    bestSeller?: boolean
    priceInfo?: boolean
    location?: boolean
    offered?: boolean
    duration?: boolean
    videos?: boolean
    images?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TourOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "name_esp" | "description" | "description_esp" | "image" | "hotelId" | "price" | "priceKids" | "category" | "offer" | "discount" | "whattobring" | "included" | "pickuptime" | "maxPeople" | "minPeople" | "minAge" | "bestSeller" | "priceInfo" | "location" | "offered" | "duration" | "videos" | "images" | "createdAt" | "updatedAt", ExtArgs["result"]["tour"]>
  export type TourInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pricecategory?: boolean | Tour$pricecategoryArgs<ExtArgs>
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
    _count?: boolean | TourCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TourIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }
  export type TourIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }

  export type $TourPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tour"
    objects: {
      pricecategory: Prisma.$TourPriceCategoryPayload<ExtArgs>[]
      Hotel: Prisma.$HotelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      name_esp: string
      description: string
      description_esp: string
      image: string
      hotelId: string
      price: number
      priceKids: number
      category: string
      offer: boolean
      discount: number
      whattobring: string
      included: string[]
      pickuptime: Date
      maxPeople: number
      minPeople: number
      minAge: number
      bestSeller: boolean
      priceInfo: string
      location: string
      offered: string[]
      duration: number
      videos: string[]
      images: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tour"]>
    composites: {}
  }

  type TourGetPayload<S extends boolean | null | undefined | TourDefaultArgs> = $Result.GetResult<Prisma.$TourPayload, S>

  type TourCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TourFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: TourCountAggregateInputType | true
    }

  export interface TourDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tour'], meta: { name: 'Tour' } }
    /**
     * Find zero or one Tour that matches the filter.
     * @param {TourFindUniqueArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TourFindUniqueArgs>(args: SelectSubset<T, TourFindUniqueArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tour that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TourFindUniqueOrThrowArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TourFindUniqueOrThrowArgs>(args: SelectSubset<T, TourFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tour that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFindFirstArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TourFindFirstArgs>(args?: SelectSubset<T, TourFindFirstArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tour that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFindFirstOrThrowArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TourFindFirstOrThrowArgs>(args?: SelectSubset<T, TourFindFirstOrThrowArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tours
     * const tours = await prisma.tour.findMany()
     * 
     * // Get first 10 Tours
     * const tours = await prisma.tour.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tourWithIdOnly = await prisma.tour.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TourFindManyArgs>(args?: SelectSubset<T, TourFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tour.
     * @param {TourCreateArgs} args - Arguments to create a Tour.
     * @example
     * // Create one Tour
     * const Tour = await prisma.tour.create({
     *   data: {
     *     // ... data to create a Tour
     *   }
     * })
     * 
     */
    create<T extends TourCreateArgs>(args: SelectSubset<T, TourCreateArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tours.
     * @param {TourCreateManyArgs} args - Arguments to create many Tours.
     * @example
     * // Create many Tours
     * const tour = await prisma.tour.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TourCreateManyArgs>(args?: SelectSubset<T, TourCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tours and returns the data saved in the database.
     * @param {TourCreateManyAndReturnArgs} args - Arguments to create many Tours.
     * @example
     * // Create many Tours
     * const tour = await prisma.tour.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tours and only return the `id`
     * const tourWithIdOnly = await prisma.tour.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TourCreateManyAndReturnArgs>(args?: SelectSubset<T, TourCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tour.
     * @param {TourDeleteArgs} args - Arguments to delete one Tour.
     * @example
     * // Delete one Tour
     * const Tour = await prisma.tour.delete({
     *   where: {
     *     // ... filter to delete one Tour
     *   }
     * })
     * 
     */
    delete<T extends TourDeleteArgs>(args: SelectSubset<T, TourDeleteArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tour.
     * @param {TourUpdateArgs} args - Arguments to update one Tour.
     * @example
     * // Update one Tour
     * const tour = await prisma.tour.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TourUpdateArgs>(args: SelectSubset<T, TourUpdateArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tours.
     * @param {TourDeleteManyArgs} args - Arguments to filter Tours to delete.
     * @example
     * // Delete a few Tours
     * const { count } = await prisma.tour.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TourDeleteManyArgs>(args?: SelectSubset<T, TourDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tours
     * const tour = await prisma.tour.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TourUpdateManyArgs>(args: SelectSubset<T, TourUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tours and returns the data updated in the database.
     * @param {TourUpdateManyAndReturnArgs} args - Arguments to update many Tours.
     * @example
     * // Update many Tours
     * const tour = await prisma.tour.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tours and only return the `id`
     * const tourWithIdOnly = await prisma.tour.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TourUpdateManyAndReturnArgs>(args: SelectSubset<T, TourUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tour.
     * @param {TourUpsertArgs} args - Arguments to update or create a Tour.
     * @example
     * // Update or create a Tour
     * const tour = await prisma.tour.upsert({
     *   create: {
     *     // ... data to create a Tour
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tour we want to update
     *   }
     * })
     */
    upsert<T extends TourUpsertArgs>(args: SelectSubset<T, TourUpsertArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourCountArgs} args - Arguments to filter Tours to count.
     * @example
     * // Count the number of Tours
     * const count = await prisma.tour.count({
     *   where: {
     *     // ... the filter for the Tours we want to count
     *   }
     * })
    **/
    count<T extends TourCountArgs>(
      args?: Subset<T, TourCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TourCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TourAggregateArgs>(args: Subset<T, TourAggregateArgs>): Prisma.PrismaPromise<GetTourAggregateType<T>>

    /**
     * Group by Tour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TourGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TourGroupByArgs['orderBy'] }
        : { orderBy?: TourGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TourGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTourGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tour model
   */
  readonly fields: TourFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tour.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TourClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pricecategory<T extends Tour$pricecategoryArgs<ExtArgs> = {}>(args?: Subset<T, Tour$pricecategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourPriceCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Hotel<T extends HotelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelDefaultArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tour model
   */
  interface TourFieldRefs {
    readonly id: FieldRef<"Tour", 'String'>
    readonly name: FieldRef<"Tour", 'String'>
    readonly name_esp: FieldRef<"Tour", 'String'>
    readonly description: FieldRef<"Tour", 'String'>
    readonly description_esp: FieldRef<"Tour", 'String'>
    readonly image: FieldRef<"Tour", 'String'>
    readonly hotelId: FieldRef<"Tour", 'String'>
    readonly price: FieldRef<"Tour", 'Int'>
    readonly priceKids: FieldRef<"Tour", 'Int'>
    readonly category: FieldRef<"Tour", 'String'>
    readonly offer: FieldRef<"Tour", 'Boolean'>
    readonly discount: FieldRef<"Tour", 'Int'>
    readonly whattobring: FieldRef<"Tour", 'String'>
    readonly included: FieldRef<"Tour", 'String[]'>
    readonly pickuptime: FieldRef<"Tour", 'DateTime'>
    readonly maxPeople: FieldRef<"Tour", 'Int'>
    readonly minPeople: FieldRef<"Tour", 'Int'>
    readonly minAge: FieldRef<"Tour", 'Int'>
    readonly bestSeller: FieldRef<"Tour", 'Boolean'>
    readonly priceInfo: FieldRef<"Tour", 'String'>
    readonly location: FieldRef<"Tour", 'String'>
    readonly offered: FieldRef<"Tour", 'String[]'>
    readonly duration: FieldRef<"Tour", 'Int'>
    readonly videos: FieldRef<"Tour", 'String[]'>
    readonly images: FieldRef<"Tour", 'String[]'>
    readonly createdAt: FieldRef<"Tour", 'DateTime'>
    readonly updatedAt: FieldRef<"Tour", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tour findUnique
   */
  export type TourFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tour
     */
    omit?: TourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tour to fetch.
     */
    where: TourWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tour findUniqueOrThrow
   */
  export type TourFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tour
     */
    omit?: TourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tour to fetch.
     */
    where: TourWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tour findFirst
   */
  export type TourFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tour
     */
    omit?: TourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tour to fetch.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tours.
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tours.
     */
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tour findFirstOrThrow
   */
  export type TourFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tour
     */
    omit?: TourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tour to fetch.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tours.
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tours.
     */
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tour findMany
   */
  export type TourFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tour
     */
    omit?: TourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tours to fetch.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tours.
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tour create
   */
  export type TourCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tour
     */
    omit?: TourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * The data needed to create a Tour.
     */
    data: XOR<TourCreateInput, TourUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tour createMany
   */
  export type TourCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tours.
     */
    data: TourCreateManyInput | TourCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tour createManyAndReturn
   */
  export type TourCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tour
     */
    omit?: TourOmit<ExtArgs> | null
    /**
     * The data used to create many Tours.
     */
    data: TourCreateManyInput | TourCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tour update
   */
  export type TourUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tour
     */
    omit?: TourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * The data needed to update a Tour.
     */
    data: XOR<TourUpdateInput, TourUncheckedUpdateInput>
    /**
     * Choose, which Tour to update.
     */
    where: TourWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tour updateMany
   */
  export type TourUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tours.
     */
    data: XOR<TourUpdateManyMutationInput, TourUncheckedUpdateManyInput>
    /**
     * Filter which Tours to update
     */
    where?: TourWhereInput
    /**
     * Limit how many Tours to update.
     */
    limit?: number
  }

  /**
   * Tour updateManyAndReturn
   */
  export type TourUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tour
     */
    omit?: TourOmit<ExtArgs> | null
    /**
     * The data used to update Tours.
     */
    data: XOR<TourUpdateManyMutationInput, TourUncheckedUpdateManyInput>
    /**
     * Filter which Tours to update
     */
    where?: TourWhereInput
    /**
     * Limit how many Tours to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tour upsert
   */
  export type TourUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tour
     */
    omit?: TourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * The filter to search for the Tour to update in case it exists.
     */
    where: TourWhereUniqueInput
    /**
     * In case the Tour found by the `where` argument doesn't exist, create a new Tour with this data.
     */
    create: XOR<TourCreateInput, TourUncheckedCreateInput>
    /**
     * In case the Tour was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TourUpdateInput, TourUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tour delete
   */
  export type TourDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tour
     */
    omit?: TourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter which Tour to delete.
     */
    where: TourWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tour deleteMany
   */
  export type TourDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tours to delete
     */
    where?: TourWhereInput
    /**
     * Limit how many Tours to delete.
     */
    limit?: number
  }

  /**
   * Tour.pricecategory
   */
  export type Tour$pricecategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourPriceCategory
     */
    select?: TourPriceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TourPriceCategory
     */
    omit?: TourPriceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourPriceCategoryInclude<ExtArgs> | null
    where?: TourPriceCategoryWhereInput
    orderBy?: TourPriceCategoryOrderByWithRelationInput | TourPriceCategoryOrderByWithRelationInput[]
    cursor?: TourPriceCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TourPriceCategoryScalarFieldEnum | TourPriceCategoryScalarFieldEnum[]
  }

  /**
   * Tour without action
   */
  export type TourDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tour
     */
    omit?: TourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityAvgAggregateOutputType = {
    price: number | null
  }

  export type ActivitySumAggregateOutputType = {
    price: number | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    name: string | null
    name_esp: string | null
    description: string | null
    description_esp: string | null
    image: string | null
    profileImage: string | null
    hotelId: string | null
    type: string | null
    start: Date | null
    end: Date | null
    price: number | null
    cashOnly: boolean | null
    freeOfCharge: boolean | null
    location: string | null
    isRecurring: boolean | null
    recurrencePattern: $Enums.RECURRINGPATTERN | null
    recurrenceEndDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    name_esp: string | null
    description: string | null
    description_esp: string | null
    image: string | null
    profileImage: string | null
    hotelId: string | null
    type: string | null
    start: Date | null
    end: Date | null
    price: number | null
    cashOnly: boolean | null
    freeOfCharge: boolean | null
    location: string | null
    isRecurring: boolean | null
    recurrencePattern: $Enums.RECURRINGPATTERN | null
    recurrenceEndDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    name: number
    name_esp: number
    description: number
    description_esp: number
    image: number
    profileImage: number
    hotelId: number
    type: number
    start: number
    end: number
    price: number
    cashOnly: number
    freeOfCharge: number
    location: number
    isRecurring: number
    recurrencePattern: number
    recurrenceDays: number
    recurrenceEndDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActivityAvgAggregateInputType = {
    price?: true
  }

  export type ActivitySumAggregateInputType = {
    price?: true
  }

  export type ActivityMinAggregateInputType = {
    id?: true
    name?: true
    name_esp?: true
    description?: true
    description_esp?: true
    image?: true
    profileImage?: true
    hotelId?: true
    type?: true
    start?: true
    end?: true
    price?: true
    cashOnly?: true
    freeOfCharge?: true
    location?: true
    isRecurring?: true
    recurrencePattern?: true
    recurrenceEndDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    name?: true
    name_esp?: true
    description?: true
    description_esp?: true
    image?: true
    profileImage?: true
    hotelId?: true
    type?: true
    start?: true
    end?: true
    price?: true
    cashOnly?: true
    freeOfCharge?: true
    location?: true
    isRecurring?: true
    recurrencePattern?: true
    recurrenceEndDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    name?: true
    name_esp?: true
    description?: true
    description_esp?: true
    image?: true
    profileImage?: true
    hotelId?: true
    type?: true
    start?: true
    end?: true
    price?: true
    cashOnly?: true
    freeOfCharge?: true
    location?: true
    isRecurring?: true
    recurrencePattern?: true
    recurrenceDays?: true
    recurrenceEndDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _avg?: ActivityAvgAggregateInputType
    _sum?: ActivitySumAggregateInputType
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    name: string
    name_esp: string
    description: string
    description_esp: string
    image: string
    profileImage: string | null
    hotelId: string
    type: string
    start: Date
    end: Date
    price: number
    cashOnly: boolean
    freeOfCharge: boolean
    location: string
    isRecurring: boolean
    recurrencePattern: $Enums.RECURRINGPATTERN
    recurrenceDays: string[]
    recurrenceEndDate: Date
    createdAt: Date
    updatedAt: Date
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    profileImage?: boolean
    hotelId?: boolean
    type?: boolean
    start?: boolean
    end?: boolean
    price?: boolean
    cashOnly?: boolean
    freeOfCharge?: boolean
    location?: boolean
    isRecurring?: boolean
    recurrencePattern?: boolean
    recurrenceDays?: boolean
    recurrenceEndDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Hotel?: boolean | Activity$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    profileImage?: boolean
    hotelId?: boolean
    type?: boolean
    start?: boolean
    end?: boolean
    price?: boolean
    cashOnly?: boolean
    freeOfCharge?: boolean
    location?: boolean
    isRecurring?: boolean
    recurrencePattern?: boolean
    recurrenceDays?: boolean
    recurrenceEndDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Hotel?: boolean | Activity$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    profileImage?: boolean
    hotelId?: boolean
    type?: boolean
    start?: boolean
    end?: boolean
    price?: boolean
    cashOnly?: boolean
    freeOfCharge?: boolean
    location?: boolean
    isRecurring?: boolean
    recurrencePattern?: boolean
    recurrenceDays?: boolean
    recurrenceEndDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Hotel?: boolean | Activity$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    profileImage?: boolean
    hotelId?: boolean
    type?: boolean
    start?: boolean
    end?: boolean
    price?: boolean
    cashOnly?: boolean
    freeOfCharge?: boolean
    location?: boolean
    isRecurring?: boolean
    recurrencePattern?: boolean
    recurrenceDays?: boolean
    recurrenceEndDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "name_esp" | "description" | "description_esp" | "image" | "profileImage" | "hotelId" | "type" | "start" | "end" | "price" | "cashOnly" | "freeOfCharge" | "location" | "isRecurring" | "recurrencePattern" | "recurrenceDays" | "recurrenceEndDate" | "createdAt" | "updatedAt", ExtArgs["result"]["activity"]>
  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | Activity$HotelArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | Activity$HotelArgs<ExtArgs>
  }
  export type ActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | Activity$HotelArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      Hotel: Prisma.$HotelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      name_esp: string
      description: string
      description_esp: string
      image: string
      profileImage: string | null
      hotelId: string
      type: string
      start: Date
      end: Date
      price: number
      cashOnly: boolean
      freeOfCharge: boolean
      location: string
      isRecurring: boolean
      recurrencePattern: $Enums.RECURRINGPATTERN
      recurrenceDays: string[]
      recurrenceEndDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {ActivityUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Hotel<T extends Activity$HotelArgs<ExtArgs> = {}>(args?: Subset<T, Activity$HotelArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly name: FieldRef<"Activity", 'String'>
    readonly name_esp: FieldRef<"Activity", 'String'>
    readonly description: FieldRef<"Activity", 'String'>
    readonly description_esp: FieldRef<"Activity", 'String'>
    readonly image: FieldRef<"Activity", 'String'>
    readonly profileImage: FieldRef<"Activity", 'String'>
    readonly hotelId: FieldRef<"Activity", 'String'>
    readonly type: FieldRef<"Activity", 'String'>
    readonly start: FieldRef<"Activity", 'DateTime'>
    readonly end: FieldRef<"Activity", 'DateTime'>
    readonly price: FieldRef<"Activity", 'Int'>
    readonly cashOnly: FieldRef<"Activity", 'Boolean'>
    readonly freeOfCharge: FieldRef<"Activity", 'Boolean'>
    readonly location: FieldRef<"Activity", 'String'>
    readonly isRecurring: FieldRef<"Activity", 'Boolean'>
    readonly recurrencePattern: FieldRef<"Activity", 'RECURRINGPATTERN'>
    readonly recurrenceDays: FieldRef<"Activity", 'String[]'>
    readonly recurrenceEndDate: FieldRef<"Activity", 'DateTime'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
    readonly updatedAt: FieldRef<"Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity updateManyAndReturn
   */
  export type ActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to delete.
     */
    limit?: number
  }

  /**
   * Activity.Hotel
   */
  export type Activity$HotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    where?: HotelWhereInput
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model SpaPriceCategory
   */

  export type AggregateSpaPriceCategory = {
    _count: SpaPriceCategoryCountAggregateOutputType | null
    _avg: SpaPriceCategoryAvgAggregateOutputType | null
    _sum: SpaPriceCategorySumAggregateOutputType | null
    _min: SpaPriceCategoryMinAggregateOutputType | null
    _max: SpaPriceCategoryMaxAggregateOutputType | null
  }

  export type SpaPriceCategoryAvgAggregateOutputType = {
    sku: number | null
    price: number | null
    duration: number | null
  }

  export type SpaPriceCategorySumAggregateOutputType = {
    sku: number | null
    price: number | null
    duration: number | null
  }

  export type SpaPriceCategoryMinAggregateOutputType = {
    id: string | null
    sku: number | null
    price: number | null
    description: string | null
    description_esp: string | null
    duration: number | null
    spaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpaPriceCategoryMaxAggregateOutputType = {
    id: string | null
    sku: number | null
    price: number | null
    description: string | null
    description_esp: string | null
    duration: number | null
    spaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpaPriceCategoryCountAggregateOutputType = {
    id: number
    sku: number
    price: number
    description: number
    description_esp: number
    duration: number
    spaId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SpaPriceCategoryAvgAggregateInputType = {
    sku?: true
    price?: true
    duration?: true
  }

  export type SpaPriceCategorySumAggregateInputType = {
    sku?: true
    price?: true
    duration?: true
  }

  export type SpaPriceCategoryMinAggregateInputType = {
    id?: true
    sku?: true
    price?: true
    description?: true
    description_esp?: true
    duration?: true
    spaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpaPriceCategoryMaxAggregateInputType = {
    id?: true
    sku?: true
    price?: true
    description?: true
    description_esp?: true
    duration?: true
    spaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpaPriceCategoryCountAggregateInputType = {
    id?: true
    sku?: true
    price?: true
    description?: true
    description_esp?: true
    duration?: true
    spaId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SpaPriceCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpaPriceCategory to aggregate.
     */
    where?: SpaPriceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaPriceCategories to fetch.
     */
    orderBy?: SpaPriceCategoryOrderByWithRelationInput | SpaPriceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpaPriceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaPriceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaPriceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpaPriceCategories
    **/
    _count?: true | SpaPriceCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpaPriceCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpaPriceCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpaPriceCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpaPriceCategoryMaxAggregateInputType
  }

  export type GetSpaPriceCategoryAggregateType<T extends SpaPriceCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSpaPriceCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpaPriceCategory[P]>
      : GetScalarType<T[P], AggregateSpaPriceCategory[P]>
  }




  export type SpaPriceCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaPriceCategoryWhereInput
    orderBy?: SpaPriceCategoryOrderByWithAggregationInput | SpaPriceCategoryOrderByWithAggregationInput[]
    by: SpaPriceCategoryScalarFieldEnum[] | SpaPriceCategoryScalarFieldEnum
    having?: SpaPriceCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpaPriceCategoryCountAggregateInputType | true
    _avg?: SpaPriceCategoryAvgAggregateInputType
    _sum?: SpaPriceCategorySumAggregateInputType
    _min?: SpaPriceCategoryMinAggregateInputType
    _max?: SpaPriceCategoryMaxAggregateInputType
  }

  export type SpaPriceCategoryGroupByOutputType = {
    id: string
    sku: number
    price: number
    description: string
    description_esp: string
    duration: number
    spaId: string
    createdAt: Date
    updatedAt: Date
    _count: SpaPriceCategoryCountAggregateOutputType | null
    _avg: SpaPriceCategoryAvgAggregateOutputType | null
    _sum: SpaPriceCategorySumAggregateOutputType | null
    _min: SpaPriceCategoryMinAggregateOutputType | null
    _max: SpaPriceCategoryMaxAggregateOutputType | null
  }

  type GetSpaPriceCategoryGroupByPayload<T extends SpaPriceCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpaPriceCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpaPriceCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpaPriceCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], SpaPriceCategoryGroupByOutputType[P]>
        }
      >
    >


  export type SpaPriceCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    price?: boolean
    description?: boolean
    description_esp?: boolean
    duration?: boolean
    spaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    spa?: boolean | SpaPriceCategory$spaArgs<ExtArgs>
  }, ExtArgs["result"]["spaPriceCategory"]>

  export type SpaPriceCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    price?: boolean
    description?: boolean
    description_esp?: boolean
    duration?: boolean
    spaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    spa?: boolean | SpaPriceCategory$spaArgs<ExtArgs>
  }, ExtArgs["result"]["spaPriceCategory"]>

  export type SpaPriceCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    price?: boolean
    description?: boolean
    description_esp?: boolean
    duration?: boolean
    spaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    spa?: boolean | SpaPriceCategory$spaArgs<ExtArgs>
  }, ExtArgs["result"]["spaPriceCategory"]>

  export type SpaPriceCategorySelectScalar = {
    id?: boolean
    sku?: boolean
    price?: boolean
    description?: boolean
    description_esp?: boolean
    duration?: boolean
    spaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SpaPriceCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sku" | "price" | "description" | "description_esp" | "duration" | "spaId" | "createdAt" | "updatedAt", ExtArgs["result"]["spaPriceCategory"]>
  export type SpaPriceCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spa?: boolean | SpaPriceCategory$spaArgs<ExtArgs>
  }
  export type SpaPriceCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spa?: boolean | SpaPriceCategory$spaArgs<ExtArgs>
  }
  export type SpaPriceCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spa?: boolean | SpaPriceCategory$spaArgs<ExtArgs>
  }

  export type $SpaPriceCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpaPriceCategory"
    objects: {
      spa: Prisma.$SpaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sku: number
      price: number
      description: string
      description_esp: string
      duration: number
      spaId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["spaPriceCategory"]>
    composites: {}
  }

  type SpaPriceCategoryGetPayload<S extends boolean | null | undefined | SpaPriceCategoryDefaultArgs> = $Result.GetResult<Prisma.$SpaPriceCategoryPayload, S>

  type SpaPriceCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpaPriceCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: SpaPriceCategoryCountAggregateInputType | true
    }

  export interface SpaPriceCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpaPriceCategory'], meta: { name: 'SpaPriceCategory' } }
    /**
     * Find zero or one SpaPriceCategory that matches the filter.
     * @param {SpaPriceCategoryFindUniqueArgs} args - Arguments to find a SpaPriceCategory
     * @example
     * // Get one SpaPriceCategory
     * const spaPriceCategory = await prisma.spaPriceCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpaPriceCategoryFindUniqueArgs>(args: SelectSubset<T, SpaPriceCategoryFindUniqueArgs<ExtArgs>>): Prisma__SpaPriceCategoryClient<$Result.GetResult<Prisma.$SpaPriceCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpaPriceCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpaPriceCategoryFindUniqueOrThrowArgs} args - Arguments to find a SpaPriceCategory
     * @example
     * // Get one SpaPriceCategory
     * const spaPriceCategory = await prisma.spaPriceCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpaPriceCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SpaPriceCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpaPriceCategoryClient<$Result.GetResult<Prisma.$SpaPriceCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpaPriceCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaPriceCategoryFindFirstArgs} args - Arguments to find a SpaPriceCategory
     * @example
     * // Get one SpaPriceCategory
     * const spaPriceCategory = await prisma.spaPriceCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpaPriceCategoryFindFirstArgs>(args?: SelectSubset<T, SpaPriceCategoryFindFirstArgs<ExtArgs>>): Prisma__SpaPriceCategoryClient<$Result.GetResult<Prisma.$SpaPriceCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpaPriceCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaPriceCategoryFindFirstOrThrowArgs} args - Arguments to find a SpaPriceCategory
     * @example
     * // Get one SpaPriceCategory
     * const spaPriceCategory = await prisma.spaPriceCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpaPriceCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SpaPriceCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpaPriceCategoryClient<$Result.GetResult<Prisma.$SpaPriceCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpaPriceCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaPriceCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpaPriceCategories
     * const spaPriceCategories = await prisma.spaPriceCategory.findMany()
     * 
     * // Get first 10 SpaPriceCategories
     * const spaPriceCategories = await prisma.spaPriceCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spaPriceCategoryWithIdOnly = await prisma.spaPriceCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpaPriceCategoryFindManyArgs>(args?: SelectSubset<T, SpaPriceCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaPriceCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpaPriceCategory.
     * @param {SpaPriceCategoryCreateArgs} args - Arguments to create a SpaPriceCategory.
     * @example
     * // Create one SpaPriceCategory
     * const SpaPriceCategory = await prisma.spaPriceCategory.create({
     *   data: {
     *     // ... data to create a SpaPriceCategory
     *   }
     * })
     * 
     */
    create<T extends SpaPriceCategoryCreateArgs>(args: SelectSubset<T, SpaPriceCategoryCreateArgs<ExtArgs>>): Prisma__SpaPriceCategoryClient<$Result.GetResult<Prisma.$SpaPriceCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpaPriceCategories.
     * @param {SpaPriceCategoryCreateManyArgs} args - Arguments to create many SpaPriceCategories.
     * @example
     * // Create many SpaPriceCategories
     * const spaPriceCategory = await prisma.spaPriceCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpaPriceCategoryCreateManyArgs>(args?: SelectSubset<T, SpaPriceCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpaPriceCategories and returns the data saved in the database.
     * @param {SpaPriceCategoryCreateManyAndReturnArgs} args - Arguments to create many SpaPriceCategories.
     * @example
     * // Create many SpaPriceCategories
     * const spaPriceCategory = await prisma.spaPriceCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpaPriceCategories and only return the `id`
     * const spaPriceCategoryWithIdOnly = await prisma.spaPriceCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpaPriceCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SpaPriceCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaPriceCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SpaPriceCategory.
     * @param {SpaPriceCategoryDeleteArgs} args - Arguments to delete one SpaPriceCategory.
     * @example
     * // Delete one SpaPriceCategory
     * const SpaPriceCategory = await prisma.spaPriceCategory.delete({
     *   where: {
     *     // ... filter to delete one SpaPriceCategory
     *   }
     * })
     * 
     */
    delete<T extends SpaPriceCategoryDeleteArgs>(args: SelectSubset<T, SpaPriceCategoryDeleteArgs<ExtArgs>>): Prisma__SpaPriceCategoryClient<$Result.GetResult<Prisma.$SpaPriceCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpaPriceCategory.
     * @param {SpaPriceCategoryUpdateArgs} args - Arguments to update one SpaPriceCategory.
     * @example
     * // Update one SpaPriceCategory
     * const spaPriceCategory = await prisma.spaPriceCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpaPriceCategoryUpdateArgs>(args: SelectSubset<T, SpaPriceCategoryUpdateArgs<ExtArgs>>): Prisma__SpaPriceCategoryClient<$Result.GetResult<Prisma.$SpaPriceCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpaPriceCategories.
     * @param {SpaPriceCategoryDeleteManyArgs} args - Arguments to filter SpaPriceCategories to delete.
     * @example
     * // Delete a few SpaPriceCategories
     * const { count } = await prisma.spaPriceCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpaPriceCategoryDeleteManyArgs>(args?: SelectSubset<T, SpaPriceCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpaPriceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaPriceCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpaPriceCategories
     * const spaPriceCategory = await prisma.spaPriceCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpaPriceCategoryUpdateManyArgs>(args: SelectSubset<T, SpaPriceCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpaPriceCategories and returns the data updated in the database.
     * @param {SpaPriceCategoryUpdateManyAndReturnArgs} args - Arguments to update many SpaPriceCategories.
     * @example
     * // Update many SpaPriceCategories
     * const spaPriceCategory = await prisma.spaPriceCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SpaPriceCategories and only return the `id`
     * const spaPriceCategoryWithIdOnly = await prisma.spaPriceCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpaPriceCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, SpaPriceCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaPriceCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SpaPriceCategory.
     * @param {SpaPriceCategoryUpsertArgs} args - Arguments to update or create a SpaPriceCategory.
     * @example
     * // Update or create a SpaPriceCategory
     * const spaPriceCategory = await prisma.spaPriceCategory.upsert({
     *   create: {
     *     // ... data to create a SpaPriceCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpaPriceCategory we want to update
     *   }
     * })
     */
    upsert<T extends SpaPriceCategoryUpsertArgs>(args: SelectSubset<T, SpaPriceCategoryUpsertArgs<ExtArgs>>): Prisma__SpaPriceCategoryClient<$Result.GetResult<Prisma.$SpaPriceCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpaPriceCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaPriceCategoryCountArgs} args - Arguments to filter SpaPriceCategories to count.
     * @example
     * // Count the number of SpaPriceCategories
     * const count = await prisma.spaPriceCategory.count({
     *   where: {
     *     // ... the filter for the SpaPriceCategories we want to count
     *   }
     * })
    **/
    count<T extends SpaPriceCategoryCountArgs>(
      args?: Subset<T, SpaPriceCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpaPriceCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpaPriceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaPriceCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpaPriceCategoryAggregateArgs>(args: Subset<T, SpaPriceCategoryAggregateArgs>): Prisma.PrismaPromise<GetSpaPriceCategoryAggregateType<T>>

    /**
     * Group by SpaPriceCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaPriceCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpaPriceCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpaPriceCategoryGroupByArgs['orderBy'] }
        : { orderBy?: SpaPriceCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpaPriceCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpaPriceCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpaPriceCategory model
   */
  readonly fields: SpaPriceCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpaPriceCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpaPriceCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    spa<T extends SpaPriceCategory$spaArgs<ExtArgs> = {}>(args?: Subset<T, SpaPriceCategory$spaArgs<ExtArgs>>): Prisma__SpaClient<$Result.GetResult<Prisma.$SpaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpaPriceCategory model
   */
  interface SpaPriceCategoryFieldRefs {
    readonly id: FieldRef<"SpaPriceCategory", 'String'>
    readonly sku: FieldRef<"SpaPriceCategory", 'Int'>
    readonly price: FieldRef<"SpaPriceCategory", 'Int'>
    readonly description: FieldRef<"SpaPriceCategory", 'String'>
    readonly description_esp: FieldRef<"SpaPriceCategory", 'String'>
    readonly duration: FieldRef<"SpaPriceCategory", 'Int'>
    readonly spaId: FieldRef<"SpaPriceCategory", 'String'>
    readonly createdAt: FieldRef<"SpaPriceCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"SpaPriceCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SpaPriceCategory findUnique
   */
  export type SpaPriceCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaPriceCategory
     */
    select?: SpaPriceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaPriceCategory
     */
    omit?: SpaPriceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaPriceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SpaPriceCategory to fetch.
     */
    where: SpaPriceCategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SpaPriceCategory findUniqueOrThrow
   */
  export type SpaPriceCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaPriceCategory
     */
    select?: SpaPriceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaPriceCategory
     */
    omit?: SpaPriceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaPriceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SpaPriceCategory to fetch.
     */
    where: SpaPriceCategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SpaPriceCategory findFirst
   */
  export type SpaPriceCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaPriceCategory
     */
    select?: SpaPriceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaPriceCategory
     */
    omit?: SpaPriceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaPriceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SpaPriceCategory to fetch.
     */
    where?: SpaPriceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaPriceCategories to fetch.
     */
    orderBy?: SpaPriceCategoryOrderByWithRelationInput | SpaPriceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpaPriceCategories.
     */
    cursor?: SpaPriceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaPriceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaPriceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpaPriceCategories.
     */
    distinct?: SpaPriceCategoryScalarFieldEnum | SpaPriceCategoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SpaPriceCategory findFirstOrThrow
   */
  export type SpaPriceCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaPriceCategory
     */
    select?: SpaPriceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaPriceCategory
     */
    omit?: SpaPriceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaPriceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SpaPriceCategory to fetch.
     */
    where?: SpaPriceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaPriceCategories to fetch.
     */
    orderBy?: SpaPriceCategoryOrderByWithRelationInput | SpaPriceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpaPriceCategories.
     */
    cursor?: SpaPriceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaPriceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaPriceCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpaPriceCategories.
     */
    distinct?: SpaPriceCategoryScalarFieldEnum | SpaPriceCategoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SpaPriceCategory findMany
   */
  export type SpaPriceCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaPriceCategory
     */
    select?: SpaPriceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaPriceCategory
     */
    omit?: SpaPriceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaPriceCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SpaPriceCategories to fetch.
     */
    where?: SpaPriceCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaPriceCategories to fetch.
     */
    orderBy?: SpaPriceCategoryOrderByWithRelationInput | SpaPriceCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpaPriceCategories.
     */
    cursor?: SpaPriceCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaPriceCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaPriceCategories.
     */
    skip?: number
    distinct?: SpaPriceCategoryScalarFieldEnum | SpaPriceCategoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SpaPriceCategory create
   */
  export type SpaPriceCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaPriceCategory
     */
    select?: SpaPriceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaPriceCategory
     */
    omit?: SpaPriceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaPriceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SpaPriceCategory.
     */
    data: XOR<SpaPriceCategoryCreateInput, SpaPriceCategoryUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SpaPriceCategory createMany
   */
  export type SpaPriceCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpaPriceCategories.
     */
    data: SpaPriceCategoryCreateManyInput | SpaPriceCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpaPriceCategory createManyAndReturn
   */
  export type SpaPriceCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaPriceCategory
     */
    select?: SpaPriceCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpaPriceCategory
     */
    omit?: SpaPriceCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many SpaPriceCategories.
     */
    data: SpaPriceCategoryCreateManyInput | SpaPriceCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaPriceCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpaPriceCategory update
   */
  export type SpaPriceCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaPriceCategory
     */
    select?: SpaPriceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaPriceCategory
     */
    omit?: SpaPriceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaPriceCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SpaPriceCategory.
     */
    data: XOR<SpaPriceCategoryUpdateInput, SpaPriceCategoryUncheckedUpdateInput>
    /**
     * Choose, which SpaPriceCategory to update.
     */
    where: SpaPriceCategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SpaPriceCategory updateMany
   */
  export type SpaPriceCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpaPriceCategories.
     */
    data: XOR<SpaPriceCategoryUpdateManyMutationInput, SpaPriceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which SpaPriceCategories to update
     */
    where?: SpaPriceCategoryWhereInput
    /**
     * Limit how many SpaPriceCategories to update.
     */
    limit?: number
  }

  /**
   * SpaPriceCategory updateManyAndReturn
   */
  export type SpaPriceCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaPriceCategory
     */
    select?: SpaPriceCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpaPriceCategory
     */
    omit?: SpaPriceCategoryOmit<ExtArgs> | null
    /**
     * The data used to update SpaPriceCategories.
     */
    data: XOR<SpaPriceCategoryUpdateManyMutationInput, SpaPriceCategoryUncheckedUpdateManyInput>
    /**
     * Filter which SpaPriceCategories to update
     */
    where?: SpaPriceCategoryWhereInput
    /**
     * Limit how many SpaPriceCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaPriceCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpaPriceCategory upsert
   */
  export type SpaPriceCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaPriceCategory
     */
    select?: SpaPriceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaPriceCategory
     */
    omit?: SpaPriceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaPriceCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SpaPriceCategory to update in case it exists.
     */
    where: SpaPriceCategoryWhereUniqueInput
    /**
     * In case the SpaPriceCategory found by the `where` argument doesn't exist, create a new SpaPriceCategory with this data.
     */
    create: XOR<SpaPriceCategoryCreateInput, SpaPriceCategoryUncheckedCreateInput>
    /**
     * In case the SpaPriceCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpaPriceCategoryUpdateInput, SpaPriceCategoryUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SpaPriceCategory delete
   */
  export type SpaPriceCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaPriceCategory
     */
    select?: SpaPriceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaPriceCategory
     */
    omit?: SpaPriceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaPriceCategoryInclude<ExtArgs> | null
    /**
     * Filter which SpaPriceCategory to delete.
     */
    where: SpaPriceCategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SpaPriceCategory deleteMany
   */
  export type SpaPriceCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpaPriceCategories to delete
     */
    where?: SpaPriceCategoryWhereInput
    /**
     * Limit how many SpaPriceCategories to delete.
     */
    limit?: number
  }

  /**
   * SpaPriceCategory.spa
   */
  export type SpaPriceCategory$spaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spa
     */
    select?: SpaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spa
     */
    omit?: SpaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaInclude<ExtArgs> | null
    where?: SpaWhereInput
  }

  /**
   * SpaPriceCategory without action
   */
  export type SpaPriceCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaPriceCategory
     */
    select?: SpaPriceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaPriceCategory
     */
    omit?: SpaPriceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaPriceCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Spa
   */

  export type AggregateSpa = {
    _count: SpaCountAggregateOutputType | null
    _min: SpaMinAggregateOutputType | null
    _max: SpaMaxAggregateOutputType | null
  }

  export type SpaMinAggregateOutputType = {
    id: string | null
    name: string | null
    name_esp: string | null
    description: string | null
    description_esp: string | null
    hotelId: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpaMaxAggregateOutputType = {
    id: string | null
    name: string | null
    name_esp: string | null
    description: string | null
    description_esp: string | null
    hotelId: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpaCountAggregateOutputType = {
    id: number
    name: number
    name_esp: number
    description: number
    description_esp: number
    hotelId: number
    type: number
    videos: number
    images: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SpaMinAggregateInputType = {
    id?: true
    name?: true
    name_esp?: true
    description?: true
    description_esp?: true
    hotelId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpaMaxAggregateInputType = {
    id?: true
    name?: true
    name_esp?: true
    description?: true
    description_esp?: true
    hotelId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpaCountAggregateInputType = {
    id?: true
    name?: true
    name_esp?: true
    description?: true
    description_esp?: true
    hotelId?: true
    type?: true
    videos?: true
    images?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SpaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Spa to aggregate.
     */
    where?: SpaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spas to fetch.
     */
    orderBy?: SpaOrderByWithRelationInput | SpaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Spas
    **/
    _count?: true | SpaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpaMaxAggregateInputType
  }

  export type GetSpaAggregateType<T extends SpaAggregateArgs> = {
        [P in keyof T & keyof AggregateSpa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpa[P]>
      : GetScalarType<T[P], AggregateSpa[P]>
  }




  export type SpaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaWhereInput
    orderBy?: SpaOrderByWithAggregationInput | SpaOrderByWithAggregationInput[]
    by: SpaScalarFieldEnum[] | SpaScalarFieldEnum
    having?: SpaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpaCountAggregateInputType | true
    _min?: SpaMinAggregateInputType
    _max?: SpaMaxAggregateInputType
  }

  export type SpaGroupByOutputType = {
    id: string
    name: string
    name_esp: string
    description: string
    description_esp: string
    hotelId: string
    type: string
    videos: string[]
    images: string[]
    createdAt: Date
    updatedAt: Date
    _count: SpaCountAggregateOutputType | null
    _min: SpaMinAggregateOutputType | null
    _max: SpaMaxAggregateOutputType | null
  }

  type GetSpaGroupByPayload<T extends SpaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpaGroupByOutputType[P]>
            : GetScalarType<T[P], SpaGroupByOutputType[P]>
        }
      >
    >


  export type SpaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    hotelId?: boolean
    type?: boolean
    videos?: boolean
    images?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pricecategory?: boolean | Spa$pricecategoryArgs<ExtArgs>
    Hotel?: boolean | Spa$HotelArgs<ExtArgs>
    _count?: boolean | SpaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spa"]>

  export type SpaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    hotelId?: boolean
    type?: boolean
    videos?: boolean
    images?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Hotel?: boolean | Spa$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["spa"]>

  export type SpaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    hotelId?: boolean
    type?: boolean
    videos?: boolean
    images?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Hotel?: boolean | Spa$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["spa"]>

  export type SpaSelectScalar = {
    id?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    hotelId?: boolean
    type?: boolean
    videos?: boolean
    images?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SpaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "name_esp" | "description" | "description_esp" | "hotelId" | "type" | "videos" | "images" | "createdAt" | "updatedAt", ExtArgs["result"]["spa"]>
  export type SpaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pricecategory?: boolean | Spa$pricecategoryArgs<ExtArgs>
    Hotel?: boolean | Spa$HotelArgs<ExtArgs>
    _count?: boolean | SpaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | Spa$HotelArgs<ExtArgs>
  }
  export type SpaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | Spa$HotelArgs<ExtArgs>
  }

  export type $SpaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Spa"
    objects: {
      pricecategory: Prisma.$SpaPriceCategoryPayload<ExtArgs>[]
      Hotel: Prisma.$HotelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      name_esp: string
      description: string
      description_esp: string
      hotelId: string
      type: string
      videos: string[]
      images: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["spa"]>
    composites: {}
  }

  type SpaGetPayload<S extends boolean | null | undefined | SpaDefaultArgs> = $Result.GetResult<Prisma.$SpaPayload, S>

  type SpaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: SpaCountAggregateInputType | true
    }

  export interface SpaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Spa'], meta: { name: 'Spa' } }
    /**
     * Find zero or one Spa that matches the filter.
     * @param {SpaFindUniqueArgs} args - Arguments to find a Spa
     * @example
     * // Get one Spa
     * const spa = await prisma.spa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpaFindUniqueArgs>(args: SelectSubset<T, SpaFindUniqueArgs<ExtArgs>>): Prisma__SpaClient<$Result.GetResult<Prisma.$SpaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Spa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpaFindUniqueOrThrowArgs} args - Arguments to find a Spa
     * @example
     * // Get one Spa
     * const spa = await prisma.spa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpaFindUniqueOrThrowArgs>(args: SelectSubset<T, SpaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpaClient<$Result.GetResult<Prisma.$SpaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Spa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaFindFirstArgs} args - Arguments to find a Spa
     * @example
     * // Get one Spa
     * const spa = await prisma.spa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpaFindFirstArgs>(args?: SelectSubset<T, SpaFindFirstArgs<ExtArgs>>): Prisma__SpaClient<$Result.GetResult<Prisma.$SpaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Spa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaFindFirstOrThrowArgs} args - Arguments to find a Spa
     * @example
     * // Get one Spa
     * const spa = await prisma.spa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpaFindFirstOrThrowArgs>(args?: SelectSubset<T, SpaFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpaClient<$Result.GetResult<Prisma.$SpaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Spas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Spas
     * const spas = await prisma.spa.findMany()
     * 
     * // Get first 10 Spas
     * const spas = await prisma.spa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spaWithIdOnly = await prisma.spa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpaFindManyArgs>(args?: SelectSubset<T, SpaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Spa.
     * @param {SpaCreateArgs} args - Arguments to create a Spa.
     * @example
     * // Create one Spa
     * const Spa = await prisma.spa.create({
     *   data: {
     *     // ... data to create a Spa
     *   }
     * })
     * 
     */
    create<T extends SpaCreateArgs>(args: SelectSubset<T, SpaCreateArgs<ExtArgs>>): Prisma__SpaClient<$Result.GetResult<Prisma.$SpaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Spas.
     * @param {SpaCreateManyArgs} args - Arguments to create many Spas.
     * @example
     * // Create many Spas
     * const spa = await prisma.spa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpaCreateManyArgs>(args?: SelectSubset<T, SpaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Spas and returns the data saved in the database.
     * @param {SpaCreateManyAndReturnArgs} args - Arguments to create many Spas.
     * @example
     * // Create many Spas
     * const spa = await prisma.spa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Spas and only return the `id`
     * const spaWithIdOnly = await prisma.spa.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpaCreateManyAndReturnArgs>(args?: SelectSubset<T, SpaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Spa.
     * @param {SpaDeleteArgs} args - Arguments to delete one Spa.
     * @example
     * // Delete one Spa
     * const Spa = await prisma.spa.delete({
     *   where: {
     *     // ... filter to delete one Spa
     *   }
     * })
     * 
     */
    delete<T extends SpaDeleteArgs>(args: SelectSubset<T, SpaDeleteArgs<ExtArgs>>): Prisma__SpaClient<$Result.GetResult<Prisma.$SpaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Spa.
     * @param {SpaUpdateArgs} args - Arguments to update one Spa.
     * @example
     * // Update one Spa
     * const spa = await prisma.spa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpaUpdateArgs>(args: SelectSubset<T, SpaUpdateArgs<ExtArgs>>): Prisma__SpaClient<$Result.GetResult<Prisma.$SpaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Spas.
     * @param {SpaDeleteManyArgs} args - Arguments to filter Spas to delete.
     * @example
     * // Delete a few Spas
     * const { count } = await prisma.spa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpaDeleteManyArgs>(args?: SelectSubset<T, SpaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Spas
     * const spa = await prisma.spa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpaUpdateManyArgs>(args: SelectSubset<T, SpaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spas and returns the data updated in the database.
     * @param {SpaUpdateManyAndReturnArgs} args - Arguments to update many Spas.
     * @example
     * // Update many Spas
     * const spa = await prisma.spa.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Spas and only return the `id`
     * const spaWithIdOnly = await prisma.spa.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpaUpdateManyAndReturnArgs>(args: SelectSubset<T, SpaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Spa.
     * @param {SpaUpsertArgs} args - Arguments to update or create a Spa.
     * @example
     * // Update or create a Spa
     * const spa = await prisma.spa.upsert({
     *   create: {
     *     // ... data to create a Spa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Spa we want to update
     *   }
     * })
     */
    upsert<T extends SpaUpsertArgs>(args: SelectSubset<T, SpaUpsertArgs<ExtArgs>>): Prisma__SpaClient<$Result.GetResult<Prisma.$SpaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Spas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaCountArgs} args - Arguments to filter Spas to count.
     * @example
     * // Count the number of Spas
     * const count = await prisma.spa.count({
     *   where: {
     *     // ... the filter for the Spas we want to count
     *   }
     * })
    **/
    count<T extends SpaCountArgs>(
      args?: Subset<T, SpaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpaAggregateArgs>(args: Subset<T, SpaAggregateArgs>): Prisma.PrismaPromise<GetSpaAggregateType<T>>

    /**
     * Group by Spa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpaGroupByArgs['orderBy'] }
        : { orderBy?: SpaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Spa model
   */
  readonly fields: SpaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Spa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pricecategory<T extends Spa$pricecategoryArgs<ExtArgs> = {}>(args?: Subset<T, Spa$pricecategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaPriceCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Hotel<T extends Spa$HotelArgs<ExtArgs> = {}>(args?: Subset<T, Spa$HotelArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Spa model
   */
  interface SpaFieldRefs {
    readonly id: FieldRef<"Spa", 'String'>
    readonly name: FieldRef<"Spa", 'String'>
    readonly name_esp: FieldRef<"Spa", 'String'>
    readonly description: FieldRef<"Spa", 'String'>
    readonly description_esp: FieldRef<"Spa", 'String'>
    readonly hotelId: FieldRef<"Spa", 'String'>
    readonly type: FieldRef<"Spa", 'String'>
    readonly videos: FieldRef<"Spa", 'String[]'>
    readonly images: FieldRef<"Spa", 'String[]'>
    readonly createdAt: FieldRef<"Spa", 'DateTime'>
    readonly updatedAt: FieldRef<"Spa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Spa findUnique
   */
  export type SpaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spa
     */
    select?: SpaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spa
     */
    omit?: SpaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaInclude<ExtArgs> | null
    /**
     * Filter, which Spa to fetch.
     */
    where: SpaWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Spa findUniqueOrThrow
   */
  export type SpaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spa
     */
    select?: SpaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spa
     */
    omit?: SpaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaInclude<ExtArgs> | null
    /**
     * Filter, which Spa to fetch.
     */
    where: SpaWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Spa findFirst
   */
  export type SpaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spa
     */
    select?: SpaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spa
     */
    omit?: SpaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaInclude<ExtArgs> | null
    /**
     * Filter, which Spa to fetch.
     */
    where?: SpaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spas to fetch.
     */
    orderBy?: SpaOrderByWithRelationInput | SpaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spas.
     */
    cursor?: SpaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spas.
     */
    distinct?: SpaScalarFieldEnum | SpaScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Spa findFirstOrThrow
   */
  export type SpaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spa
     */
    select?: SpaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spa
     */
    omit?: SpaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaInclude<ExtArgs> | null
    /**
     * Filter, which Spa to fetch.
     */
    where?: SpaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spas to fetch.
     */
    orderBy?: SpaOrderByWithRelationInput | SpaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spas.
     */
    cursor?: SpaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spas.
     */
    distinct?: SpaScalarFieldEnum | SpaScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Spa findMany
   */
  export type SpaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spa
     */
    select?: SpaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spa
     */
    omit?: SpaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaInclude<ExtArgs> | null
    /**
     * Filter, which Spas to fetch.
     */
    where?: SpaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spas to fetch.
     */
    orderBy?: SpaOrderByWithRelationInput | SpaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Spas.
     */
    cursor?: SpaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spas.
     */
    skip?: number
    distinct?: SpaScalarFieldEnum | SpaScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Spa create
   */
  export type SpaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spa
     */
    select?: SpaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spa
     */
    omit?: SpaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaInclude<ExtArgs> | null
    /**
     * The data needed to create a Spa.
     */
    data: XOR<SpaCreateInput, SpaUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Spa createMany
   */
  export type SpaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Spas.
     */
    data: SpaCreateManyInput | SpaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Spa createManyAndReturn
   */
  export type SpaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spa
     */
    select?: SpaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Spa
     */
    omit?: SpaOmit<ExtArgs> | null
    /**
     * The data used to create many Spas.
     */
    data: SpaCreateManyInput | SpaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Spa update
   */
  export type SpaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spa
     */
    select?: SpaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spa
     */
    omit?: SpaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaInclude<ExtArgs> | null
    /**
     * The data needed to update a Spa.
     */
    data: XOR<SpaUpdateInput, SpaUncheckedUpdateInput>
    /**
     * Choose, which Spa to update.
     */
    where: SpaWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Spa updateMany
   */
  export type SpaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Spas.
     */
    data: XOR<SpaUpdateManyMutationInput, SpaUncheckedUpdateManyInput>
    /**
     * Filter which Spas to update
     */
    where?: SpaWhereInput
    /**
     * Limit how many Spas to update.
     */
    limit?: number
  }

  /**
   * Spa updateManyAndReturn
   */
  export type SpaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spa
     */
    select?: SpaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Spa
     */
    omit?: SpaOmit<ExtArgs> | null
    /**
     * The data used to update Spas.
     */
    data: XOR<SpaUpdateManyMutationInput, SpaUncheckedUpdateManyInput>
    /**
     * Filter which Spas to update
     */
    where?: SpaWhereInput
    /**
     * Limit how many Spas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Spa upsert
   */
  export type SpaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spa
     */
    select?: SpaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spa
     */
    omit?: SpaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaInclude<ExtArgs> | null
    /**
     * The filter to search for the Spa to update in case it exists.
     */
    where: SpaWhereUniqueInput
    /**
     * In case the Spa found by the `where` argument doesn't exist, create a new Spa with this data.
     */
    create: XOR<SpaCreateInput, SpaUncheckedCreateInput>
    /**
     * In case the Spa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpaUpdateInput, SpaUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Spa delete
   */
  export type SpaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spa
     */
    select?: SpaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spa
     */
    omit?: SpaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaInclude<ExtArgs> | null
    /**
     * Filter which Spa to delete.
     */
    where: SpaWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Spa deleteMany
   */
  export type SpaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Spas to delete
     */
    where?: SpaWhereInput
    /**
     * Limit how many Spas to delete.
     */
    limit?: number
  }

  /**
   * Spa.pricecategory
   */
  export type Spa$pricecategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaPriceCategory
     */
    select?: SpaPriceCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpaPriceCategory
     */
    omit?: SpaPriceCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaPriceCategoryInclude<ExtArgs> | null
    where?: SpaPriceCategoryWhereInput
    orderBy?: SpaPriceCategoryOrderByWithRelationInput | SpaPriceCategoryOrderByWithRelationInput[]
    cursor?: SpaPriceCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpaPriceCategoryScalarFieldEnum | SpaPriceCategoryScalarFieldEnum[]
  }

  /**
   * Spa.Hotel
   */
  export type Spa$HotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    where?: HotelWhereInput
  }

  /**
   * Spa without action
   */
  export type SpaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Spa
     */
    select?: SpaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Spa
     */
    omit?: SpaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaInclude<ExtArgs> | null
  }


  /**
   * Model TVChannels
   */

  export type AggregateTVChannels = {
    _count: TVChannelsCountAggregateOutputType | null
    _min: TVChannelsMinAggregateOutputType | null
    _max: TVChannelsMaxAggregateOutputType | null
  }

  export type TVChannelsMinAggregateOutputType = {
    id: string | null
    name: string | null
    name_esp: string | null
    description: string | null
    description_esp: string | null
    logo: string | null
    channelNo: string | null
    languages: $Enums.TVChannelLanguages | null
    channeltype: $Enums.TVCHANNELTYPE | null
    category: string | null
    hotelId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TVChannelsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    name_esp: string | null
    description: string | null
    description_esp: string | null
    logo: string | null
    channelNo: string | null
    languages: $Enums.TVChannelLanguages | null
    channeltype: $Enums.TVCHANNELTYPE | null
    category: string | null
    hotelId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TVChannelsCountAggregateOutputType = {
    id: number
    name: number
    name_esp: number
    description: number
    description_esp: number
    logo: number
    channelNo: number
    languages: number
    channeltype: number
    category: number
    hotelId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TVChannelsMinAggregateInputType = {
    id?: true
    name?: true
    name_esp?: true
    description?: true
    description_esp?: true
    logo?: true
    channelNo?: true
    languages?: true
    channeltype?: true
    category?: true
    hotelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TVChannelsMaxAggregateInputType = {
    id?: true
    name?: true
    name_esp?: true
    description?: true
    description_esp?: true
    logo?: true
    channelNo?: true
    languages?: true
    channeltype?: true
    category?: true
    hotelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TVChannelsCountAggregateInputType = {
    id?: true
    name?: true
    name_esp?: true
    description?: true
    description_esp?: true
    logo?: true
    channelNo?: true
    languages?: true
    channeltype?: true
    category?: true
    hotelId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TVChannelsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TVChannels to aggregate.
     */
    where?: TVChannelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TVChannels to fetch.
     */
    orderBy?: TVChannelsOrderByWithRelationInput | TVChannelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TVChannelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TVChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TVChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TVChannels
    **/
    _count?: true | TVChannelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TVChannelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TVChannelsMaxAggregateInputType
  }

  export type GetTVChannelsAggregateType<T extends TVChannelsAggregateArgs> = {
        [P in keyof T & keyof AggregateTVChannels]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTVChannels[P]>
      : GetScalarType<T[P], AggregateTVChannels[P]>
  }




  export type TVChannelsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TVChannelsWhereInput
    orderBy?: TVChannelsOrderByWithAggregationInput | TVChannelsOrderByWithAggregationInput[]
    by: TVChannelsScalarFieldEnum[] | TVChannelsScalarFieldEnum
    having?: TVChannelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TVChannelsCountAggregateInputType | true
    _min?: TVChannelsMinAggregateInputType
    _max?: TVChannelsMaxAggregateInputType
  }

  export type TVChannelsGroupByOutputType = {
    id: string
    name: string
    name_esp: string | null
    description: string
    description_esp: string | null
    logo: string | null
    channelNo: string
    languages: $Enums.TVChannelLanguages
    channeltype: $Enums.TVCHANNELTYPE
    category: string
    hotelId: string
    createdAt: Date
    updatedAt: Date
    _count: TVChannelsCountAggregateOutputType | null
    _min: TVChannelsMinAggregateOutputType | null
    _max: TVChannelsMaxAggregateOutputType | null
  }

  type GetTVChannelsGroupByPayload<T extends TVChannelsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TVChannelsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TVChannelsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TVChannelsGroupByOutputType[P]>
            : GetScalarType<T[P], TVChannelsGroupByOutputType[P]>
        }
      >
    >


  export type TVChannelsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    logo?: boolean
    channelNo?: boolean
    languages?: boolean
    channeltype?: boolean
    category?: boolean
    hotelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Hotel?: boolean | TVChannels$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["tVChannels"]>

  export type TVChannelsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    logo?: boolean
    channelNo?: boolean
    languages?: boolean
    channeltype?: boolean
    category?: boolean
    hotelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Hotel?: boolean | TVChannels$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["tVChannels"]>

  export type TVChannelsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    logo?: boolean
    channelNo?: boolean
    languages?: boolean
    channeltype?: boolean
    category?: boolean
    hotelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Hotel?: boolean | TVChannels$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["tVChannels"]>

  export type TVChannelsSelectScalar = {
    id?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    logo?: boolean
    channelNo?: boolean
    languages?: boolean
    channeltype?: boolean
    category?: boolean
    hotelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TVChannelsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "name_esp" | "description" | "description_esp" | "logo" | "channelNo" | "languages" | "channeltype" | "category" | "hotelId" | "createdAt" | "updatedAt", ExtArgs["result"]["tVChannels"]>
  export type TVChannelsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | TVChannels$HotelArgs<ExtArgs>
  }
  export type TVChannelsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | TVChannels$HotelArgs<ExtArgs>
  }
  export type TVChannelsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | TVChannels$HotelArgs<ExtArgs>
  }

  export type $TVChannelsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TVChannels"
    objects: {
      Hotel: Prisma.$HotelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      name_esp: string | null
      description: string
      description_esp: string | null
      logo: string | null
      channelNo: string
      languages: $Enums.TVChannelLanguages
      channeltype: $Enums.TVCHANNELTYPE
      category: string
      hotelId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tVChannels"]>
    composites: {}
  }

  type TVChannelsGetPayload<S extends boolean | null | undefined | TVChannelsDefaultArgs> = $Result.GetResult<Prisma.$TVChannelsPayload, S>

  type TVChannelsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TVChannelsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: TVChannelsCountAggregateInputType | true
    }

  export interface TVChannelsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TVChannels'], meta: { name: 'TVChannels' } }
    /**
     * Find zero or one TVChannels that matches the filter.
     * @param {TVChannelsFindUniqueArgs} args - Arguments to find a TVChannels
     * @example
     * // Get one TVChannels
     * const tVChannels = await prisma.tVChannels.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TVChannelsFindUniqueArgs>(args: SelectSubset<T, TVChannelsFindUniqueArgs<ExtArgs>>): Prisma__TVChannelsClient<$Result.GetResult<Prisma.$TVChannelsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TVChannels that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TVChannelsFindUniqueOrThrowArgs} args - Arguments to find a TVChannels
     * @example
     * // Get one TVChannels
     * const tVChannels = await prisma.tVChannels.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TVChannelsFindUniqueOrThrowArgs>(args: SelectSubset<T, TVChannelsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TVChannelsClient<$Result.GetResult<Prisma.$TVChannelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TVChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TVChannelsFindFirstArgs} args - Arguments to find a TVChannels
     * @example
     * // Get one TVChannels
     * const tVChannels = await prisma.tVChannels.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TVChannelsFindFirstArgs>(args?: SelectSubset<T, TVChannelsFindFirstArgs<ExtArgs>>): Prisma__TVChannelsClient<$Result.GetResult<Prisma.$TVChannelsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TVChannels that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TVChannelsFindFirstOrThrowArgs} args - Arguments to find a TVChannels
     * @example
     * // Get one TVChannels
     * const tVChannels = await prisma.tVChannels.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TVChannelsFindFirstOrThrowArgs>(args?: SelectSubset<T, TVChannelsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TVChannelsClient<$Result.GetResult<Prisma.$TVChannelsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TVChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TVChannelsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TVChannels
     * const tVChannels = await prisma.tVChannels.findMany()
     * 
     * // Get first 10 TVChannels
     * const tVChannels = await prisma.tVChannels.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tVChannelsWithIdOnly = await prisma.tVChannels.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TVChannelsFindManyArgs>(args?: SelectSubset<T, TVChannelsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TVChannelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TVChannels.
     * @param {TVChannelsCreateArgs} args - Arguments to create a TVChannels.
     * @example
     * // Create one TVChannels
     * const TVChannels = await prisma.tVChannels.create({
     *   data: {
     *     // ... data to create a TVChannels
     *   }
     * })
     * 
     */
    create<T extends TVChannelsCreateArgs>(args: SelectSubset<T, TVChannelsCreateArgs<ExtArgs>>): Prisma__TVChannelsClient<$Result.GetResult<Prisma.$TVChannelsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TVChannels.
     * @param {TVChannelsCreateManyArgs} args - Arguments to create many TVChannels.
     * @example
     * // Create many TVChannels
     * const tVChannels = await prisma.tVChannels.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TVChannelsCreateManyArgs>(args?: SelectSubset<T, TVChannelsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TVChannels and returns the data saved in the database.
     * @param {TVChannelsCreateManyAndReturnArgs} args - Arguments to create many TVChannels.
     * @example
     * // Create many TVChannels
     * const tVChannels = await prisma.tVChannels.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TVChannels and only return the `id`
     * const tVChannelsWithIdOnly = await prisma.tVChannels.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TVChannelsCreateManyAndReturnArgs>(args?: SelectSubset<T, TVChannelsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TVChannelsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TVChannels.
     * @param {TVChannelsDeleteArgs} args - Arguments to delete one TVChannels.
     * @example
     * // Delete one TVChannels
     * const TVChannels = await prisma.tVChannels.delete({
     *   where: {
     *     // ... filter to delete one TVChannels
     *   }
     * })
     * 
     */
    delete<T extends TVChannelsDeleteArgs>(args: SelectSubset<T, TVChannelsDeleteArgs<ExtArgs>>): Prisma__TVChannelsClient<$Result.GetResult<Prisma.$TVChannelsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TVChannels.
     * @param {TVChannelsUpdateArgs} args - Arguments to update one TVChannels.
     * @example
     * // Update one TVChannels
     * const tVChannels = await prisma.tVChannels.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TVChannelsUpdateArgs>(args: SelectSubset<T, TVChannelsUpdateArgs<ExtArgs>>): Prisma__TVChannelsClient<$Result.GetResult<Prisma.$TVChannelsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TVChannels.
     * @param {TVChannelsDeleteManyArgs} args - Arguments to filter TVChannels to delete.
     * @example
     * // Delete a few TVChannels
     * const { count } = await prisma.tVChannels.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TVChannelsDeleteManyArgs>(args?: SelectSubset<T, TVChannelsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TVChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TVChannelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TVChannels
     * const tVChannels = await prisma.tVChannels.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TVChannelsUpdateManyArgs>(args: SelectSubset<T, TVChannelsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TVChannels and returns the data updated in the database.
     * @param {TVChannelsUpdateManyAndReturnArgs} args - Arguments to update many TVChannels.
     * @example
     * // Update many TVChannels
     * const tVChannels = await prisma.tVChannels.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TVChannels and only return the `id`
     * const tVChannelsWithIdOnly = await prisma.tVChannels.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TVChannelsUpdateManyAndReturnArgs>(args: SelectSubset<T, TVChannelsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TVChannelsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TVChannels.
     * @param {TVChannelsUpsertArgs} args - Arguments to update or create a TVChannels.
     * @example
     * // Update or create a TVChannels
     * const tVChannels = await prisma.tVChannels.upsert({
     *   create: {
     *     // ... data to create a TVChannels
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TVChannels we want to update
     *   }
     * })
     */
    upsert<T extends TVChannelsUpsertArgs>(args: SelectSubset<T, TVChannelsUpsertArgs<ExtArgs>>): Prisma__TVChannelsClient<$Result.GetResult<Prisma.$TVChannelsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TVChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TVChannelsCountArgs} args - Arguments to filter TVChannels to count.
     * @example
     * // Count the number of TVChannels
     * const count = await prisma.tVChannels.count({
     *   where: {
     *     // ... the filter for the TVChannels we want to count
     *   }
     * })
    **/
    count<T extends TVChannelsCountArgs>(
      args?: Subset<T, TVChannelsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TVChannelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TVChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TVChannelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TVChannelsAggregateArgs>(args: Subset<T, TVChannelsAggregateArgs>): Prisma.PrismaPromise<GetTVChannelsAggregateType<T>>

    /**
     * Group by TVChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TVChannelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TVChannelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TVChannelsGroupByArgs['orderBy'] }
        : { orderBy?: TVChannelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TVChannelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTVChannelsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TVChannels model
   */
  readonly fields: TVChannelsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TVChannels.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TVChannelsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Hotel<T extends TVChannels$HotelArgs<ExtArgs> = {}>(args?: Subset<T, TVChannels$HotelArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TVChannels model
   */
  interface TVChannelsFieldRefs {
    readonly id: FieldRef<"TVChannels", 'String'>
    readonly name: FieldRef<"TVChannels", 'String'>
    readonly name_esp: FieldRef<"TVChannels", 'String'>
    readonly description: FieldRef<"TVChannels", 'String'>
    readonly description_esp: FieldRef<"TVChannels", 'String'>
    readonly logo: FieldRef<"TVChannels", 'String'>
    readonly channelNo: FieldRef<"TVChannels", 'String'>
    readonly languages: FieldRef<"TVChannels", 'TVChannelLanguages'>
    readonly channeltype: FieldRef<"TVChannels", 'TVCHANNELTYPE'>
    readonly category: FieldRef<"TVChannels", 'String'>
    readonly hotelId: FieldRef<"TVChannels", 'String'>
    readonly createdAt: FieldRef<"TVChannels", 'DateTime'>
    readonly updatedAt: FieldRef<"TVChannels", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TVChannels findUnique
   */
  export type TVChannelsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVChannels
     */
    select?: TVChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVChannels
     */
    omit?: TVChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVChannelsInclude<ExtArgs> | null
    /**
     * Filter, which TVChannels to fetch.
     */
    where: TVChannelsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVChannels findUniqueOrThrow
   */
  export type TVChannelsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVChannels
     */
    select?: TVChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVChannels
     */
    omit?: TVChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVChannelsInclude<ExtArgs> | null
    /**
     * Filter, which TVChannels to fetch.
     */
    where: TVChannelsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVChannels findFirst
   */
  export type TVChannelsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVChannels
     */
    select?: TVChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVChannels
     */
    omit?: TVChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVChannelsInclude<ExtArgs> | null
    /**
     * Filter, which TVChannels to fetch.
     */
    where?: TVChannelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TVChannels to fetch.
     */
    orderBy?: TVChannelsOrderByWithRelationInput | TVChannelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TVChannels.
     */
    cursor?: TVChannelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TVChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TVChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TVChannels.
     */
    distinct?: TVChannelsScalarFieldEnum | TVChannelsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVChannels findFirstOrThrow
   */
  export type TVChannelsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVChannels
     */
    select?: TVChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVChannels
     */
    omit?: TVChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVChannelsInclude<ExtArgs> | null
    /**
     * Filter, which TVChannels to fetch.
     */
    where?: TVChannelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TVChannels to fetch.
     */
    orderBy?: TVChannelsOrderByWithRelationInput | TVChannelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TVChannels.
     */
    cursor?: TVChannelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TVChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TVChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TVChannels.
     */
    distinct?: TVChannelsScalarFieldEnum | TVChannelsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVChannels findMany
   */
  export type TVChannelsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVChannels
     */
    select?: TVChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVChannels
     */
    omit?: TVChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVChannelsInclude<ExtArgs> | null
    /**
     * Filter, which TVChannels to fetch.
     */
    where?: TVChannelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TVChannels to fetch.
     */
    orderBy?: TVChannelsOrderByWithRelationInput | TVChannelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TVChannels.
     */
    cursor?: TVChannelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TVChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TVChannels.
     */
    skip?: number
    distinct?: TVChannelsScalarFieldEnum | TVChannelsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVChannels create
   */
  export type TVChannelsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVChannels
     */
    select?: TVChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVChannels
     */
    omit?: TVChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVChannelsInclude<ExtArgs> | null
    /**
     * The data needed to create a TVChannels.
     */
    data: XOR<TVChannelsCreateInput, TVChannelsUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVChannels createMany
   */
  export type TVChannelsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TVChannels.
     */
    data: TVChannelsCreateManyInput | TVChannelsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TVChannels createManyAndReturn
   */
  export type TVChannelsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVChannels
     */
    select?: TVChannelsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TVChannels
     */
    omit?: TVChannelsOmit<ExtArgs> | null
    /**
     * The data used to create many TVChannels.
     */
    data: TVChannelsCreateManyInput | TVChannelsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVChannelsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TVChannels update
   */
  export type TVChannelsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVChannels
     */
    select?: TVChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVChannels
     */
    omit?: TVChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVChannelsInclude<ExtArgs> | null
    /**
     * The data needed to update a TVChannels.
     */
    data: XOR<TVChannelsUpdateInput, TVChannelsUncheckedUpdateInput>
    /**
     * Choose, which TVChannels to update.
     */
    where: TVChannelsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVChannels updateMany
   */
  export type TVChannelsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TVChannels.
     */
    data: XOR<TVChannelsUpdateManyMutationInput, TVChannelsUncheckedUpdateManyInput>
    /**
     * Filter which TVChannels to update
     */
    where?: TVChannelsWhereInput
    /**
     * Limit how many TVChannels to update.
     */
    limit?: number
  }

  /**
   * TVChannels updateManyAndReturn
   */
  export type TVChannelsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVChannels
     */
    select?: TVChannelsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TVChannels
     */
    omit?: TVChannelsOmit<ExtArgs> | null
    /**
     * The data used to update TVChannels.
     */
    data: XOR<TVChannelsUpdateManyMutationInput, TVChannelsUncheckedUpdateManyInput>
    /**
     * Filter which TVChannels to update
     */
    where?: TVChannelsWhereInput
    /**
     * Limit how many TVChannels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVChannelsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TVChannels upsert
   */
  export type TVChannelsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVChannels
     */
    select?: TVChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVChannels
     */
    omit?: TVChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVChannelsInclude<ExtArgs> | null
    /**
     * The filter to search for the TVChannels to update in case it exists.
     */
    where: TVChannelsWhereUniqueInput
    /**
     * In case the TVChannels found by the `where` argument doesn't exist, create a new TVChannels with this data.
     */
    create: XOR<TVChannelsCreateInput, TVChannelsUncheckedCreateInput>
    /**
     * In case the TVChannels was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TVChannelsUpdateInput, TVChannelsUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVChannels delete
   */
  export type TVChannelsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVChannels
     */
    select?: TVChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVChannels
     */
    omit?: TVChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVChannelsInclude<ExtArgs> | null
    /**
     * Filter which TVChannels to delete.
     */
    where: TVChannelsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TVChannels deleteMany
   */
  export type TVChannelsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TVChannels to delete
     */
    where?: TVChannelsWhereInput
    /**
     * Limit how many TVChannels to delete.
     */
    limit?: number
  }

  /**
   * TVChannels.Hotel
   */
  export type TVChannels$HotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    where?: HotelWhereInput
  }

  /**
   * TVChannels without action
   */
  export type TVChannelsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TVChannels
     */
    select?: TVChannelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TVChannels
     */
    omit?: TVChannelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TVChannelsInclude<ExtArgs> | null
  }


  /**
   * Model Restaurant
   */

  export type AggregateRestaurant = {
    _count: RestaurantCountAggregateOutputType | null
    _avg: RestaurantAvgAggregateOutputType | null
    _sum: RestaurantSumAggregateOutputType | null
    _min: RestaurantMinAggregateOutputType | null
    _max: RestaurantMaxAggregateOutputType | null
  }

  export type RestaurantAvgAggregateOutputType = {
    listorder: number | null
  }

  export type RestaurantSumAggregateOutputType = {
    listorder: number | null
  }

  export type RestaurantMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    descriptionshort: string | null
    description_esp: string | null
    descriptionshort_esp: string | null
    image: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    phone: string | null
    email: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
    listorder: number | null
  }

  export type RestaurantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    descriptionshort: string | null
    description_esp: string | null
    descriptionshort_esp: string | null
    image: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    phone: string | null
    email: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
    listorder: number | null
  }

  export type RestaurantCountAggregateOutputType = {
    id: number
    name: number
    description: number
    descriptionshort: number
    description_esp: number
    descriptionshort_esp: number
    image: number
    address: number
    city: number
    state: number
    zipCode: number
    phone: number
    email: number
    website: number
    createdAt: number
    updatedAt: number
    listorder: number
    _all: number
  }


  export type RestaurantAvgAggregateInputType = {
    listorder?: true
  }

  export type RestaurantSumAggregateInputType = {
    listorder?: true
  }

  export type RestaurantMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    descriptionshort?: true
    description_esp?: true
    descriptionshort_esp?: true
    image?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    phone?: true
    email?: true
    website?: true
    createdAt?: true
    updatedAt?: true
    listorder?: true
  }

  export type RestaurantMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    descriptionshort?: true
    description_esp?: true
    descriptionshort_esp?: true
    image?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    phone?: true
    email?: true
    website?: true
    createdAt?: true
    updatedAt?: true
    listorder?: true
  }

  export type RestaurantCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    descriptionshort?: true
    description_esp?: true
    descriptionshort_esp?: true
    image?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    phone?: true
    email?: true
    website?: true
    createdAt?: true
    updatedAt?: true
    listorder?: true
    _all?: true
  }

  export type RestaurantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Restaurant to aggregate.
     */
    where?: RestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restaurants to fetch.
     */
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restaurants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Restaurants
    **/
    _count?: true | RestaurantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RestaurantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RestaurantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RestaurantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RestaurantMaxAggregateInputType
  }

  export type GetRestaurantAggregateType<T extends RestaurantAggregateArgs> = {
        [P in keyof T & keyof AggregateRestaurant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestaurant[P]>
      : GetScalarType<T[P], AggregateRestaurant[P]>
  }




  export type RestaurantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantWhereInput
    orderBy?: RestaurantOrderByWithAggregationInput | RestaurantOrderByWithAggregationInput[]
    by: RestaurantScalarFieldEnum[] | RestaurantScalarFieldEnum
    having?: RestaurantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RestaurantCountAggregateInputType | true
    _avg?: RestaurantAvgAggregateInputType
    _sum?: RestaurantSumAggregateInputType
    _min?: RestaurantMinAggregateInputType
    _max?: RestaurantMaxAggregateInputType
  }

  export type RestaurantGroupByOutputType = {
    id: string
    name: string
    description: string | null
    descriptionshort: string | null
    description_esp: string | null
    descriptionshort_esp: string | null
    image: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    phone: string | null
    email: string | null
    website: string | null
    createdAt: Date
    updatedAt: Date
    listorder: number
    _count: RestaurantCountAggregateOutputType | null
    _avg: RestaurantAvgAggregateOutputType | null
    _sum: RestaurantSumAggregateOutputType | null
    _min: RestaurantMinAggregateOutputType | null
    _max: RestaurantMaxAggregateOutputType | null
  }

  type GetRestaurantGroupByPayload<T extends RestaurantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RestaurantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RestaurantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RestaurantGroupByOutputType[P]>
            : GetScalarType<T[P], RestaurantGroupByOutputType[P]>
        }
      >
    >


  export type RestaurantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    descriptionshort?: boolean
    description_esp?: boolean
    descriptionshort_esp?: boolean
    image?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    listorder?: boolean
    categories?: boolean | Restaurant$categoriesArgs<ExtArgs>
    dishes?: boolean | Restaurant$dishesArgs<ExtArgs>
    menus?: boolean | Restaurant$menusArgs<ExtArgs>
    tables?: boolean | Restaurant$tablesArgs<ExtArgs>
    reservations?: boolean | Restaurant$reservationsArgs<ExtArgs>
    openingHours?: boolean | Restaurant$openingHoursArgs<ExtArgs>
    _count?: boolean | RestaurantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurant"]>

  export type RestaurantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    descriptionshort?: boolean
    description_esp?: boolean
    descriptionshort_esp?: boolean
    image?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    listorder?: boolean
  }, ExtArgs["result"]["restaurant"]>

  export type RestaurantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    descriptionshort?: boolean
    description_esp?: boolean
    descriptionshort_esp?: boolean
    image?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    listorder?: boolean
  }, ExtArgs["result"]["restaurant"]>

  export type RestaurantSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    descriptionshort?: boolean
    description_esp?: boolean
    descriptionshort_esp?: boolean
    image?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    listorder?: boolean
  }

  export type RestaurantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "descriptionshort" | "description_esp" | "descriptionshort_esp" | "image" | "address" | "city" | "state" | "zipCode" | "phone" | "email" | "website" | "createdAt" | "updatedAt" | "listorder", ExtArgs["result"]["restaurant"]>
  export type RestaurantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | Restaurant$categoriesArgs<ExtArgs>
    dishes?: boolean | Restaurant$dishesArgs<ExtArgs>
    menus?: boolean | Restaurant$menusArgs<ExtArgs>
    tables?: boolean | Restaurant$tablesArgs<ExtArgs>
    reservations?: boolean | Restaurant$reservationsArgs<ExtArgs>
    openingHours?: boolean | Restaurant$openingHoursArgs<ExtArgs>
    _count?: boolean | RestaurantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RestaurantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RestaurantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RestaurantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Restaurant"
    objects: {
      categories: Prisma.$CategoryPayload<ExtArgs>[]
      dishes: Prisma.$DishPayload<ExtArgs>[]
      menus: Prisma.$MenuPayload<ExtArgs>[]
      tables: Prisma.$TablePayload<ExtArgs>[]
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
      openingHours: Prisma.$OpeningHoursPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      descriptionshort: string | null
      description_esp: string | null
      descriptionshort_esp: string | null
      image: string | null
      address: string | null
      city: string | null
      state: string | null
      zipCode: string | null
      phone: string | null
      email: string | null
      website: string | null
      createdAt: Date
      updatedAt: Date
      listorder: number
    }, ExtArgs["result"]["restaurant"]>
    composites: {}
  }

  type RestaurantGetPayload<S extends boolean | null | undefined | RestaurantDefaultArgs> = $Result.GetResult<Prisma.$RestaurantPayload, S>

  type RestaurantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RestaurantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: RestaurantCountAggregateInputType | true
    }

  export interface RestaurantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Restaurant'], meta: { name: 'Restaurant' } }
    /**
     * Find zero or one Restaurant that matches the filter.
     * @param {RestaurantFindUniqueArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RestaurantFindUniqueArgs>(args: SelectSubset<T, RestaurantFindUniqueArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Restaurant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RestaurantFindUniqueOrThrowArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RestaurantFindUniqueOrThrowArgs>(args: SelectSubset<T, RestaurantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Restaurant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantFindFirstArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RestaurantFindFirstArgs>(args?: SelectSubset<T, RestaurantFindFirstArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Restaurant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantFindFirstOrThrowArgs} args - Arguments to find a Restaurant
     * @example
     * // Get one Restaurant
     * const restaurant = await prisma.restaurant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RestaurantFindFirstOrThrowArgs>(args?: SelectSubset<T, RestaurantFindFirstOrThrowArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Restaurants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Restaurants
     * const restaurants = await prisma.restaurant.findMany()
     * 
     * // Get first 10 Restaurants
     * const restaurants = await prisma.restaurant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const restaurantWithIdOnly = await prisma.restaurant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RestaurantFindManyArgs>(args?: SelectSubset<T, RestaurantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Restaurant.
     * @param {RestaurantCreateArgs} args - Arguments to create a Restaurant.
     * @example
     * // Create one Restaurant
     * const Restaurant = await prisma.restaurant.create({
     *   data: {
     *     // ... data to create a Restaurant
     *   }
     * })
     * 
     */
    create<T extends RestaurantCreateArgs>(args: SelectSubset<T, RestaurantCreateArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Restaurants.
     * @param {RestaurantCreateManyArgs} args - Arguments to create many Restaurants.
     * @example
     * // Create many Restaurants
     * const restaurant = await prisma.restaurant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RestaurantCreateManyArgs>(args?: SelectSubset<T, RestaurantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Restaurants and returns the data saved in the database.
     * @param {RestaurantCreateManyAndReturnArgs} args - Arguments to create many Restaurants.
     * @example
     * // Create many Restaurants
     * const restaurant = await prisma.restaurant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Restaurants and only return the `id`
     * const restaurantWithIdOnly = await prisma.restaurant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RestaurantCreateManyAndReturnArgs>(args?: SelectSubset<T, RestaurantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Restaurant.
     * @param {RestaurantDeleteArgs} args - Arguments to delete one Restaurant.
     * @example
     * // Delete one Restaurant
     * const Restaurant = await prisma.restaurant.delete({
     *   where: {
     *     // ... filter to delete one Restaurant
     *   }
     * })
     * 
     */
    delete<T extends RestaurantDeleteArgs>(args: SelectSubset<T, RestaurantDeleteArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Restaurant.
     * @param {RestaurantUpdateArgs} args - Arguments to update one Restaurant.
     * @example
     * // Update one Restaurant
     * const restaurant = await prisma.restaurant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RestaurantUpdateArgs>(args: SelectSubset<T, RestaurantUpdateArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Restaurants.
     * @param {RestaurantDeleteManyArgs} args - Arguments to filter Restaurants to delete.
     * @example
     * // Delete a few Restaurants
     * const { count } = await prisma.restaurant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RestaurantDeleteManyArgs>(args?: SelectSubset<T, RestaurantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Restaurants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Restaurants
     * const restaurant = await prisma.restaurant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RestaurantUpdateManyArgs>(args: SelectSubset<T, RestaurantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Restaurants and returns the data updated in the database.
     * @param {RestaurantUpdateManyAndReturnArgs} args - Arguments to update many Restaurants.
     * @example
     * // Update many Restaurants
     * const restaurant = await prisma.restaurant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Restaurants and only return the `id`
     * const restaurantWithIdOnly = await prisma.restaurant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RestaurantUpdateManyAndReturnArgs>(args: SelectSubset<T, RestaurantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Restaurant.
     * @param {RestaurantUpsertArgs} args - Arguments to update or create a Restaurant.
     * @example
     * // Update or create a Restaurant
     * const restaurant = await prisma.restaurant.upsert({
     *   create: {
     *     // ... data to create a Restaurant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Restaurant we want to update
     *   }
     * })
     */
    upsert<T extends RestaurantUpsertArgs>(args: SelectSubset<T, RestaurantUpsertArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Restaurants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantCountArgs} args - Arguments to filter Restaurants to count.
     * @example
     * // Count the number of Restaurants
     * const count = await prisma.restaurant.count({
     *   where: {
     *     // ... the filter for the Restaurants we want to count
     *   }
     * })
    **/
    count<T extends RestaurantCountArgs>(
      args?: Subset<T, RestaurantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RestaurantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Restaurant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RestaurantAggregateArgs>(args: Subset<T, RestaurantAggregateArgs>): Prisma.PrismaPromise<GetRestaurantAggregateType<T>>

    /**
     * Group by Restaurant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RestaurantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RestaurantGroupByArgs['orderBy'] }
        : { orderBy?: RestaurantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RestaurantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRestaurantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Restaurant model
   */
  readonly fields: RestaurantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Restaurant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RestaurantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends Restaurant$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Restaurant$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dishes<T extends Restaurant$dishesArgs<ExtArgs> = {}>(args?: Subset<T, Restaurant$dishesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    menus<T extends Restaurant$menusArgs<ExtArgs> = {}>(args?: Subset<T, Restaurant$menusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tables<T extends Restaurant$tablesArgs<ExtArgs> = {}>(args?: Subset<T, Restaurant$tablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reservations<T extends Restaurant$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Restaurant$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    openingHours<T extends Restaurant$openingHoursArgs<ExtArgs> = {}>(args?: Subset<T, Restaurant$openingHoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpeningHoursPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Restaurant model
   */
  interface RestaurantFieldRefs {
    readonly id: FieldRef<"Restaurant", 'String'>
    readonly name: FieldRef<"Restaurant", 'String'>
    readonly description: FieldRef<"Restaurant", 'String'>
    readonly descriptionshort: FieldRef<"Restaurant", 'String'>
    readonly description_esp: FieldRef<"Restaurant", 'String'>
    readonly descriptionshort_esp: FieldRef<"Restaurant", 'String'>
    readonly image: FieldRef<"Restaurant", 'String'>
    readonly address: FieldRef<"Restaurant", 'String'>
    readonly city: FieldRef<"Restaurant", 'String'>
    readonly state: FieldRef<"Restaurant", 'String'>
    readonly zipCode: FieldRef<"Restaurant", 'String'>
    readonly phone: FieldRef<"Restaurant", 'String'>
    readonly email: FieldRef<"Restaurant", 'String'>
    readonly website: FieldRef<"Restaurant", 'String'>
    readonly createdAt: FieldRef<"Restaurant", 'DateTime'>
    readonly updatedAt: FieldRef<"Restaurant", 'DateTime'>
    readonly listorder: FieldRef<"Restaurant", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Restaurant findUnique
   */
  export type RestaurantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurant to fetch.
     */
    where: RestaurantWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Restaurant findUniqueOrThrow
   */
  export type RestaurantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurant to fetch.
     */
    where: RestaurantWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Restaurant findFirst
   */
  export type RestaurantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurant to fetch.
     */
    where?: RestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restaurants to fetch.
     */
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Restaurants.
     */
    cursor?: RestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restaurants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Restaurants.
     */
    distinct?: RestaurantScalarFieldEnum | RestaurantScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Restaurant findFirstOrThrow
   */
  export type RestaurantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurant to fetch.
     */
    where?: RestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restaurants to fetch.
     */
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Restaurants.
     */
    cursor?: RestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restaurants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Restaurants.
     */
    distinct?: RestaurantScalarFieldEnum | RestaurantScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Restaurant findMany
   */
  export type RestaurantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter, which Restaurants to fetch.
     */
    where?: RestaurantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restaurants to fetch.
     */
    orderBy?: RestaurantOrderByWithRelationInput | RestaurantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Restaurants.
     */
    cursor?: RestaurantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restaurants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restaurants.
     */
    skip?: number
    distinct?: RestaurantScalarFieldEnum | RestaurantScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Restaurant create
   */
  export type RestaurantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * The data needed to create a Restaurant.
     */
    data: XOR<RestaurantCreateInput, RestaurantUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Restaurant createMany
   */
  export type RestaurantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Restaurants.
     */
    data: RestaurantCreateManyInput | RestaurantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Restaurant createManyAndReturn
   */
  export type RestaurantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * The data used to create many Restaurants.
     */
    data: RestaurantCreateManyInput | RestaurantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Restaurant update
   */
  export type RestaurantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * The data needed to update a Restaurant.
     */
    data: XOR<RestaurantUpdateInput, RestaurantUncheckedUpdateInput>
    /**
     * Choose, which Restaurant to update.
     */
    where: RestaurantWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Restaurant updateMany
   */
  export type RestaurantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Restaurants.
     */
    data: XOR<RestaurantUpdateManyMutationInput, RestaurantUncheckedUpdateManyInput>
    /**
     * Filter which Restaurants to update
     */
    where?: RestaurantWhereInput
    /**
     * Limit how many Restaurants to update.
     */
    limit?: number
  }

  /**
   * Restaurant updateManyAndReturn
   */
  export type RestaurantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * The data used to update Restaurants.
     */
    data: XOR<RestaurantUpdateManyMutationInput, RestaurantUncheckedUpdateManyInput>
    /**
     * Filter which Restaurants to update
     */
    where?: RestaurantWhereInput
    /**
     * Limit how many Restaurants to update.
     */
    limit?: number
  }

  /**
   * Restaurant upsert
   */
  export type RestaurantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * The filter to search for the Restaurant to update in case it exists.
     */
    where: RestaurantWhereUniqueInput
    /**
     * In case the Restaurant found by the `where` argument doesn't exist, create a new Restaurant with this data.
     */
    create: XOR<RestaurantCreateInput, RestaurantUncheckedCreateInput>
    /**
     * In case the Restaurant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RestaurantUpdateInput, RestaurantUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Restaurant delete
   */
  export type RestaurantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
    /**
     * Filter which Restaurant to delete.
     */
    where: RestaurantWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Restaurant deleteMany
   */
  export type RestaurantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Restaurants to delete
     */
    where?: RestaurantWhereInput
    /**
     * Limit how many Restaurants to delete.
     */
    limit?: number
  }

  /**
   * Restaurant.categories
   */
  export type Restaurant$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Restaurant.dishes
   */
  export type Restaurant$dishesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    where?: DishWhereInput
    orderBy?: DishOrderByWithRelationInput | DishOrderByWithRelationInput[]
    cursor?: DishWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DishScalarFieldEnum | DishScalarFieldEnum[]
  }

  /**
   * Restaurant.menus
   */
  export type Restaurant$menusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    where?: MenuWhereInput
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    cursor?: MenuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Restaurant.tables
   */
  export type Restaurant$tablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    where?: TableWhereInput
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    cursor?: TableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Restaurant.reservations
   */
  export type Restaurant$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Restaurant.openingHours
   */
  export type Restaurant$openingHoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpeningHours
     */
    select?: OpeningHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpeningHours
     */
    omit?: OpeningHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpeningHoursInclude<ExtArgs> | null
    where?: OpeningHoursWhereInput
    orderBy?: OpeningHoursOrderByWithRelationInput | OpeningHoursOrderByWithRelationInput[]
    cursor?: OpeningHoursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpeningHoursScalarFieldEnum | OpeningHoursScalarFieldEnum[]
  }

  /**
   * Restaurant without action
   */
  export type RestaurantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restaurant
     */
    select?: RestaurantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restaurant
     */
    omit?: RestaurantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantInclude<ExtArgs> | null
  }


  /**
   * Model Menu
   */

  export type AggregateMenu = {
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  export type MenuAvgAggregateOutputType = {
    position: number | null
    price: number | null
  }

  export type MenuSumAggregateOutputType = {
    position: number | null
    price: number | null
  }

  export type MenuMinAggregateOutputType = {
    id: string | null
    position: number | null
    name: string | null
    name_esp: string | null
    description: string | null
    description_esp: string | null
    image: string | null
    price: number | null
    restaurantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
  }

  export type MenuMaxAggregateOutputType = {
    id: string | null
    position: number | null
    name: string | null
    name_esp: string | null
    description: string | null
    description_esp: string | null
    image: string | null
    price: number | null
    restaurantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
  }

  export type MenuCountAggregateOutputType = {
    id: number
    position: number
    name: number
    name_esp: number
    description: number
    description_esp: number
    image: number
    price: number
    restaurantId: number
    createdAt: number
    updatedAt: number
    isActive: number
    _all: number
  }


  export type MenuAvgAggregateInputType = {
    position?: true
    price?: true
  }

  export type MenuSumAggregateInputType = {
    position?: true
    price?: true
  }

  export type MenuMinAggregateInputType = {
    id?: true
    position?: true
    name?: true
    name_esp?: true
    description?: true
    description_esp?: true
    image?: true
    price?: true
    restaurantId?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
  }

  export type MenuMaxAggregateInputType = {
    id?: true
    position?: true
    name?: true
    name_esp?: true
    description?: true
    description_esp?: true
    image?: true
    price?: true
    restaurantId?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
  }

  export type MenuCountAggregateInputType = {
    id?: true
    position?: true
    name?: true
    name_esp?: true
    description?: true
    description_esp?: true
    image?: true
    price?: true
    restaurantId?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    _all?: true
  }

  export type MenuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Menu to aggregate.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Menus
    **/
    _count?: true | MenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuMaxAggregateInputType
  }

  export type GetMenuAggregateType<T extends MenuAggregateArgs> = {
        [P in keyof T & keyof AggregateMenu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenu[P]>
      : GetScalarType<T[P], AggregateMenu[P]>
  }




  export type MenuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuWhereInput
    orderBy?: MenuOrderByWithAggregationInput | MenuOrderByWithAggregationInput[]
    by: MenuScalarFieldEnum[] | MenuScalarFieldEnum
    having?: MenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuCountAggregateInputType | true
    _avg?: MenuAvgAggregateInputType
    _sum?: MenuSumAggregateInputType
    _min?: MenuMinAggregateInputType
    _max?: MenuMaxAggregateInputType
  }

  export type MenuGroupByOutputType = {
    id: string
    position: number
    name: string
    name_esp: string
    description: string | null
    description_esp: string | null
    image: string | null
    price: number
    restaurantId: string
    createdAt: Date
    updatedAt: Date
    isActive: boolean
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  type GetMenuGroupByPayload<T extends MenuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuGroupByOutputType[P]>
            : GetScalarType<T[P], MenuGroupByOutputType[P]>
        }
      >
    >


  export type MenuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    position?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    price?: boolean
    restaurantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
    dishes?: boolean | Menu$dishesArgs<ExtArgs>
    _count?: boolean | MenuCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menu"]>

  export type MenuSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    position?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    price?: boolean
    restaurantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menu"]>

  export type MenuSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    position?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    price?: boolean
    restaurantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menu"]>

  export type MenuSelectScalar = {
    id?: boolean
    position?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    price?: boolean
    restaurantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
  }

  export type MenuOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "position" | "name" | "name_esp" | "description" | "description_esp" | "image" | "price" | "restaurantId" | "createdAt" | "updatedAt" | "isActive", ExtArgs["result"]["menu"]>
  export type MenuInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
    dishes?: boolean | Menu$dishesArgs<ExtArgs>
    _count?: boolean | MenuCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MenuIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }
  export type MenuIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }

  export type $MenuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Menu"
    objects: {
      restaurant: Prisma.$RestaurantPayload<ExtArgs>
      dishes: Prisma.$DishPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      position: number
      name: string
      name_esp: string
      description: string | null
      description_esp: string | null
      image: string | null
      price: number
      restaurantId: string
      createdAt: Date
      updatedAt: Date
      isActive: boolean
    }, ExtArgs["result"]["menu"]>
    composites: {}
  }

  type MenuGetPayload<S extends boolean | null | undefined | MenuDefaultArgs> = $Result.GetResult<Prisma.$MenuPayload, S>

  type MenuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MenuFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: MenuCountAggregateInputType | true
    }

  export interface MenuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Menu'], meta: { name: 'Menu' } }
    /**
     * Find zero or one Menu that matches the filter.
     * @param {MenuFindUniqueArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenuFindUniqueArgs>(args: SelectSubset<T, MenuFindUniqueArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Menu that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenuFindUniqueOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenuFindUniqueOrThrowArgs>(args: SelectSubset<T, MenuFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Menu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenuFindFirstArgs>(args?: SelectSubset<T, MenuFindFirstArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Menu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenuFindFirstOrThrowArgs>(args?: SelectSubset<T, MenuFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Menus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Menus
     * const menus = await prisma.menu.findMany()
     * 
     * // Get first 10 Menus
     * const menus = await prisma.menu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuWithIdOnly = await prisma.menu.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MenuFindManyArgs>(args?: SelectSubset<T, MenuFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Menu.
     * @param {MenuCreateArgs} args - Arguments to create a Menu.
     * @example
     * // Create one Menu
     * const Menu = await prisma.menu.create({
     *   data: {
     *     // ... data to create a Menu
     *   }
     * })
     * 
     */
    create<T extends MenuCreateArgs>(args: SelectSubset<T, MenuCreateArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Menus.
     * @param {MenuCreateManyArgs} args - Arguments to create many Menus.
     * @example
     * // Create many Menus
     * const menu = await prisma.menu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenuCreateManyArgs>(args?: SelectSubset<T, MenuCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Menus and returns the data saved in the database.
     * @param {MenuCreateManyAndReturnArgs} args - Arguments to create many Menus.
     * @example
     * // Create many Menus
     * const menu = await prisma.menu.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Menus and only return the `id`
     * const menuWithIdOnly = await prisma.menu.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenuCreateManyAndReturnArgs>(args?: SelectSubset<T, MenuCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Menu.
     * @param {MenuDeleteArgs} args - Arguments to delete one Menu.
     * @example
     * // Delete one Menu
     * const Menu = await prisma.menu.delete({
     *   where: {
     *     // ... filter to delete one Menu
     *   }
     * })
     * 
     */
    delete<T extends MenuDeleteArgs>(args: SelectSubset<T, MenuDeleteArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Menu.
     * @param {MenuUpdateArgs} args - Arguments to update one Menu.
     * @example
     * // Update one Menu
     * const menu = await prisma.menu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenuUpdateArgs>(args: SelectSubset<T, MenuUpdateArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Menus.
     * @param {MenuDeleteManyArgs} args - Arguments to filter Menus to delete.
     * @example
     * // Delete a few Menus
     * const { count } = await prisma.menu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenuDeleteManyArgs>(args?: SelectSubset<T, MenuDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Menus
     * const menu = await prisma.menu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenuUpdateManyArgs>(args: SelectSubset<T, MenuUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menus and returns the data updated in the database.
     * @param {MenuUpdateManyAndReturnArgs} args - Arguments to update many Menus.
     * @example
     * // Update many Menus
     * const menu = await prisma.menu.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Menus and only return the `id`
     * const menuWithIdOnly = await prisma.menu.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MenuUpdateManyAndReturnArgs>(args: SelectSubset<T, MenuUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Menu.
     * @param {MenuUpsertArgs} args - Arguments to update or create a Menu.
     * @example
     * // Update or create a Menu
     * const menu = await prisma.menu.upsert({
     *   create: {
     *     // ... data to create a Menu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Menu we want to update
     *   }
     * })
     */
    upsert<T extends MenuUpsertArgs>(args: SelectSubset<T, MenuUpsertArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuCountArgs} args - Arguments to filter Menus to count.
     * @example
     * // Count the number of Menus
     * const count = await prisma.menu.count({
     *   where: {
     *     // ... the filter for the Menus we want to count
     *   }
     * })
    **/
    count<T extends MenuCountArgs>(
      args?: Subset<T, MenuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuAggregateArgs>(args: Subset<T, MenuAggregateArgs>): Prisma.PrismaPromise<GetMenuAggregateType<T>>

    /**
     * Group by Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuGroupByArgs['orderBy'] }
        : { orderBy?: MenuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Menu model
   */
  readonly fields: MenuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Menu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    restaurant<T extends RestaurantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantDefaultArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dishes<T extends Menu$dishesArgs<ExtArgs> = {}>(args?: Subset<T, Menu$dishesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Menu model
   */
  interface MenuFieldRefs {
    readonly id: FieldRef<"Menu", 'String'>
    readonly position: FieldRef<"Menu", 'Int'>
    readonly name: FieldRef<"Menu", 'String'>
    readonly name_esp: FieldRef<"Menu", 'String'>
    readonly description: FieldRef<"Menu", 'String'>
    readonly description_esp: FieldRef<"Menu", 'String'>
    readonly image: FieldRef<"Menu", 'String'>
    readonly price: FieldRef<"Menu", 'Float'>
    readonly restaurantId: FieldRef<"Menu", 'String'>
    readonly createdAt: FieldRef<"Menu", 'DateTime'>
    readonly updatedAt: FieldRef<"Menu", 'DateTime'>
    readonly isActive: FieldRef<"Menu", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Menu findUnique
   */
  export type MenuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where: MenuWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Menu findUniqueOrThrow
   */
  export type MenuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where: MenuWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Menu findFirst
   */
  export type MenuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Menu findFirstOrThrow
   */
  export type MenuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Menu findMany
   */
  export type MenuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menus to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Menu create
   */
  export type MenuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The data needed to create a Menu.
     */
    data: XOR<MenuCreateInput, MenuUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Menu createMany
   */
  export type MenuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Menus.
     */
    data: MenuCreateManyInput | MenuCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Menu createManyAndReturn
   */
  export type MenuCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * The data used to create many Menus.
     */
    data: MenuCreateManyInput | MenuCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Menu update
   */
  export type MenuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The data needed to update a Menu.
     */
    data: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
    /**
     * Choose, which Menu to update.
     */
    where: MenuWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Menu updateMany
   */
  export type MenuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Menus.
     */
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyInput>
    /**
     * Filter which Menus to update
     */
    where?: MenuWhereInput
    /**
     * Limit how many Menus to update.
     */
    limit?: number
  }

  /**
   * Menu updateManyAndReturn
   */
  export type MenuUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * The data used to update Menus.
     */
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyInput>
    /**
     * Filter which Menus to update
     */
    where?: MenuWhereInput
    /**
     * Limit how many Menus to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Menu upsert
   */
  export type MenuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The filter to search for the Menu to update in case it exists.
     */
    where: MenuWhereUniqueInput
    /**
     * In case the Menu found by the `where` argument doesn't exist, create a new Menu with this data.
     */
    create: XOR<MenuCreateInput, MenuUncheckedCreateInput>
    /**
     * In case the Menu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Menu delete
   */
  export type MenuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter which Menu to delete.
     */
    where: MenuWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Menu deleteMany
   */
  export type MenuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Menus to delete
     */
    where?: MenuWhereInput
    /**
     * Limit how many Menus to delete.
     */
    limit?: number
  }

  /**
   * Menu.dishes
   */
  export type Menu$dishesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    where?: DishWhereInput
    orderBy?: DishOrderByWithRelationInput | DishOrderByWithRelationInput[]
    cursor?: DishWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DishScalarFieldEnum | DishScalarFieldEnum[]
  }

  /**
   * Menu without action
   */
  export type MenuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
  }


  /**
   * Model Table
   */

  export type AggregateTable = {
    _count: TableCountAggregateOutputType | null
    _avg: TableAvgAggregateOutputType | null
    _sum: TableSumAggregateOutputType | null
    _min: TableMinAggregateOutputType | null
    _max: TableMaxAggregateOutputType | null
  }

  export type TableAvgAggregateOutputType = {
    number: number | null
    capacity: number | null
  }

  export type TableSumAggregateOutputType = {
    number: number | null
    capacity: number | null
  }

  export type TableMinAggregateOutputType = {
    id: string | null
    number: number | null
    capacity: number | null
    location: string | null
    isActive: boolean | null
    restaurantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TableMaxAggregateOutputType = {
    id: string | null
    number: number | null
    capacity: number | null
    location: string | null
    isActive: boolean | null
    restaurantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TableCountAggregateOutputType = {
    id: number
    number: number
    capacity: number
    location: number
    isActive: number
    restaurantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TableAvgAggregateInputType = {
    number?: true
    capacity?: true
  }

  export type TableSumAggregateInputType = {
    number?: true
    capacity?: true
  }

  export type TableMinAggregateInputType = {
    id?: true
    number?: true
    capacity?: true
    location?: true
    isActive?: true
    restaurantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TableMaxAggregateInputType = {
    id?: true
    number?: true
    capacity?: true
    location?: true
    isActive?: true
    restaurantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TableCountAggregateInputType = {
    id?: true
    number?: true
    capacity?: true
    location?: true
    isActive?: true
    restaurantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Table to aggregate.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tables
    **/
    _count?: true | TableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TableMaxAggregateInputType
  }

  export type GetTableAggregateType<T extends TableAggregateArgs> = {
        [P in keyof T & keyof AggregateTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTable[P]>
      : GetScalarType<T[P], AggregateTable[P]>
  }




  export type TableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableWhereInput
    orderBy?: TableOrderByWithAggregationInput | TableOrderByWithAggregationInput[]
    by: TableScalarFieldEnum[] | TableScalarFieldEnum
    having?: TableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TableCountAggregateInputType | true
    _avg?: TableAvgAggregateInputType
    _sum?: TableSumAggregateInputType
    _min?: TableMinAggregateInputType
    _max?: TableMaxAggregateInputType
  }

  export type TableGroupByOutputType = {
    id: string
    number: number
    capacity: number
    location: string | null
    isActive: boolean
    restaurantId: string
    createdAt: Date
    updatedAt: Date
    _count: TableCountAggregateOutputType | null
    _avg: TableAvgAggregateOutputType | null
    _sum: TableSumAggregateOutputType | null
    _min: TableMinAggregateOutputType | null
    _max: TableMaxAggregateOutputType | null
  }

  type GetTableGroupByPayload<T extends TableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TableGroupByOutputType[P]>
            : GetScalarType<T[P], TableGroupByOutputType[P]>
        }
      >
    >


  export type TableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    capacity?: boolean
    location?: boolean
    isActive?: boolean
    restaurantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
    reservations?: boolean | Table$reservationsArgs<ExtArgs>
    _count?: boolean | TableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["table"]>

  export type TableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    capacity?: boolean
    location?: boolean
    isActive?: boolean
    restaurantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["table"]>

  export type TableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    capacity?: boolean
    location?: boolean
    isActive?: boolean
    restaurantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["table"]>

  export type TableSelectScalar = {
    id?: boolean
    number?: boolean
    capacity?: boolean
    location?: boolean
    isActive?: boolean
    restaurantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "number" | "capacity" | "location" | "isActive" | "restaurantId" | "createdAt" | "updatedAt", ExtArgs["result"]["table"]>
  export type TableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
    reservations?: boolean | Table$reservationsArgs<ExtArgs>
    _count?: boolean | TableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }
  export type TableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }

  export type $TablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Table"
    objects: {
      restaurant: Prisma.$RestaurantPayload<ExtArgs>
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      number: number
      capacity: number
      location: string | null
      isActive: boolean
      restaurantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["table"]>
    composites: {}
  }

  type TableGetPayload<S extends boolean | null | undefined | TableDefaultArgs> = $Result.GetResult<Prisma.$TablePayload, S>

  type TableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: TableCountAggregateInputType | true
    }

  export interface TableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Table'], meta: { name: 'Table' } }
    /**
     * Find zero or one Table that matches the filter.
     * @param {TableFindUniqueArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TableFindUniqueArgs>(args: SelectSubset<T, TableFindUniqueArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Table that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TableFindUniqueOrThrowArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TableFindUniqueOrThrowArgs>(args: SelectSubset<T, TableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Table that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindFirstArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TableFindFirstArgs>(args?: SelectSubset<T, TableFindFirstArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Table that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindFirstOrThrowArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TableFindFirstOrThrowArgs>(args?: SelectSubset<T, TableFindFirstOrThrowArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tables
     * const tables = await prisma.table.findMany()
     * 
     * // Get first 10 Tables
     * const tables = await prisma.table.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tableWithIdOnly = await prisma.table.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TableFindManyArgs>(args?: SelectSubset<T, TableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Table.
     * @param {TableCreateArgs} args - Arguments to create a Table.
     * @example
     * // Create one Table
     * const Table = await prisma.table.create({
     *   data: {
     *     // ... data to create a Table
     *   }
     * })
     * 
     */
    create<T extends TableCreateArgs>(args: SelectSubset<T, TableCreateArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tables.
     * @param {TableCreateManyArgs} args - Arguments to create many Tables.
     * @example
     * // Create many Tables
     * const table = await prisma.table.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TableCreateManyArgs>(args?: SelectSubset<T, TableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tables and returns the data saved in the database.
     * @param {TableCreateManyAndReturnArgs} args - Arguments to create many Tables.
     * @example
     * // Create many Tables
     * const table = await prisma.table.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tables and only return the `id`
     * const tableWithIdOnly = await prisma.table.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TableCreateManyAndReturnArgs>(args?: SelectSubset<T, TableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Table.
     * @param {TableDeleteArgs} args - Arguments to delete one Table.
     * @example
     * // Delete one Table
     * const Table = await prisma.table.delete({
     *   where: {
     *     // ... filter to delete one Table
     *   }
     * })
     * 
     */
    delete<T extends TableDeleteArgs>(args: SelectSubset<T, TableDeleteArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Table.
     * @param {TableUpdateArgs} args - Arguments to update one Table.
     * @example
     * // Update one Table
     * const table = await prisma.table.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TableUpdateArgs>(args: SelectSubset<T, TableUpdateArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tables.
     * @param {TableDeleteManyArgs} args - Arguments to filter Tables to delete.
     * @example
     * // Delete a few Tables
     * const { count } = await prisma.table.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TableDeleteManyArgs>(args?: SelectSubset<T, TableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tables
     * const table = await prisma.table.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TableUpdateManyArgs>(args: SelectSubset<T, TableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tables and returns the data updated in the database.
     * @param {TableUpdateManyAndReturnArgs} args - Arguments to update many Tables.
     * @example
     * // Update many Tables
     * const table = await prisma.table.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tables and only return the `id`
     * const tableWithIdOnly = await prisma.table.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TableUpdateManyAndReturnArgs>(args: SelectSubset<T, TableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Table.
     * @param {TableUpsertArgs} args - Arguments to update or create a Table.
     * @example
     * // Update or create a Table
     * const table = await prisma.table.upsert({
     *   create: {
     *     // ... data to create a Table
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Table we want to update
     *   }
     * })
     */
    upsert<T extends TableUpsertArgs>(args: SelectSubset<T, TableUpsertArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableCountArgs} args - Arguments to filter Tables to count.
     * @example
     * // Count the number of Tables
     * const count = await prisma.table.count({
     *   where: {
     *     // ... the filter for the Tables we want to count
     *   }
     * })
    **/
    count<T extends TableCountArgs>(
      args?: Subset<T, TableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TableAggregateArgs>(args: Subset<T, TableAggregateArgs>): Prisma.PrismaPromise<GetTableAggregateType<T>>

    /**
     * Group by Table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TableGroupByArgs['orderBy'] }
        : { orderBy?: TableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Table model
   */
  readonly fields: TableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Table.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    restaurant<T extends RestaurantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantDefaultArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reservations<T extends Table$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Table$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Table model
   */
  interface TableFieldRefs {
    readonly id: FieldRef<"Table", 'String'>
    readonly number: FieldRef<"Table", 'Int'>
    readonly capacity: FieldRef<"Table", 'Int'>
    readonly location: FieldRef<"Table", 'String'>
    readonly isActive: FieldRef<"Table", 'Boolean'>
    readonly restaurantId: FieldRef<"Table", 'String'>
    readonly createdAt: FieldRef<"Table", 'DateTime'>
    readonly updatedAt: FieldRef<"Table", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Table findUnique
   */
  export type TableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where: TableWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Table findUniqueOrThrow
   */
  export type TableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where: TableWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Table findFirst
   */
  export type TableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tables.
     */
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Table findFirstOrThrow
   */
  export type TableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tables.
     */
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Table findMany
   */
  export type TableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Tables to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Table create
   */
  export type TableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The data needed to create a Table.
     */
    data: XOR<TableCreateInput, TableUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Table createMany
   */
  export type TableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tables.
     */
    data: TableCreateManyInput | TableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Table createManyAndReturn
   */
  export type TableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * The data used to create many Tables.
     */
    data: TableCreateManyInput | TableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Table update
   */
  export type TableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The data needed to update a Table.
     */
    data: XOR<TableUpdateInput, TableUncheckedUpdateInput>
    /**
     * Choose, which Table to update.
     */
    where: TableWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Table updateMany
   */
  export type TableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tables.
     */
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyInput>
    /**
     * Filter which Tables to update
     */
    where?: TableWhereInput
    /**
     * Limit how many Tables to update.
     */
    limit?: number
  }

  /**
   * Table updateManyAndReturn
   */
  export type TableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * The data used to update Tables.
     */
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyInput>
    /**
     * Filter which Tables to update
     */
    where?: TableWhereInput
    /**
     * Limit how many Tables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Table upsert
   */
  export type TableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The filter to search for the Table to update in case it exists.
     */
    where: TableWhereUniqueInput
    /**
     * In case the Table found by the `where` argument doesn't exist, create a new Table with this data.
     */
    create: XOR<TableCreateInput, TableUncheckedCreateInput>
    /**
     * In case the Table was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TableUpdateInput, TableUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Table delete
   */
  export type TableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter which Table to delete.
     */
    where: TableWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Table deleteMany
   */
  export type TableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tables to delete
     */
    where?: TableWhereInput
    /**
     * Limit how many Tables to delete.
     */
    limit?: number
  }

  /**
   * Table.reservations
   */
  export type Table$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Table without action
   */
  export type TableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reservations?: boolean | Customer$reservationsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservations?: boolean | Customer$reservationsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reservations<T extends Customer$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.reservations
   */
  export type Customer$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Reservation
   */

  export type AggregateReservation = {
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  export type ReservationAvgAggregateOutputType = {
    partySize: number | null
  }

  export type ReservationSumAggregateOutputType = {
    partySize: number | null
  }

  export type ReservationMinAggregateOutputType = {
    id: string | null
    date: Date | null
    startTime: Date | null
    endTime: Date | null
    partySize: number | null
    status: $Enums.ReservationStatus | null
    notes: string | null
    customerId: string | null
    tableId: string | null
    restaurantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReservationMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    startTime: Date | null
    endTime: Date | null
    partySize: number | null
    status: $Enums.ReservationStatus | null
    notes: string | null
    customerId: string | null
    tableId: string | null
    restaurantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReservationCountAggregateOutputType = {
    id: number
    date: number
    startTime: number
    endTime: number
    partySize: number
    status: number
    notes: number
    customerId: number
    tableId: number
    restaurantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReservationAvgAggregateInputType = {
    partySize?: true
  }

  export type ReservationSumAggregateInputType = {
    partySize?: true
  }

  export type ReservationMinAggregateInputType = {
    id?: true
    date?: true
    startTime?: true
    endTime?: true
    partySize?: true
    status?: true
    notes?: true
    customerId?: true
    tableId?: true
    restaurantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReservationMaxAggregateInputType = {
    id?: true
    date?: true
    startTime?: true
    endTime?: true
    partySize?: true
    status?: true
    notes?: true
    customerId?: true
    tableId?: true
    restaurantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReservationCountAggregateInputType = {
    id?: true
    date?: true
    startTime?: true
    endTime?: true
    partySize?: true
    status?: true
    notes?: true
    customerId?: true
    tableId?: true
    restaurantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReservationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservation to aggregate.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reservations
    **/
    _count?: true | ReservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReservationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReservationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservationMaxAggregateInputType
  }

  export type GetReservationAggregateType<T extends ReservationAggregateArgs> = {
        [P in keyof T & keyof AggregateReservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservation[P]>
      : GetScalarType<T[P], AggregateReservation[P]>
  }




  export type ReservationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithAggregationInput | ReservationOrderByWithAggregationInput[]
    by: ReservationScalarFieldEnum[] | ReservationScalarFieldEnum
    having?: ReservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservationCountAggregateInputType | true
    _avg?: ReservationAvgAggregateInputType
    _sum?: ReservationSumAggregateInputType
    _min?: ReservationMinAggregateInputType
    _max?: ReservationMaxAggregateInputType
  }

  export type ReservationGroupByOutputType = {
    id: string
    date: Date
    startTime: Date
    endTime: Date
    partySize: number
    status: $Enums.ReservationStatus
    notes: string | null
    customerId: string
    tableId: string | null
    restaurantId: string
    createdAt: Date
    updatedAt: Date
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  type GetReservationGroupByPayload<T extends ReservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservationGroupByOutputType[P]>
            : GetScalarType<T[P], ReservationGroupByOutputType[P]>
        }
      >
    >


  export type ReservationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    partySize?: boolean
    status?: boolean
    notes?: boolean
    customerId?: boolean
    tableId?: boolean
    restaurantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    table?: boolean | Reservation$tableArgs<ExtArgs>
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    partySize?: boolean
    status?: boolean
    notes?: boolean
    customerId?: boolean
    tableId?: boolean
    restaurantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    table?: boolean | Reservation$tableArgs<ExtArgs>
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    partySize?: boolean
    status?: boolean
    notes?: boolean
    customerId?: boolean
    tableId?: boolean
    restaurantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    table?: boolean | Reservation$tableArgs<ExtArgs>
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectScalar = {
    id?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    partySize?: boolean
    status?: boolean
    notes?: boolean
    customerId?: boolean
    tableId?: boolean
    restaurantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReservationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "startTime" | "endTime" | "partySize" | "status" | "notes" | "customerId" | "tableId" | "restaurantId" | "createdAt" | "updatedAt", ExtArgs["result"]["reservation"]>
  export type ReservationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    table?: boolean | Reservation$tableArgs<ExtArgs>
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }
  export type ReservationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    table?: boolean | Reservation$tableArgs<ExtArgs>
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }
  export type ReservationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    table?: boolean | Reservation$tableArgs<ExtArgs>
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }

  export type $ReservationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reservation"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      table: Prisma.$TablePayload<ExtArgs> | null
      restaurant: Prisma.$RestaurantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      startTime: Date
      endTime: Date
      partySize: number
      status: $Enums.ReservationStatus
      notes: string | null
      customerId: string
      tableId: string | null
      restaurantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reservation"]>
    composites: {}
  }

  type ReservationGetPayload<S extends boolean | null | undefined | ReservationDefaultArgs> = $Result.GetResult<Prisma.$ReservationPayload, S>

  type ReservationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReservationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ReservationCountAggregateInputType | true
    }

  export interface ReservationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reservation'], meta: { name: 'Reservation' } }
    /**
     * Find zero or one Reservation that matches the filter.
     * @param {ReservationFindUniqueArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReservationFindUniqueArgs>(args: SelectSubset<T, ReservationFindUniqueArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reservation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReservationFindUniqueOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReservationFindUniqueOrThrowArgs>(args: SelectSubset<T, ReservationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReservationFindFirstArgs>(args?: SelectSubset<T, ReservationFindFirstArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reservation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReservationFindFirstOrThrowArgs>(args?: SelectSubset<T, ReservationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservations
     * const reservations = await prisma.reservation.findMany()
     * 
     * // Get first 10 Reservations
     * const reservations = await prisma.reservation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservationWithIdOnly = await prisma.reservation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReservationFindManyArgs>(args?: SelectSubset<T, ReservationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reservation.
     * @param {ReservationCreateArgs} args - Arguments to create a Reservation.
     * @example
     * // Create one Reservation
     * const Reservation = await prisma.reservation.create({
     *   data: {
     *     // ... data to create a Reservation
     *   }
     * })
     * 
     */
    create<T extends ReservationCreateArgs>(args: SelectSubset<T, ReservationCreateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reservations.
     * @param {ReservationCreateManyArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReservationCreateManyArgs>(args?: SelectSubset<T, ReservationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reservations and returns the data saved in the database.
     * @param {ReservationCreateManyAndReturnArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reservations and only return the `id`
     * const reservationWithIdOnly = await prisma.reservation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReservationCreateManyAndReturnArgs>(args?: SelectSubset<T, ReservationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reservation.
     * @param {ReservationDeleteArgs} args - Arguments to delete one Reservation.
     * @example
     * // Delete one Reservation
     * const Reservation = await prisma.reservation.delete({
     *   where: {
     *     // ... filter to delete one Reservation
     *   }
     * })
     * 
     */
    delete<T extends ReservationDeleteArgs>(args: SelectSubset<T, ReservationDeleteArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reservation.
     * @param {ReservationUpdateArgs} args - Arguments to update one Reservation.
     * @example
     * // Update one Reservation
     * const reservation = await prisma.reservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReservationUpdateArgs>(args: SelectSubset<T, ReservationUpdateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reservations.
     * @param {ReservationDeleteManyArgs} args - Arguments to filter Reservations to delete.
     * @example
     * // Delete a few Reservations
     * const { count } = await prisma.reservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReservationDeleteManyArgs>(args?: SelectSubset<T, ReservationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReservationUpdateManyArgs>(args: SelectSubset<T, ReservationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations and returns the data updated in the database.
     * @param {ReservationUpdateManyAndReturnArgs} args - Arguments to update many Reservations.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reservations and only return the `id`
     * const reservationWithIdOnly = await prisma.reservation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReservationUpdateManyAndReturnArgs>(args: SelectSubset<T, ReservationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reservation.
     * @param {ReservationUpsertArgs} args - Arguments to update or create a Reservation.
     * @example
     * // Update or create a Reservation
     * const reservation = await prisma.reservation.upsert({
     *   create: {
     *     // ... data to create a Reservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservation we want to update
     *   }
     * })
     */
    upsert<T extends ReservationUpsertArgs>(args: SelectSubset<T, ReservationUpsertArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationCountArgs} args - Arguments to filter Reservations to count.
     * @example
     * // Count the number of Reservations
     * const count = await prisma.reservation.count({
     *   where: {
     *     // ... the filter for the Reservations we want to count
     *   }
     * })
    **/
    count<T extends ReservationCountArgs>(
      args?: Subset<T, ReservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservationAggregateArgs>(args: Subset<T, ReservationAggregateArgs>): Prisma.PrismaPromise<GetReservationAggregateType<T>>

    /**
     * Group by Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservationGroupByArgs['orderBy'] }
        : { orderBy?: ReservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reservation model
   */
  readonly fields: ReservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReservationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    table<T extends Reservation$tableArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$tableArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    restaurant<T extends RestaurantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantDefaultArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reservation model
   */
  interface ReservationFieldRefs {
    readonly id: FieldRef<"Reservation", 'String'>
    readonly date: FieldRef<"Reservation", 'DateTime'>
    readonly startTime: FieldRef<"Reservation", 'DateTime'>
    readonly endTime: FieldRef<"Reservation", 'DateTime'>
    readonly partySize: FieldRef<"Reservation", 'Int'>
    readonly status: FieldRef<"Reservation", 'ReservationStatus'>
    readonly notes: FieldRef<"Reservation", 'String'>
    readonly customerId: FieldRef<"Reservation", 'String'>
    readonly tableId: FieldRef<"Reservation", 'String'>
    readonly restaurantId: FieldRef<"Reservation", 'String'>
    readonly createdAt: FieldRef<"Reservation", 'DateTime'>
    readonly updatedAt: FieldRef<"Reservation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reservation findUnique
   */
  export type ReservationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reservation findUniqueOrThrow
   */
  export type ReservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reservation findFirst
   */
  export type ReservationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reservation findFirstOrThrow
   */
  export type ReservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reservation findMany
   */
  export type ReservationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservations to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reservation create
   */
  export type ReservationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to create a Reservation.
     */
    data: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reservation createMany
   */
  export type ReservationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reservation createManyAndReturn
   */
  export type ReservationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reservation update
   */
  export type ReservationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to update a Reservation.
     */
    data: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
    /**
     * Choose, which Reservation to update.
     */
    where: ReservationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reservation updateMany
   */
  export type ReservationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reservations.
     */
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyInput>
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to update.
     */
    limit?: number
  }

  /**
   * Reservation updateManyAndReturn
   */
  export type ReservationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * The data used to update Reservations.
     */
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyInput>
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reservation upsert
   */
  export type ReservationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The filter to search for the Reservation to update in case it exists.
     */
    where: ReservationWhereUniqueInput
    /**
     * In case the Reservation found by the `where` argument doesn't exist, create a new Reservation with this data.
     */
    create: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
    /**
     * In case the Reservation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reservation delete
   */
  export type ReservationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter which Reservation to delete.
     */
    where: ReservationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reservation deleteMany
   */
  export type ReservationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservations to delete
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to delete.
     */
    limit?: number
  }

  /**
   * Reservation.table
   */
  export type Reservation$tableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    where?: TableWhereInput
  }

  /**
   * Reservation without action
   */
  export type ReservationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    postition: number | null
  }

  export type CategorySumAggregateOutputType = {
    postition: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    name_esp: string | null
    slug: string | null
    description: string | null
    description_esp: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    restaurantId: string | null
    postition: number | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    name_esp: string | null
    slug: string | null
    description: string | null
    description_esp: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    restaurantId: string | null
    postition: number | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    name_esp: number
    slug: number
    description: number
    description_esp: number
    image: number
    createdAt: number
    updatedAt: number
    restaurantId: number
    postition: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    postition?: true
  }

  export type CategorySumAggregateInputType = {
    postition?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    name_esp?: true
    slug?: true
    description?: true
    description_esp?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    restaurantId?: true
    postition?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    name_esp?: true
    slug?: true
    description?: true
    description_esp?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    restaurantId?: true
    postition?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    name_esp?: true
    slug?: true
    description?: true
    description_esp?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    restaurantId?: true
    postition?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    name_esp: string | null
    slug: string
    description: string | null
    description_esp: string | null
    image: string | null
    createdAt: Date
    updatedAt: Date
    restaurantId: string
    postition: number
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_esp?: boolean
    slug?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    restaurantId?: boolean
    postition?: boolean
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
    dishes?: boolean | Category$dishesArgs<ExtArgs>
    subcategories?: boolean | Category$subcategoriesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_esp?: boolean
    slug?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    restaurantId?: boolean
    postition?: boolean
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_esp?: boolean
    slug?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    restaurantId?: boolean
    postition?: boolean
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    name_esp?: boolean
    slug?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    restaurantId?: boolean
    postition?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "name_esp" | "slug" | "description" | "description_esp" | "image" | "createdAt" | "updatedAt" | "restaurantId" | "postition", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
    dishes?: boolean | Category$dishesArgs<ExtArgs>
    subcategories?: boolean | Category$subcategoriesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      restaurant: Prisma.$RestaurantPayload<ExtArgs>
      dishes: Prisma.$DishPayload<ExtArgs>[]
      subcategories: Prisma.$SubcategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      name_esp: string | null
      slug: string
      description: string | null
      description_esp: string | null
      image: string | null
      createdAt: Date
      updatedAt: Date
      restaurantId: string
      postition: number
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    restaurant<T extends RestaurantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantDefaultArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dishes<T extends Category$dishesArgs<ExtArgs> = {}>(args?: Subset<T, Category$dishesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subcategories<T extends Category$subcategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Category$subcategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly name_esp: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly description_esp: FieldRef<"Category", 'String'>
    readonly image: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
    readonly restaurantId: FieldRef<"Category", 'String'>
    readonly postition: FieldRef<"Category", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.dishes
   */
  export type Category$dishesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    where?: DishWhereInput
    orderBy?: DishOrderByWithRelationInput | DishOrderByWithRelationInput[]
    cursor?: DishWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DishScalarFieldEnum | DishScalarFieldEnum[]
  }

  /**
   * Category.subcategories
   */
  export type Category$subcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    where?: SubcategoryWhereInput
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    cursor?: SubcategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubcategoryScalarFieldEnum | SubcategoryScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Subcategory
   */

  export type AggregateSubcategory = {
    _count: SubcategoryCountAggregateOutputType | null
    _avg: SubcategoryAvgAggregateOutputType | null
    _sum: SubcategorySumAggregateOutputType | null
    _min: SubcategoryMinAggregateOutputType | null
    _max: SubcategoryMaxAggregateOutputType | null
  }

  export type SubcategoryAvgAggregateOutputType = {
    postition: number | null
  }

  export type SubcategorySumAggregateOutputType = {
    postition: number | null
  }

  export type SubcategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    name_esp: string | null
    slug: string | null
    description: string | null
    description_esp: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    parentCategoryId: string | null
    postition: number | null
  }

  export type SubcategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    name_esp: string | null
    slug: string | null
    description: string | null
    description_esp: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    parentCategoryId: string | null
    postition: number | null
  }

  export type SubcategoryCountAggregateOutputType = {
    id: number
    name: number
    name_esp: number
    slug: number
    description: number
    description_esp: number
    image: number
    createdAt: number
    updatedAt: number
    parentCategoryId: number
    postition: number
    _all: number
  }


  export type SubcategoryAvgAggregateInputType = {
    postition?: true
  }

  export type SubcategorySumAggregateInputType = {
    postition?: true
  }

  export type SubcategoryMinAggregateInputType = {
    id?: true
    name?: true
    name_esp?: true
    slug?: true
    description?: true
    description_esp?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    parentCategoryId?: true
    postition?: true
  }

  export type SubcategoryMaxAggregateInputType = {
    id?: true
    name?: true
    name_esp?: true
    slug?: true
    description?: true
    description_esp?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    parentCategoryId?: true
    postition?: true
  }

  export type SubcategoryCountAggregateInputType = {
    id?: true
    name?: true
    name_esp?: true
    slug?: true
    description?: true
    description_esp?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    parentCategoryId?: true
    postition?: true
    _all?: true
  }

  export type SubcategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subcategory to aggregate.
     */
    where?: SubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subcategories to fetch.
     */
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subcategories
    **/
    _count?: true | SubcategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubcategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubcategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubcategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubcategoryMaxAggregateInputType
  }

  export type GetSubcategoryAggregateType<T extends SubcategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSubcategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubcategory[P]>
      : GetScalarType<T[P], AggregateSubcategory[P]>
  }




  export type SubcategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubcategoryWhereInput
    orderBy?: SubcategoryOrderByWithAggregationInput | SubcategoryOrderByWithAggregationInput[]
    by: SubcategoryScalarFieldEnum[] | SubcategoryScalarFieldEnum
    having?: SubcategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubcategoryCountAggregateInputType | true
    _avg?: SubcategoryAvgAggregateInputType
    _sum?: SubcategorySumAggregateInputType
    _min?: SubcategoryMinAggregateInputType
    _max?: SubcategoryMaxAggregateInputType
  }

  export type SubcategoryGroupByOutputType = {
    id: string
    name: string
    name_esp: string | null
    slug: string
    description: string | null
    description_esp: string | null
    image: string | null
    createdAt: Date
    updatedAt: Date
    parentCategoryId: string
    postition: number
    _count: SubcategoryCountAggregateOutputType | null
    _avg: SubcategoryAvgAggregateOutputType | null
    _sum: SubcategorySumAggregateOutputType | null
    _min: SubcategoryMinAggregateOutputType | null
    _max: SubcategoryMaxAggregateOutputType | null
  }

  type GetSubcategoryGroupByPayload<T extends SubcategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubcategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubcategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubcategoryGroupByOutputType[P]>
            : GetScalarType<T[P], SubcategoryGroupByOutputType[P]>
        }
      >
    >


  export type SubcategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_esp?: boolean
    slug?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentCategoryId?: boolean
    postition?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    dishes?: boolean | Subcategory$dishesArgs<ExtArgs>
    subSubcategories?: boolean | Subcategory$subSubcategoriesArgs<ExtArgs>
    _count?: boolean | SubcategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subcategory"]>

  export type SubcategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_esp?: boolean
    slug?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentCategoryId?: boolean
    postition?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subcategory"]>

  export type SubcategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_esp?: boolean
    slug?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentCategoryId?: boolean
    postition?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subcategory"]>

  export type SubcategorySelectScalar = {
    id?: boolean
    name?: boolean
    name_esp?: boolean
    slug?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentCategoryId?: boolean
    postition?: boolean
  }

  export type SubcategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "name_esp" | "slug" | "description" | "description_esp" | "image" | "createdAt" | "updatedAt" | "parentCategoryId" | "postition", ExtArgs["result"]["subcategory"]>
  export type SubcategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    dishes?: boolean | Subcategory$dishesArgs<ExtArgs>
    subSubcategories?: boolean | Subcategory$subSubcategoriesArgs<ExtArgs>
    _count?: boolean | SubcategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubcategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type SubcategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $SubcategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subcategory"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      dishes: Prisma.$DishPayload<ExtArgs>[]
      subSubcategories: Prisma.$SubSubcategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      name_esp: string | null
      slug: string
      description: string | null
      description_esp: string | null
      image: string | null
      createdAt: Date
      updatedAt: Date
      parentCategoryId: string
      postition: number
    }, ExtArgs["result"]["subcategory"]>
    composites: {}
  }

  type SubcategoryGetPayload<S extends boolean | null | undefined | SubcategoryDefaultArgs> = $Result.GetResult<Prisma.$SubcategoryPayload, S>

  type SubcategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubcategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: SubcategoryCountAggregateInputType | true
    }

  export interface SubcategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subcategory'], meta: { name: 'Subcategory' } }
    /**
     * Find zero or one Subcategory that matches the filter.
     * @param {SubcategoryFindUniqueArgs} args - Arguments to find a Subcategory
     * @example
     * // Get one Subcategory
     * const subcategory = await prisma.subcategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubcategoryFindUniqueArgs>(args: SelectSubset<T, SubcategoryFindUniqueArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subcategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubcategoryFindUniqueOrThrowArgs} args - Arguments to find a Subcategory
     * @example
     * // Get one Subcategory
     * const subcategory = await prisma.subcategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubcategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SubcategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subcategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryFindFirstArgs} args - Arguments to find a Subcategory
     * @example
     * // Get one Subcategory
     * const subcategory = await prisma.subcategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubcategoryFindFirstArgs>(args?: SelectSubset<T, SubcategoryFindFirstArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subcategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryFindFirstOrThrowArgs} args - Arguments to find a Subcategory
     * @example
     * // Get one Subcategory
     * const subcategory = await prisma.subcategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubcategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SubcategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subcategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subcategories
     * const subcategories = await prisma.subcategory.findMany()
     * 
     * // Get first 10 Subcategories
     * const subcategories = await prisma.subcategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subcategoryWithIdOnly = await prisma.subcategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubcategoryFindManyArgs>(args?: SelectSubset<T, SubcategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subcategory.
     * @param {SubcategoryCreateArgs} args - Arguments to create a Subcategory.
     * @example
     * // Create one Subcategory
     * const Subcategory = await prisma.subcategory.create({
     *   data: {
     *     // ... data to create a Subcategory
     *   }
     * })
     * 
     */
    create<T extends SubcategoryCreateArgs>(args: SelectSubset<T, SubcategoryCreateArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subcategories.
     * @param {SubcategoryCreateManyArgs} args - Arguments to create many Subcategories.
     * @example
     * // Create many Subcategories
     * const subcategory = await prisma.subcategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubcategoryCreateManyArgs>(args?: SelectSubset<T, SubcategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subcategories and returns the data saved in the database.
     * @param {SubcategoryCreateManyAndReturnArgs} args - Arguments to create many Subcategories.
     * @example
     * // Create many Subcategories
     * const subcategory = await prisma.subcategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subcategories and only return the `id`
     * const subcategoryWithIdOnly = await prisma.subcategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubcategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SubcategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subcategory.
     * @param {SubcategoryDeleteArgs} args - Arguments to delete one Subcategory.
     * @example
     * // Delete one Subcategory
     * const Subcategory = await prisma.subcategory.delete({
     *   where: {
     *     // ... filter to delete one Subcategory
     *   }
     * })
     * 
     */
    delete<T extends SubcategoryDeleteArgs>(args: SelectSubset<T, SubcategoryDeleteArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subcategory.
     * @param {SubcategoryUpdateArgs} args - Arguments to update one Subcategory.
     * @example
     * // Update one Subcategory
     * const subcategory = await prisma.subcategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubcategoryUpdateArgs>(args: SelectSubset<T, SubcategoryUpdateArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subcategories.
     * @param {SubcategoryDeleteManyArgs} args - Arguments to filter Subcategories to delete.
     * @example
     * // Delete a few Subcategories
     * const { count } = await prisma.subcategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubcategoryDeleteManyArgs>(args?: SelectSubset<T, SubcategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subcategories
     * const subcategory = await prisma.subcategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubcategoryUpdateManyArgs>(args: SelectSubset<T, SubcategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subcategories and returns the data updated in the database.
     * @param {SubcategoryUpdateManyAndReturnArgs} args - Arguments to update many Subcategories.
     * @example
     * // Update many Subcategories
     * const subcategory = await prisma.subcategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subcategories and only return the `id`
     * const subcategoryWithIdOnly = await prisma.subcategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubcategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, SubcategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subcategory.
     * @param {SubcategoryUpsertArgs} args - Arguments to update or create a Subcategory.
     * @example
     * // Update or create a Subcategory
     * const subcategory = await prisma.subcategory.upsert({
     *   create: {
     *     // ... data to create a Subcategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subcategory we want to update
     *   }
     * })
     */
    upsert<T extends SubcategoryUpsertArgs>(args: SelectSubset<T, SubcategoryUpsertArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryCountArgs} args - Arguments to filter Subcategories to count.
     * @example
     * // Count the number of Subcategories
     * const count = await prisma.subcategory.count({
     *   where: {
     *     // ... the filter for the Subcategories we want to count
     *   }
     * })
    **/
    count<T extends SubcategoryCountArgs>(
      args?: Subset<T, SubcategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubcategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubcategoryAggregateArgs>(args: Subset<T, SubcategoryAggregateArgs>): Prisma.PrismaPromise<GetSubcategoryAggregateType<T>>

    /**
     * Group by Subcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubcategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubcategoryGroupByArgs['orderBy'] }
        : { orderBy?: SubcategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubcategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubcategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subcategory model
   */
  readonly fields: SubcategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subcategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubcategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dishes<T extends Subcategory$dishesArgs<ExtArgs> = {}>(args?: Subset<T, Subcategory$dishesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subSubcategories<T extends Subcategory$subSubcategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Subcategory$subSubcategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubSubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subcategory model
   */
  interface SubcategoryFieldRefs {
    readonly id: FieldRef<"Subcategory", 'String'>
    readonly name: FieldRef<"Subcategory", 'String'>
    readonly name_esp: FieldRef<"Subcategory", 'String'>
    readonly slug: FieldRef<"Subcategory", 'String'>
    readonly description: FieldRef<"Subcategory", 'String'>
    readonly description_esp: FieldRef<"Subcategory", 'String'>
    readonly image: FieldRef<"Subcategory", 'String'>
    readonly createdAt: FieldRef<"Subcategory", 'DateTime'>
    readonly updatedAt: FieldRef<"Subcategory", 'DateTime'>
    readonly parentCategoryId: FieldRef<"Subcategory", 'String'>
    readonly postition: FieldRef<"Subcategory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Subcategory findUnique
   */
  export type SubcategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategory to fetch.
     */
    where: SubcategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subcategory findUniqueOrThrow
   */
  export type SubcategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategory to fetch.
     */
    where: SubcategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subcategory findFirst
   */
  export type SubcategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategory to fetch.
     */
    where?: SubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subcategories to fetch.
     */
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subcategories.
     */
    cursor?: SubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subcategories.
     */
    distinct?: SubcategoryScalarFieldEnum | SubcategoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subcategory findFirstOrThrow
   */
  export type SubcategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategory to fetch.
     */
    where?: SubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subcategories to fetch.
     */
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subcategories.
     */
    cursor?: SubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subcategories.
     */
    distinct?: SubcategoryScalarFieldEnum | SubcategoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subcategory findMany
   */
  export type SubcategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategories to fetch.
     */
    where?: SubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subcategories to fetch.
     */
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subcategories.
     */
    cursor?: SubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subcategories.
     */
    skip?: number
    distinct?: SubcategoryScalarFieldEnum | SubcategoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subcategory create
   */
  export type SubcategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Subcategory.
     */
    data: XOR<SubcategoryCreateInput, SubcategoryUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subcategory createMany
   */
  export type SubcategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subcategories.
     */
    data: SubcategoryCreateManyInput | SubcategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subcategory createManyAndReturn
   */
  export type SubcategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Subcategories.
     */
    data: SubcategoryCreateManyInput | SubcategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subcategory update
   */
  export type SubcategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Subcategory.
     */
    data: XOR<SubcategoryUpdateInput, SubcategoryUncheckedUpdateInput>
    /**
     * Choose, which Subcategory to update.
     */
    where: SubcategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subcategory updateMany
   */
  export type SubcategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subcategories.
     */
    data: XOR<SubcategoryUpdateManyMutationInput, SubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which Subcategories to update
     */
    where?: SubcategoryWhereInput
    /**
     * Limit how many Subcategories to update.
     */
    limit?: number
  }

  /**
   * Subcategory updateManyAndReturn
   */
  export type SubcategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * The data used to update Subcategories.
     */
    data: XOR<SubcategoryUpdateManyMutationInput, SubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which Subcategories to update
     */
    where?: SubcategoryWhereInput
    /**
     * Limit how many Subcategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subcategory upsert
   */
  export type SubcategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Subcategory to update in case it exists.
     */
    where: SubcategoryWhereUniqueInput
    /**
     * In case the Subcategory found by the `where` argument doesn't exist, create a new Subcategory with this data.
     */
    create: XOR<SubcategoryCreateInput, SubcategoryUncheckedCreateInput>
    /**
     * In case the Subcategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubcategoryUpdateInput, SubcategoryUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subcategory delete
   */
  export type SubcategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter which Subcategory to delete.
     */
    where: SubcategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subcategory deleteMany
   */
  export type SubcategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subcategories to delete
     */
    where?: SubcategoryWhereInput
    /**
     * Limit how many Subcategories to delete.
     */
    limit?: number
  }

  /**
   * Subcategory.dishes
   */
  export type Subcategory$dishesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    where?: DishWhereInput
    orderBy?: DishOrderByWithRelationInput | DishOrderByWithRelationInput[]
    cursor?: DishWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DishScalarFieldEnum | DishScalarFieldEnum[]
  }

  /**
   * Subcategory.subSubcategories
   */
  export type Subcategory$subSubcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubSubcategory
     */
    select?: SubSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubSubcategory
     */
    omit?: SubSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubSubcategoryInclude<ExtArgs> | null
    where?: SubSubcategoryWhereInput
    orderBy?: SubSubcategoryOrderByWithRelationInput | SubSubcategoryOrderByWithRelationInput[]
    cursor?: SubSubcategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubSubcategoryScalarFieldEnum | SubSubcategoryScalarFieldEnum[]
  }

  /**
   * Subcategory without action
   */
  export type SubcategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
  }


  /**
   * Model SubSubcategory
   */

  export type AggregateSubSubcategory = {
    _count: SubSubcategoryCountAggregateOutputType | null
    _avg: SubSubcategoryAvgAggregateOutputType | null
    _sum: SubSubcategorySumAggregateOutputType | null
    _min: SubSubcategoryMinAggregateOutputType | null
    _max: SubSubcategoryMaxAggregateOutputType | null
  }

  export type SubSubcategoryAvgAggregateOutputType = {
    postition: number | null
  }

  export type SubSubcategorySumAggregateOutputType = {
    postition: number | null
  }

  export type SubSubcategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    name_esp: string | null
    slug: string | null
    description: string | null
    description_esp: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    parentSubcategoryId: string | null
    postition: number | null
  }

  export type SubSubcategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    name_esp: string | null
    slug: string | null
    description: string | null
    description_esp: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    parentSubcategoryId: string | null
    postition: number | null
  }

  export type SubSubcategoryCountAggregateOutputType = {
    id: number
    name: number
    name_esp: number
    slug: number
    description: number
    description_esp: number
    image: number
    createdAt: number
    updatedAt: number
    parentSubcategoryId: number
    postition: number
    _all: number
  }


  export type SubSubcategoryAvgAggregateInputType = {
    postition?: true
  }

  export type SubSubcategorySumAggregateInputType = {
    postition?: true
  }

  export type SubSubcategoryMinAggregateInputType = {
    id?: true
    name?: true
    name_esp?: true
    slug?: true
    description?: true
    description_esp?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    parentSubcategoryId?: true
    postition?: true
  }

  export type SubSubcategoryMaxAggregateInputType = {
    id?: true
    name?: true
    name_esp?: true
    slug?: true
    description?: true
    description_esp?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    parentSubcategoryId?: true
    postition?: true
  }

  export type SubSubcategoryCountAggregateInputType = {
    id?: true
    name?: true
    name_esp?: true
    slug?: true
    description?: true
    description_esp?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    parentSubcategoryId?: true
    postition?: true
    _all?: true
  }

  export type SubSubcategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubSubcategory to aggregate.
     */
    where?: SubSubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubSubcategories to fetch.
     */
    orderBy?: SubSubcategoryOrderByWithRelationInput | SubSubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubSubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubSubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubSubcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubSubcategories
    **/
    _count?: true | SubSubcategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubSubcategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubSubcategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubSubcategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubSubcategoryMaxAggregateInputType
  }

  export type GetSubSubcategoryAggregateType<T extends SubSubcategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSubSubcategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubSubcategory[P]>
      : GetScalarType<T[P], AggregateSubSubcategory[P]>
  }




  export type SubSubcategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubSubcategoryWhereInput
    orderBy?: SubSubcategoryOrderByWithAggregationInput | SubSubcategoryOrderByWithAggregationInput[]
    by: SubSubcategoryScalarFieldEnum[] | SubSubcategoryScalarFieldEnum
    having?: SubSubcategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubSubcategoryCountAggregateInputType | true
    _avg?: SubSubcategoryAvgAggregateInputType
    _sum?: SubSubcategorySumAggregateInputType
    _min?: SubSubcategoryMinAggregateInputType
    _max?: SubSubcategoryMaxAggregateInputType
  }

  export type SubSubcategoryGroupByOutputType = {
    id: string
    name: string
    name_esp: string | null
    slug: string
    description: string | null
    description_esp: string | null
    image: string | null
    createdAt: Date
    updatedAt: Date
    parentSubcategoryId: string
    postition: number
    _count: SubSubcategoryCountAggregateOutputType | null
    _avg: SubSubcategoryAvgAggregateOutputType | null
    _sum: SubSubcategorySumAggregateOutputType | null
    _min: SubSubcategoryMinAggregateOutputType | null
    _max: SubSubcategoryMaxAggregateOutputType | null
  }

  type GetSubSubcategoryGroupByPayload<T extends SubSubcategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubSubcategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubSubcategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubSubcategoryGroupByOutputType[P]>
            : GetScalarType<T[P], SubSubcategoryGroupByOutputType[P]>
        }
      >
    >


  export type SubSubcategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_esp?: boolean
    slug?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentSubcategoryId?: boolean
    postition?: boolean
    subcategory?: boolean | SubcategoryDefaultArgs<ExtArgs>
    dishes?: boolean | SubSubcategory$dishesArgs<ExtArgs>
    _count?: boolean | SubSubcategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subSubcategory"]>

  export type SubSubcategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_esp?: boolean
    slug?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentSubcategoryId?: boolean
    postition?: boolean
    subcategory?: boolean | SubcategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subSubcategory"]>

  export type SubSubcategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_esp?: boolean
    slug?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentSubcategoryId?: boolean
    postition?: boolean
    subcategory?: boolean | SubcategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subSubcategory"]>

  export type SubSubcategorySelectScalar = {
    id?: boolean
    name?: boolean
    name_esp?: boolean
    slug?: boolean
    description?: boolean
    description_esp?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentSubcategoryId?: boolean
    postition?: boolean
  }

  export type SubSubcategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "name_esp" | "slug" | "description" | "description_esp" | "image" | "createdAt" | "updatedAt" | "parentSubcategoryId" | "postition", ExtArgs["result"]["subSubcategory"]>
  export type SubSubcategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subcategory?: boolean | SubcategoryDefaultArgs<ExtArgs>
    dishes?: boolean | SubSubcategory$dishesArgs<ExtArgs>
    _count?: boolean | SubSubcategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubSubcategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subcategory?: boolean | SubcategoryDefaultArgs<ExtArgs>
  }
  export type SubSubcategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subcategory?: boolean | SubcategoryDefaultArgs<ExtArgs>
  }

  export type $SubSubcategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubSubcategory"
    objects: {
      subcategory: Prisma.$SubcategoryPayload<ExtArgs>
      dishes: Prisma.$DishPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      name_esp: string | null
      slug: string
      description: string | null
      description_esp: string | null
      image: string | null
      createdAt: Date
      updatedAt: Date
      parentSubcategoryId: string
      postition: number
    }, ExtArgs["result"]["subSubcategory"]>
    composites: {}
  }

  type SubSubcategoryGetPayload<S extends boolean | null | undefined | SubSubcategoryDefaultArgs> = $Result.GetResult<Prisma.$SubSubcategoryPayload, S>

  type SubSubcategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubSubcategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: SubSubcategoryCountAggregateInputType | true
    }

  export interface SubSubcategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubSubcategory'], meta: { name: 'SubSubcategory' } }
    /**
     * Find zero or one SubSubcategory that matches the filter.
     * @param {SubSubcategoryFindUniqueArgs} args - Arguments to find a SubSubcategory
     * @example
     * // Get one SubSubcategory
     * const subSubcategory = await prisma.subSubcategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubSubcategoryFindUniqueArgs>(args: SelectSubset<T, SubSubcategoryFindUniqueArgs<ExtArgs>>): Prisma__SubSubcategoryClient<$Result.GetResult<Prisma.$SubSubcategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubSubcategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubSubcategoryFindUniqueOrThrowArgs} args - Arguments to find a SubSubcategory
     * @example
     * // Get one SubSubcategory
     * const subSubcategory = await prisma.subSubcategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubSubcategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SubSubcategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubSubcategoryClient<$Result.GetResult<Prisma.$SubSubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubSubcategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubSubcategoryFindFirstArgs} args - Arguments to find a SubSubcategory
     * @example
     * // Get one SubSubcategory
     * const subSubcategory = await prisma.subSubcategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubSubcategoryFindFirstArgs>(args?: SelectSubset<T, SubSubcategoryFindFirstArgs<ExtArgs>>): Prisma__SubSubcategoryClient<$Result.GetResult<Prisma.$SubSubcategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubSubcategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubSubcategoryFindFirstOrThrowArgs} args - Arguments to find a SubSubcategory
     * @example
     * // Get one SubSubcategory
     * const subSubcategory = await prisma.subSubcategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubSubcategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SubSubcategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubSubcategoryClient<$Result.GetResult<Prisma.$SubSubcategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubSubcategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubSubcategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubSubcategories
     * const subSubcategories = await prisma.subSubcategory.findMany()
     * 
     * // Get first 10 SubSubcategories
     * const subSubcategories = await prisma.subSubcategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subSubcategoryWithIdOnly = await prisma.subSubcategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubSubcategoryFindManyArgs>(args?: SelectSubset<T, SubSubcategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubSubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubSubcategory.
     * @param {SubSubcategoryCreateArgs} args - Arguments to create a SubSubcategory.
     * @example
     * // Create one SubSubcategory
     * const SubSubcategory = await prisma.subSubcategory.create({
     *   data: {
     *     // ... data to create a SubSubcategory
     *   }
     * })
     * 
     */
    create<T extends SubSubcategoryCreateArgs>(args: SelectSubset<T, SubSubcategoryCreateArgs<ExtArgs>>): Prisma__SubSubcategoryClient<$Result.GetResult<Prisma.$SubSubcategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubSubcategories.
     * @param {SubSubcategoryCreateManyArgs} args - Arguments to create many SubSubcategories.
     * @example
     * // Create many SubSubcategories
     * const subSubcategory = await prisma.subSubcategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubSubcategoryCreateManyArgs>(args?: SelectSubset<T, SubSubcategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubSubcategories and returns the data saved in the database.
     * @param {SubSubcategoryCreateManyAndReturnArgs} args - Arguments to create many SubSubcategories.
     * @example
     * // Create many SubSubcategories
     * const subSubcategory = await prisma.subSubcategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubSubcategories and only return the `id`
     * const subSubcategoryWithIdOnly = await prisma.subSubcategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubSubcategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SubSubcategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubSubcategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubSubcategory.
     * @param {SubSubcategoryDeleteArgs} args - Arguments to delete one SubSubcategory.
     * @example
     * // Delete one SubSubcategory
     * const SubSubcategory = await prisma.subSubcategory.delete({
     *   where: {
     *     // ... filter to delete one SubSubcategory
     *   }
     * })
     * 
     */
    delete<T extends SubSubcategoryDeleteArgs>(args: SelectSubset<T, SubSubcategoryDeleteArgs<ExtArgs>>): Prisma__SubSubcategoryClient<$Result.GetResult<Prisma.$SubSubcategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubSubcategory.
     * @param {SubSubcategoryUpdateArgs} args - Arguments to update one SubSubcategory.
     * @example
     * // Update one SubSubcategory
     * const subSubcategory = await prisma.subSubcategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubSubcategoryUpdateArgs>(args: SelectSubset<T, SubSubcategoryUpdateArgs<ExtArgs>>): Prisma__SubSubcategoryClient<$Result.GetResult<Prisma.$SubSubcategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubSubcategories.
     * @param {SubSubcategoryDeleteManyArgs} args - Arguments to filter SubSubcategories to delete.
     * @example
     * // Delete a few SubSubcategories
     * const { count } = await prisma.subSubcategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubSubcategoryDeleteManyArgs>(args?: SelectSubset<T, SubSubcategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubSubcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubSubcategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubSubcategories
     * const subSubcategory = await prisma.subSubcategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubSubcategoryUpdateManyArgs>(args: SelectSubset<T, SubSubcategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubSubcategories and returns the data updated in the database.
     * @param {SubSubcategoryUpdateManyAndReturnArgs} args - Arguments to update many SubSubcategories.
     * @example
     * // Update many SubSubcategories
     * const subSubcategory = await prisma.subSubcategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubSubcategories and only return the `id`
     * const subSubcategoryWithIdOnly = await prisma.subSubcategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubSubcategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, SubSubcategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubSubcategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubSubcategory.
     * @param {SubSubcategoryUpsertArgs} args - Arguments to update or create a SubSubcategory.
     * @example
     * // Update or create a SubSubcategory
     * const subSubcategory = await prisma.subSubcategory.upsert({
     *   create: {
     *     // ... data to create a SubSubcategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubSubcategory we want to update
     *   }
     * })
     */
    upsert<T extends SubSubcategoryUpsertArgs>(args: SelectSubset<T, SubSubcategoryUpsertArgs<ExtArgs>>): Prisma__SubSubcategoryClient<$Result.GetResult<Prisma.$SubSubcategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubSubcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubSubcategoryCountArgs} args - Arguments to filter SubSubcategories to count.
     * @example
     * // Count the number of SubSubcategories
     * const count = await prisma.subSubcategory.count({
     *   where: {
     *     // ... the filter for the SubSubcategories we want to count
     *   }
     * })
    **/
    count<T extends SubSubcategoryCountArgs>(
      args?: Subset<T, SubSubcategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubSubcategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubSubcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubSubcategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubSubcategoryAggregateArgs>(args: Subset<T, SubSubcategoryAggregateArgs>): Prisma.PrismaPromise<GetSubSubcategoryAggregateType<T>>

    /**
     * Group by SubSubcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubSubcategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubSubcategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubSubcategoryGroupByArgs['orderBy'] }
        : { orderBy?: SubSubcategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubSubcategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubSubcategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubSubcategory model
   */
  readonly fields: SubSubcategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubSubcategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubSubcategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subcategory<T extends SubcategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubcategoryDefaultArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dishes<T extends SubSubcategory$dishesArgs<ExtArgs> = {}>(args?: Subset<T, SubSubcategory$dishesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubSubcategory model
   */
  interface SubSubcategoryFieldRefs {
    readonly id: FieldRef<"SubSubcategory", 'String'>
    readonly name: FieldRef<"SubSubcategory", 'String'>
    readonly name_esp: FieldRef<"SubSubcategory", 'String'>
    readonly slug: FieldRef<"SubSubcategory", 'String'>
    readonly description: FieldRef<"SubSubcategory", 'String'>
    readonly description_esp: FieldRef<"SubSubcategory", 'String'>
    readonly image: FieldRef<"SubSubcategory", 'String'>
    readonly createdAt: FieldRef<"SubSubcategory", 'DateTime'>
    readonly updatedAt: FieldRef<"SubSubcategory", 'DateTime'>
    readonly parentSubcategoryId: FieldRef<"SubSubcategory", 'String'>
    readonly postition: FieldRef<"SubSubcategory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SubSubcategory findUnique
   */
  export type SubSubcategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubSubcategory
     */
    select?: SubSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubSubcategory
     */
    omit?: SubSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubSubcategory to fetch.
     */
    where: SubSubcategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SubSubcategory findUniqueOrThrow
   */
  export type SubSubcategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubSubcategory
     */
    select?: SubSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubSubcategory
     */
    omit?: SubSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubSubcategory to fetch.
     */
    where: SubSubcategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SubSubcategory findFirst
   */
  export type SubSubcategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubSubcategory
     */
    select?: SubSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubSubcategory
     */
    omit?: SubSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubSubcategory to fetch.
     */
    where?: SubSubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubSubcategories to fetch.
     */
    orderBy?: SubSubcategoryOrderByWithRelationInput | SubSubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubSubcategories.
     */
    cursor?: SubSubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubSubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubSubcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubSubcategories.
     */
    distinct?: SubSubcategoryScalarFieldEnum | SubSubcategoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SubSubcategory findFirstOrThrow
   */
  export type SubSubcategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubSubcategory
     */
    select?: SubSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubSubcategory
     */
    omit?: SubSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubSubcategory to fetch.
     */
    where?: SubSubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubSubcategories to fetch.
     */
    orderBy?: SubSubcategoryOrderByWithRelationInput | SubSubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubSubcategories.
     */
    cursor?: SubSubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubSubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubSubcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubSubcategories.
     */
    distinct?: SubSubcategoryScalarFieldEnum | SubSubcategoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SubSubcategory findMany
   */
  export type SubSubcategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubSubcategory
     */
    select?: SubSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubSubcategory
     */
    omit?: SubSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubSubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubSubcategories to fetch.
     */
    where?: SubSubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubSubcategories to fetch.
     */
    orderBy?: SubSubcategoryOrderByWithRelationInput | SubSubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubSubcategories.
     */
    cursor?: SubSubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubSubcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubSubcategories.
     */
    skip?: number
    distinct?: SubSubcategoryScalarFieldEnum | SubSubcategoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SubSubcategory create
   */
  export type SubSubcategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubSubcategory
     */
    select?: SubSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubSubcategory
     */
    omit?: SubSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubSubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SubSubcategory.
     */
    data: XOR<SubSubcategoryCreateInput, SubSubcategoryUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SubSubcategory createMany
   */
  export type SubSubcategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubSubcategories.
     */
    data: SubSubcategoryCreateManyInput | SubSubcategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubSubcategory createManyAndReturn
   */
  export type SubSubcategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubSubcategory
     */
    select?: SubSubcategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubSubcategory
     */
    omit?: SubSubcategoryOmit<ExtArgs> | null
    /**
     * The data used to create many SubSubcategories.
     */
    data: SubSubcategoryCreateManyInput | SubSubcategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubSubcategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubSubcategory update
   */
  export type SubSubcategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubSubcategory
     */
    select?: SubSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubSubcategory
     */
    omit?: SubSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubSubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SubSubcategory.
     */
    data: XOR<SubSubcategoryUpdateInput, SubSubcategoryUncheckedUpdateInput>
    /**
     * Choose, which SubSubcategory to update.
     */
    where: SubSubcategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SubSubcategory updateMany
   */
  export type SubSubcategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubSubcategories.
     */
    data: XOR<SubSubcategoryUpdateManyMutationInput, SubSubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which SubSubcategories to update
     */
    where?: SubSubcategoryWhereInput
    /**
     * Limit how many SubSubcategories to update.
     */
    limit?: number
  }

  /**
   * SubSubcategory updateManyAndReturn
   */
  export type SubSubcategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubSubcategory
     */
    select?: SubSubcategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubSubcategory
     */
    omit?: SubSubcategoryOmit<ExtArgs> | null
    /**
     * The data used to update SubSubcategories.
     */
    data: XOR<SubSubcategoryUpdateManyMutationInput, SubSubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which SubSubcategories to update
     */
    where?: SubSubcategoryWhereInput
    /**
     * Limit how many SubSubcategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubSubcategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubSubcategory upsert
   */
  export type SubSubcategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubSubcategory
     */
    select?: SubSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubSubcategory
     */
    omit?: SubSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubSubcategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SubSubcategory to update in case it exists.
     */
    where: SubSubcategoryWhereUniqueInput
    /**
     * In case the SubSubcategory found by the `where` argument doesn't exist, create a new SubSubcategory with this data.
     */
    create: XOR<SubSubcategoryCreateInput, SubSubcategoryUncheckedCreateInput>
    /**
     * In case the SubSubcategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubSubcategoryUpdateInput, SubSubcategoryUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SubSubcategory delete
   */
  export type SubSubcategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubSubcategory
     */
    select?: SubSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubSubcategory
     */
    omit?: SubSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubSubcategoryInclude<ExtArgs> | null
    /**
     * Filter which SubSubcategory to delete.
     */
    where: SubSubcategoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SubSubcategory deleteMany
   */
  export type SubSubcategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubSubcategories to delete
     */
    where?: SubSubcategoryWhereInput
    /**
     * Limit how many SubSubcategories to delete.
     */
    limit?: number
  }

  /**
   * SubSubcategory.dishes
   */
  export type SubSubcategory$dishesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    where?: DishWhereInput
    orderBy?: DishOrderByWithRelationInput | DishOrderByWithRelationInput[]
    cursor?: DishWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DishScalarFieldEnum | DishScalarFieldEnum[]
  }

  /**
   * SubSubcategory without action
   */
  export type SubSubcategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubSubcategory
     */
    select?: SubSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubSubcategory
     */
    omit?: SubSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubSubcategoryInclude<ExtArgs> | null
  }


  /**
   * Model Dish
   */

  export type AggregateDish = {
    _count: DishCountAggregateOutputType | null
    _avg: DishAvgAggregateOutputType | null
    _sum: DishSumAggregateOutputType | null
    _min: DishMinAggregateOutputType | null
    _max: DishMaxAggregateOutputType | null
  }

  export type DishAvgAggregateOutputType = {
    sku: number | null
    price: number | null
    availableAtDayOfWeek: number | null
    prepTime: number | null
    course_number: number | null
  }

  export type DishSumAggregateOutputType = {
    sku: number | null
    price: number | null
    availableAtDayOfWeek: number | null
    prepTime: number | null
    course_number: number | null
  }

  export type DishMinAggregateOutputType = {
    id: string | null
    sku: number | null
    name: string | null
    name_esp: string | null
    description: string | null
    description_esp: string | null
    price: number | null
    unit: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    restaurantId: string | null
    categoryId: string | null
    subcategoryId: string | null
    subSubcategoryId: string | null
    availableAtDayOfWeek: number | null
    prepTime: number | null
    isPopular: boolean | null
    isNew: boolean | null
    menuId: string | null
    course_number: number | null
  }

  export type DishMaxAggregateOutputType = {
    id: string | null
    sku: number | null
    name: string | null
    name_esp: string | null
    description: string | null
    description_esp: string | null
    price: number | null
    unit: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    restaurantId: string | null
    categoryId: string | null
    subcategoryId: string | null
    subSubcategoryId: string | null
    availableAtDayOfWeek: number | null
    prepTime: number | null
    isPopular: boolean | null
    isNew: boolean | null
    menuId: string | null
    course_number: number | null
  }

  export type DishCountAggregateOutputType = {
    id: number
    sku: number
    name: number
    name_esp: number
    description: number
    description_esp: number
    price: number
    unit: number
    image: number
    createdAt: number
    updatedAt: number
    restaurantId: number
    categoryId: number
    subcategoryId: number
    subSubcategoryId: number
    availableAtDayOfWeek: number
    dietaryInfo: number
    allergens: number
    ingredients: number
    prepTime: number
    isPopular: number
    isNew: number
    menuId: number
    course_number: number
    _all: number
  }


  export type DishAvgAggregateInputType = {
    sku?: true
    price?: true
    availableAtDayOfWeek?: true
    prepTime?: true
    course_number?: true
  }

  export type DishSumAggregateInputType = {
    sku?: true
    price?: true
    availableAtDayOfWeek?: true
    prepTime?: true
    course_number?: true
  }

  export type DishMinAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    name_esp?: true
    description?: true
    description_esp?: true
    price?: true
    unit?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    restaurantId?: true
    categoryId?: true
    subcategoryId?: true
    subSubcategoryId?: true
    availableAtDayOfWeek?: true
    prepTime?: true
    isPopular?: true
    isNew?: true
    menuId?: true
    course_number?: true
  }

  export type DishMaxAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    name_esp?: true
    description?: true
    description_esp?: true
    price?: true
    unit?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    restaurantId?: true
    categoryId?: true
    subcategoryId?: true
    subSubcategoryId?: true
    availableAtDayOfWeek?: true
    prepTime?: true
    isPopular?: true
    isNew?: true
    menuId?: true
    course_number?: true
  }

  export type DishCountAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    name_esp?: true
    description?: true
    description_esp?: true
    price?: true
    unit?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    restaurantId?: true
    categoryId?: true
    subcategoryId?: true
    subSubcategoryId?: true
    availableAtDayOfWeek?: true
    dietaryInfo?: true
    allergens?: true
    ingredients?: true
    prepTime?: true
    isPopular?: true
    isNew?: true
    menuId?: true
    course_number?: true
    _all?: true
  }

  export type DishAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dish to aggregate.
     */
    where?: DishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dishes to fetch.
     */
    orderBy?: DishOrderByWithRelationInput | DishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dishes
    **/
    _count?: true | DishCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DishAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DishSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DishMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DishMaxAggregateInputType
  }

  export type GetDishAggregateType<T extends DishAggregateArgs> = {
        [P in keyof T & keyof AggregateDish]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDish[P]>
      : GetScalarType<T[P], AggregateDish[P]>
  }




  export type DishGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DishWhereInput
    orderBy?: DishOrderByWithAggregationInput | DishOrderByWithAggregationInput[]
    by: DishScalarFieldEnum[] | DishScalarFieldEnum
    having?: DishScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DishCountAggregateInputType | true
    _avg?: DishAvgAggregateInputType
    _sum?: DishSumAggregateInputType
    _min?: DishMinAggregateInputType
    _max?: DishMaxAggregateInputType
  }

  export type DishGroupByOutputType = {
    id: string
    sku: number
    name: string
    name_esp: string
    description: string
    description_esp: string
    price: number
    unit: string | null
    image: string | null
    createdAt: Date
    updatedAt: Date
    restaurantId: string
    categoryId: string
    subcategoryId: string | null
    subSubcategoryId: string | null
    availableAtDayOfWeek: number
    dietaryInfo: string[]
    allergens: string[]
    ingredients: string[]
    prepTime: number | null
    isPopular: boolean
    isNew: boolean
    menuId: string | null
    course_number: number
    _count: DishCountAggregateOutputType | null
    _avg: DishAvgAggregateOutputType | null
    _sum: DishSumAggregateOutputType | null
    _min: DishMinAggregateOutputType | null
    _max: DishMaxAggregateOutputType | null
  }

  type GetDishGroupByPayload<T extends DishGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DishGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DishGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DishGroupByOutputType[P]>
            : GetScalarType<T[P], DishGroupByOutputType[P]>
        }
      >
    >


  export type DishSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    price?: boolean
    unit?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    restaurantId?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    subSubcategoryId?: boolean
    availableAtDayOfWeek?: boolean
    dietaryInfo?: boolean
    allergens?: boolean
    ingredients?: boolean
    prepTime?: boolean
    isPopular?: boolean
    isNew?: boolean
    menuId?: boolean
    course_number?: boolean
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | Dish$subcategoryArgs<ExtArgs>
    subSubcategory?: boolean | Dish$subSubcategoryArgs<ExtArgs>
    menu?: boolean | Dish$menuArgs<ExtArgs>
  }, ExtArgs["result"]["dish"]>

  export type DishSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    price?: boolean
    unit?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    restaurantId?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    subSubcategoryId?: boolean
    availableAtDayOfWeek?: boolean
    dietaryInfo?: boolean
    allergens?: boolean
    ingredients?: boolean
    prepTime?: boolean
    isPopular?: boolean
    isNew?: boolean
    menuId?: boolean
    course_number?: boolean
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | Dish$subcategoryArgs<ExtArgs>
    subSubcategory?: boolean | Dish$subSubcategoryArgs<ExtArgs>
    menu?: boolean | Dish$menuArgs<ExtArgs>
  }, ExtArgs["result"]["dish"]>

  export type DishSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    price?: boolean
    unit?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    restaurantId?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    subSubcategoryId?: boolean
    availableAtDayOfWeek?: boolean
    dietaryInfo?: boolean
    allergens?: boolean
    ingredients?: boolean
    prepTime?: boolean
    isPopular?: boolean
    isNew?: boolean
    menuId?: boolean
    course_number?: boolean
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | Dish$subcategoryArgs<ExtArgs>
    subSubcategory?: boolean | Dish$subSubcategoryArgs<ExtArgs>
    menu?: boolean | Dish$menuArgs<ExtArgs>
  }, ExtArgs["result"]["dish"]>

  export type DishSelectScalar = {
    id?: boolean
    sku?: boolean
    name?: boolean
    name_esp?: boolean
    description?: boolean
    description_esp?: boolean
    price?: boolean
    unit?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    restaurantId?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    subSubcategoryId?: boolean
    availableAtDayOfWeek?: boolean
    dietaryInfo?: boolean
    allergens?: boolean
    ingredients?: boolean
    prepTime?: boolean
    isPopular?: boolean
    isNew?: boolean
    menuId?: boolean
    course_number?: boolean
  }

  export type DishOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sku" | "name" | "name_esp" | "description" | "description_esp" | "price" | "unit" | "image" | "createdAt" | "updatedAt" | "restaurantId" | "categoryId" | "subcategoryId" | "subSubcategoryId" | "availableAtDayOfWeek" | "dietaryInfo" | "allergens" | "ingredients" | "prepTime" | "isPopular" | "isNew" | "menuId" | "course_number", ExtArgs["result"]["dish"]>
  export type DishInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | Dish$subcategoryArgs<ExtArgs>
    subSubcategory?: boolean | Dish$subSubcategoryArgs<ExtArgs>
    menu?: boolean | Dish$menuArgs<ExtArgs>
  }
  export type DishIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | Dish$subcategoryArgs<ExtArgs>
    subSubcategory?: boolean | Dish$subSubcategoryArgs<ExtArgs>
    menu?: boolean | Dish$menuArgs<ExtArgs>
  }
  export type DishIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | Dish$subcategoryArgs<ExtArgs>
    subSubcategory?: boolean | Dish$subSubcategoryArgs<ExtArgs>
    menu?: boolean | Dish$menuArgs<ExtArgs>
  }

  export type $DishPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dish"
    objects: {
      restaurant: Prisma.$RestaurantPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
      subcategory: Prisma.$SubcategoryPayload<ExtArgs> | null
      subSubcategory: Prisma.$SubSubcategoryPayload<ExtArgs> | null
      menu: Prisma.$MenuPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sku: number
      name: string
      name_esp: string
      description: string
      description_esp: string
      price: number
      unit: string | null
      image: string | null
      createdAt: Date
      updatedAt: Date
      restaurantId: string
      categoryId: string
      subcategoryId: string | null
      subSubcategoryId: string | null
      availableAtDayOfWeek: number
      dietaryInfo: string[]
      allergens: string[]
      ingredients: string[]
      prepTime: number | null
      isPopular: boolean
      isNew: boolean
      menuId: string | null
      course_number: number
    }, ExtArgs["result"]["dish"]>
    composites: {}
  }

  type DishGetPayload<S extends boolean | null | undefined | DishDefaultArgs> = $Result.GetResult<Prisma.$DishPayload, S>

  type DishCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DishFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: DishCountAggregateInputType | true
    }

  export interface DishDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dish'], meta: { name: 'Dish' } }
    /**
     * Find zero or one Dish that matches the filter.
     * @param {DishFindUniqueArgs} args - Arguments to find a Dish
     * @example
     * // Get one Dish
     * const dish = await prisma.dish.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DishFindUniqueArgs>(args: SelectSubset<T, DishFindUniqueArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dish that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DishFindUniqueOrThrowArgs} args - Arguments to find a Dish
     * @example
     * // Get one Dish
     * const dish = await prisma.dish.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DishFindUniqueOrThrowArgs>(args: SelectSubset<T, DishFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dish that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishFindFirstArgs} args - Arguments to find a Dish
     * @example
     * // Get one Dish
     * const dish = await prisma.dish.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DishFindFirstArgs>(args?: SelectSubset<T, DishFindFirstArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dish that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishFindFirstOrThrowArgs} args - Arguments to find a Dish
     * @example
     * // Get one Dish
     * const dish = await prisma.dish.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DishFindFirstOrThrowArgs>(args?: SelectSubset<T, DishFindFirstOrThrowArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Dishes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dishes
     * const dishes = await prisma.dish.findMany()
     * 
     * // Get first 10 Dishes
     * const dishes = await prisma.dish.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dishWithIdOnly = await prisma.dish.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DishFindManyArgs>(args?: SelectSubset<T, DishFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dish.
     * @param {DishCreateArgs} args - Arguments to create a Dish.
     * @example
     * // Create one Dish
     * const Dish = await prisma.dish.create({
     *   data: {
     *     // ... data to create a Dish
     *   }
     * })
     * 
     */
    create<T extends DishCreateArgs>(args: SelectSubset<T, DishCreateArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Dishes.
     * @param {DishCreateManyArgs} args - Arguments to create many Dishes.
     * @example
     * // Create many Dishes
     * const dish = await prisma.dish.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DishCreateManyArgs>(args?: SelectSubset<T, DishCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dishes and returns the data saved in the database.
     * @param {DishCreateManyAndReturnArgs} args - Arguments to create many Dishes.
     * @example
     * // Create many Dishes
     * const dish = await prisma.dish.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dishes and only return the `id`
     * const dishWithIdOnly = await prisma.dish.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DishCreateManyAndReturnArgs>(args?: SelectSubset<T, DishCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Dish.
     * @param {DishDeleteArgs} args - Arguments to delete one Dish.
     * @example
     * // Delete one Dish
     * const Dish = await prisma.dish.delete({
     *   where: {
     *     // ... filter to delete one Dish
     *   }
     * })
     * 
     */
    delete<T extends DishDeleteArgs>(args: SelectSubset<T, DishDeleteArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dish.
     * @param {DishUpdateArgs} args - Arguments to update one Dish.
     * @example
     * // Update one Dish
     * const dish = await prisma.dish.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DishUpdateArgs>(args: SelectSubset<T, DishUpdateArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Dishes.
     * @param {DishDeleteManyArgs} args - Arguments to filter Dishes to delete.
     * @example
     * // Delete a few Dishes
     * const { count } = await prisma.dish.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DishDeleteManyArgs>(args?: SelectSubset<T, DishDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dishes
     * const dish = await prisma.dish.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DishUpdateManyArgs>(args: SelectSubset<T, DishUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dishes and returns the data updated in the database.
     * @param {DishUpdateManyAndReturnArgs} args - Arguments to update many Dishes.
     * @example
     * // Update many Dishes
     * const dish = await prisma.dish.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Dishes and only return the `id`
     * const dishWithIdOnly = await prisma.dish.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DishUpdateManyAndReturnArgs>(args: SelectSubset<T, DishUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Dish.
     * @param {DishUpsertArgs} args - Arguments to update or create a Dish.
     * @example
     * // Update or create a Dish
     * const dish = await prisma.dish.upsert({
     *   create: {
     *     // ... data to create a Dish
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dish we want to update
     *   }
     * })
     */
    upsert<T extends DishUpsertArgs>(args: SelectSubset<T, DishUpsertArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Dishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishCountArgs} args - Arguments to filter Dishes to count.
     * @example
     * // Count the number of Dishes
     * const count = await prisma.dish.count({
     *   where: {
     *     // ... the filter for the Dishes we want to count
     *   }
     * })
    **/
    count<T extends DishCountArgs>(
      args?: Subset<T, DishCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DishCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dish.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DishAggregateArgs>(args: Subset<T, DishAggregateArgs>): Prisma.PrismaPromise<GetDishAggregateType<T>>

    /**
     * Group by Dish.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DishGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DishGroupByArgs['orderBy'] }
        : { orderBy?: DishGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DishGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDishGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dish model
   */
  readonly fields: DishFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dish.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DishClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    restaurant<T extends RestaurantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantDefaultArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subcategory<T extends Dish$subcategoryArgs<ExtArgs> = {}>(args?: Subset<T, Dish$subcategoryArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subSubcategory<T extends Dish$subSubcategoryArgs<ExtArgs> = {}>(args?: Subset<T, Dish$subSubcategoryArgs<ExtArgs>>): Prisma__SubSubcategoryClient<$Result.GetResult<Prisma.$SubSubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    menu<T extends Dish$menuArgs<ExtArgs> = {}>(args?: Subset<T, Dish$menuArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dish model
   */
  interface DishFieldRefs {
    readonly id: FieldRef<"Dish", 'String'>
    readonly sku: FieldRef<"Dish", 'Int'>
    readonly name: FieldRef<"Dish", 'String'>
    readonly name_esp: FieldRef<"Dish", 'String'>
    readonly description: FieldRef<"Dish", 'String'>
    readonly description_esp: FieldRef<"Dish", 'String'>
    readonly price: FieldRef<"Dish", 'Float'>
    readonly unit: FieldRef<"Dish", 'String'>
    readonly image: FieldRef<"Dish", 'String'>
    readonly createdAt: FieldRef<"Dish", 'DateTime'>
    readonly updatedAt: FieldRef<"Dish", 'DateTime'>
    readonly restaurantId: FieldRef<"Dish", 'String'>
    readonly categoryId: FieldRef<"Dish", 'String'>
    readonly subcategoryId: FieldRef<"Dish", 'String'>
    readonly subSubcategoryId: FieldRef<"Dish", 'String'>
    readonly availableAtDayOfWeek: FieldRef<"Dish", 'Int'>
    readonly dietaryInfo: FieldRef<"Dish", 'String[]'>
    readonly allergens: FieldRef<"Dish", 'String[]'>
    readonly ingredients: FieldRef<"Dish", 'String[]'>
    readonly prepTime: FieldRef<"Dish", 'Int'>
    readonly isPopular: FieldRef<"Dish", 'Boolean'>
    readonly isNew: FieldRef<"Dish", 'Boolean'>
    readonly menuId: FieldRef<"Dish", 'String'>
    readonly course_number: FieldRef<"Dish", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Dish findUnique
   */
  export type DishFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * Filter, which Dish to fetch.
     */
    where: DishWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dish findUniqueOrThrow
   */
  export type DishFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * Filter, which Dish to fetch.
     */
    where: DishWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dish findFirst
   */
  export type DishFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * Filter, which Dish to fetch.
     */
    where?: DishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dishes to fetch.
     */
    orderBy?: DishOrderByWithRelationInput | DishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dishes.
     */
    cursor?: DishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dishes.
     */
    distinct?: DishScalarFieldEnum | DishScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dish findFirstOrThrow
   */
  export type DishFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * Filter, which Dish to fetch.
     */
    where?: DishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dishes to fetch.
     */
    orderBy?: DishOrderByWithRelationInput | DishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dishes.
     */
    cursor?: DishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dishes.
     */
    distinct?: DishScalarFieldEnum | DishScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dish findMany
   */
  export type DishFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * Filter, which Dishes to fetch.
     */
    where?: DishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dishes to fetch.
     */
    orderBy?: DishOrderByWithRelationInput | DishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dishes.
     */
    cursor?: DishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dishes.
     */
    skip?: number
    distinct?: DishScalarFieldEnum | DishScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dish create
   */
  export type DishCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * The data needed to create a Dish.
     */
    data: XOR<DishCreateInput, DishUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dish createMany
   */
  export type DishCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dishes.
     */
    data: DishCreateManyInput | DishCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dish createManyAndReturn
   */
  export type DishCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * The data used to create many Dishes.
     */
    data: DishCreateManyInput | DishCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dish update
   */
  export type DishUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * The data needed to update a Dish.
     */
    data: XOR<DishUpdateInput, DishUncheckedUpdateInput>
    /**
     * Choose, which Dish to update.
     */
    where: DishWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dish updateMany
   */
  export type DishUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dishes.
     */
    data: XOR<DishUpdateManyMutationInput, DishUncheckedUpdateManyInput>
    /**
     * Filter which Dishes to update
     */
    where?: DishWhereInput
    /**
     * Limit how many Dishes to update.
     */
    limit?: number
  }

  /**
   * Dish updateManyAndReturn
   */
  export type DishUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * The data used to update Dishes.
     */
    data: XOR<DishUpdateManyMutationInput, DishUncheckedUpdateManyInput>
    /**
     * Filter which Dishes to update
     */
    where?: DishWhereInput
    /**
     * Limit how many Dishes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dish upsert
   */
  export type DishUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * The filter to search for the Dish to update in case it exists.
     */
    where: DishWhereUniqueInput
    /**
     * In case the Dish found by the `where` argument doesn't exist, create a new Dish with this data.
     */
    create: XOR<DishCreateInput, DishUncheckedCreateInput>
    /**
     * In case the Dish was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DishUpdateInput, DishUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dish delete
   */
  export type DishDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * Filter which Dish to delete.
     */
    where: DishWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dish deleteMany
   */
  export type DishDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dishes to delete
     */
    where?: DishWhereInput
    /**
     * Limit how many Dishes to delete.
     */
    limit?: number
  }

  /**
   * Dish.subcategory
   */
  export type Dish$subcategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    where?: SubcategoryWhereInput
  }

  /**
   * Dish.subSubcategory
   */
  export type Dish$subSubcategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubSubcategory
     */
    select?: SubSubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubSubcategory
     */
    omit?: SubSubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubSubcategoryInclude<ExtArgs> | null
    where?: SubSubcategoryWhereInput
  }

  /**
   * Dish.menu
   */
  export type Dish$menuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    where?: MenuWhereInput
  }

  /**
   * Dish without action
   */
  export type DishDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
  }


  /**
   * Model OpeningHours
   */

  export type AggregateOpeningHours = {
    _count: OpeningHoursCountAggregateOutputType | null
    _avg: OpeningHoursAvgAggregateOutputType | null
    _sum: OpeningHoursSumAggregateOutputType | null
    _min: OpeningHoursMinAggregateOutputType | null
    _max: OpeningHoursMaxAggregateOutputType | null
  }

  export type OpeningHoursAvgAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type OpeningHoursSumAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type OpeningHoursMinAggregateOutputType = {
    id: string | null
    dayOfWeek: number | null
    openTime: string | null
    closeTime: string | null
    isClosed: boolean | null
    restaurantId: string | null
  }

  export type OpeningHoursMaxAggregateOutputType = {
    id: string | null
    dayOfWeek: number | null
    openTime: string | null
    closeTime: string | null
    isClosed: boolean | null
    restaurantId: string | null
  }

  export type OpeningHoursCountAggregateOutputType = {
    id: number
    dayOfWeek: number
    openTime: number
    closeTime: number
    isClosed: number
    restaurantId: number
    _all: number
  }


  export type OpeningHoursAvgAggregateInputType = {
    dayOfWeek?: true
  }

  export type OpeningHoursSumAggregateInputType = {
    dayOfWeek?: true
  }

  export type OpeningHoursMinAggregateInputType = {
    id?: true
    dayOfWeek?: true
    openTime?: true
    closeTime?: true
    isClosed?: true
    restaurantId?: true
  }

  export type OpeningHoursMaxAggregateInputType = {
    id?: true
    dayOfWeek?: true
    openTime?: true
    closeTime?: true
    isClosed?: true
    restaurantId?: true
  }

  export type OpeningHoursCountAggregateInputType = {
    id?: true
    dayOfWeek?: true
    openTime?: true
    closeTime?: true
    isClosed?: true
    restaurantId?: true
    _all?: true
  }

  export type OpeningHoursAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpeningHours to aggregate.
     */
    where?: OpeningHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpeningHours to fetch.
     */
    orderBy?: OpeningHoursOrderByWithRelationInput | OpeningHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpeningHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpeningHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpeningHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OpeningHours
    **/
    _count?: true | OpeningHoursCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OpeningHoursAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OpeningHoursSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpeningHoursMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpeningHoursMaxAggregateInputType
  }

  export type GetOpeningHoursAggregateType<T extends OpeningHoursAggregateArgs> = {
        [P in keyof T & keyof AggregateOpeningHours]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpeningHours[P]>
      : GetScalarType<T[P], AggregateOpeningHours[P]>
  }




  export type OpeningHoursGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpeningHoursWhereInput
    orderBy?: OpeningHoursOrderByWithAggregationInput | OpeningHoursOrderByWithAggregationInput[]
    by: OpeningHoursScalarFieldEnum[] | OpeningHoursScalarFieldEnum
    having?: OpeningHoursScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpeningHoursCountAggregateInputType | true
    _avg?: OpeningHoursAvgAggregateInputType
    _sum?: OpeningHoursSumAggregateInputType
    _min?: OpeningHoursMinAggregateInputType
    _max?: OpeningHoursMaxAggregateInputType
  }

  export type OpeningHoursGroupByOutputType = {
    id: string
    dayOfWeek: number
    openTime: string
    closeTime: string
    isClosed: boolean
    restaurantId: string
    _count: OpeningHoursCountAggregateOutputType | null
    _avg: OpeningHoursAvgAggregateOutputType | null
    _sum: OpeningHoursSumAggregateOutputType | null
    _min: OpeningHoursMinAggregateOutputType | null
    _max: OpeningHoursMaxAggregateOutputType | null
  }

  type GetOpeningHoursGroupByPayload<T extends OpeningHoursGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpeningHoursGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpeningHoursGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpeningHoursGroupByOutputType[P]>
            : GetScalarType<T[P], OpeningHoursGroupByOutputType[P]>
        }
      >
    >


  export type OpeningHoursSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dayOfWeek?: boolean
    openTime?: boolean
    closeTime?: boolean
    isClosed?: boolean
    restaurantId?: boolean
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["openingHours"]>

  export type OpeningHoursSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dayOfWeek?: boolean
    openTime?: boolean
    closeTime?: boolean
    isClosed?: boolean
    restaurantId?: boolean
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["openingHours"]>

  export type OpeningHoursSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dayOfWeek?: boolean
    openTime?: boolean
    closeTime?: boolean
    isClosed?: boolean
    restaurantId?: boolean
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["openingHours"]>

  export type OpeningHoursSelectScalar = {
    id?: boolean
    dayOfWeek?: boolean
    openTime?: boolean
    closeTime?: boolean
    isClosed?: boolean
    restaurantId?: boolean
  }

  export type OpeningHoursOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dayOfWeek" | "openTime" | "closeTime" | "isClosed" | "restaurantId", ExtArgs["result"]["openingHours"]>
  export type OpeningHoursInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }
  export type OpeningHoursIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }
  export type OpeningHoursIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restaurant?: boolean | RestaurantDefaultArgs<ExtArgs>
  }

  export type $OpeningHoursPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OpeningHours"
    objects: {
      restaurant: Prisma.$RestaurantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dayOfWeek: number
      openTime: string
      closeTime: string
      isClosed: boolean
      restaurantId: string
    }, ExtArgs["result"]["openingHours"]>
    composites: {}
  }

  type OpeningHoursGetPayload<S extends boolean | null | undefined | OpeningHoursDefaultArgs> = $Result.GetResult<Prisma.$OpeningHoursPayload, S>

  type OpeningHoursCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OpeningHoursFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: OpeningHoursCountAggregateInputType | true
    }

  export interface OpeningHoursDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OpeningHours'], meta: { name: 'OpeningHours' } }
    /**
     * Find zero or one OpeningHours that matches the filter.
     * @param {OpeningHoursFindUniqueArgs} args - Arguments to find a OpeningHours
     * @example
     * // Get one OpeningHours
     * const openingHours = await prisma.openingHours.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpeningHoursFindUniqueArgs>(args: SelectSubset<T, OpeningHoursFindUniqueArgs<ExtArgs>>): Prisma__OpeningHoursClient<$Result.GetResult<Prisma.$OpeningHoursPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OpeningHours that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OpeningHoursFindUniqueOrThrowArgs} args - Arguments to find a OpeningHours
     * @example
     * // Get one OpeningHours
     * const openingHours = await prisma.openingHours.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpeningHoursFindUniqueOrThrowArgs>(args: SelectSubset<T, OpeningHoursFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpeningHoursClient<$Result.GetResult<Prisma.$OpeningHoursPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OpeningHours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpeningHoursFindFirstArgs} args - Arguments to find a OpeningHours
     * @example
     * // Get one OpeningHours
     * const openingHours = await prisma.openingHours.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpeningHoursFindFirstArgs>(args?: SelectSubset<T, OpeningHoursFindFirstArgs<ExtArgs>>): Prisma__OpeningHoursClient<$Result.GetResult<Prisma.$OpeningHoursPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OpeningHours that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpeningHoursFindFirstOrThrowArgs} args - Arguments to find a OpeningHours
     * @example
     * // Get one OpeningHours
     * const openingHours = await prisma.openingHours.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpeningHoursFindFirstOrThrowArgs>(args?: SelectSubset<T, OpeningHoursFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpeningHoursClient<$Result.GetResult<Prisma.$OpeningHoursPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OpeningHours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpeningHoursFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OpeningHours
     * const openingHours = await prisma.openingHours.findMany()
     * 
     * // Get first 10 OpeningHours
     * const openingHours = await prisma.openingHours.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const openingHoursWithIdOnly = await prisma.openingHours.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OpeningHoursFindManyArgs>(args?: SelectSubset<T, OpeningHoursFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpeningHoursPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OpeningHours.
     * @param {OpeningHoursCreateArgs} args - Arguments to create a OpeningHours.
     * @example
     * // Create one OpeningHours
     * const OpeningHours = await prisma.openingHours.create({
     *   data: {
     *     // ... data to create a OpeningHours
     *   }
     * })
     * 
     */
    create<T extends OpeningHoursCreateArgs>(args: SelectSubset<T, OpeningHoursCreateArgs<ExtArgs>>): Prisma__OpeningHoursClient<$Result.GetResult<Prisma.$OpeningHoursPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OpeningHours.
     * @param {OpeningHoursCreateManyArgs} args - Arguments to create many OpeningHours.
     * @example
     * // Create many OpeningHours
     * const openingHours = await prisma.openingHours.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpeningHoursCreateManyArgs>(args?: SelectSubset<T, OpeningHoursCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OpeningHours and returns the data saved in the database.
     * @param {OpeningHoursCreateManyAndReturnArgs} args - Arguments to create many OpeningHours.
     * @example
     * // Create many OpeningHours
     * const openingHours = await prisma.openingHours.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OpeningHours and only return the `id`
     * const openingHoursWithIdOnly = await prisma.openingHours.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OpeningHoursCreateManyAndReturnArgs>(args?: SelectSubset<T, OpeningHoursCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpeningHoursPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OpeningHours.
     * @param {OpeningHoursDeleteArgs} args - Arguments to delete one OpeningHours.
     * @example
     * // Delete one OpeningHours
     * const OpeningHours = await prisma.openingHours.delete({
     *   where: {
     *     // ... filter to delete one OpeningHours
     *   }
     * })
     * 
     */
    delete<T extends OpeningHoursDeleteArgs>(args: SelectSubset<T, OpeningHoursDeleteArgs<ExtArgs>>): Prisma__OpeningHoursClient<$Result.GetResult<Prisma.$OpeningHoursPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OpeningHours.
     * @param {OpeningHoursUpdateArgs} args - Arguments to update one OpeningHours.
     * @example
     * // Update one OpeningHours
     * const openingHours = await prisma.openingHours.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpeningHoursUpdateArgs>(args: SelectSubset<T, OpeningHoursUpdateArgs<ExtArgs>>): Prisma__OpeningHoursClient<$Result.GetResult<Prisma.$OpeningHoursPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OpeningHours.
     * @param {OpeningHoursDeleteManyArgs} args - Arguments to filter OpeningHours to delete.
     * @example
     * // Delete a few OpeningHours
     * const { count } = await prisma.openingHours.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpeningHoursDeleteManyArgs>(args?: SelectSubset<T, OpeningHoursDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpeningHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpeningHoursUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OpeningHours
     * const openingHours = await prisma.openingHours.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpeningHoursUpdateManyArgs>(args: SelectSubset<T, OpeningHoursUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpeningHours and returns the data updated in the database.
     * @param {OpeningHoursUpdateManyAndReturnArgs} args - Arguments to update many OpeningHours.
     * @example
     * // Update many OpeningHours
     * const openingHours = await prisma.openingHours.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OpeningHours and only return the `id`
     * const openingHoursWithIdOnly = await prisma.openingHours.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OpeningHoursUpdateManyAndReturnArgs>(args: SelectSubset<T, OpeningHoursUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpeningHoursPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OpeningHours.
     * @param {OpeningHoursUpsertArgs} args - Arguments to update or create a OpeningHours.
     * @example
     * // Update or create a OpeningHours
     * const openingHours = await prisma.openingHours.upsert({
     *   create: {
     *     // ... data to create a OpeningHours
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OpeningHours we want to update
     *   }
     * })
     */
    upsert<T extends OpeningHoursUpsertArgs>(args: SelectSubset<T, OpeningHoursUpsertArgs<ExtArgs>>): Prisma__OpeningHoursClient<$Result.GetResult<Prisma.$OpeningHoursPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OpeningHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpeningHoursCountArgs} args - Arguments to filter OpeningHours to count.
     * @example
     * // Count the number of OpeningHours
     * const count = await prisma.openingHours.count({
     *   where: {
     *     // ... the filter for the OpeningHours we want to count
     *   }
     * })
    **/
    count<T extends OpeningHoursCountArgs>(
      args?: Subset<T, OpeningHoursCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpeningHoursCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OpeningHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpeningHoursAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpeningHoursAggregateArgs>(args: Subset<T, OpeningHoursAggregateArgs>): Prisma.PrismaPromise<GetOpeningHoursAggregateType<T>>

    /**
     * Group by OpeningHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpeningHoursGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpeningHoursGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpeningHoursGroupByArgs['orderBy'] }
        : { orderBy?: OpeningHoursGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpeningHoursGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpeningHoursGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OpeningHours model
   */
  readonly fields: OpeningHoursFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OpeningHours.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpeningHoursClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    restaurant<T extends RestaurantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantDefaultArgs<ExtArgs>>): Prisma__RestaurantClient<$Result.GetResult<Prisma.$RestaurantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OpeningHours model
   */
  interface OpeningHoursFieldRefs {
    readonly id: FieldRef<"OpeningHours", 'String'>
    readonly dayOfWeek: FieldRef<"OpeningHours", 'Int'>
    readonly openTime: FieldRef<"OpeningHours", 'String'>
    readonly closeTime: FieldRef<"OpeningHours", 'String'>
    readonly isClosed: FieldRef<"OpeningHours", 'Boolean'>
    readonly restaurantId: FieldRef<"OpeningHours", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OpeningHours findUnique
   */
  export type OpeningHoursFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpeningHours
     */
    select?: OpeningHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpeningHours
     */
    omit?: OpeningHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpeningHoursInclude<ExtArgs> | null
    /**
     * Filter, which OpeningHours to fetch.
     */
    where: OpeningHoursWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OpeningHours findUniqueOrThrow
   */
  export type OpeningHoursFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpeningHours
     */
    select?: OpeningHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpeningHours
     */
    omit?: OpeningHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpeningHoursInclude<ExtArgs> | null
    /**
     * Filter, which OpeningHours to fetch.
     */
    where: OpeningHoursWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OpeningHours findFirst
   */
  export type OpeningHoursFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpeningHours
     */
    select?: OpeningHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpeningHours
     */
    omit?: OpeningHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpeningHoursInclude<ExtArgs> | null
    /**
     * Filter, which OpeningHours to fetch.
     */
    where?: OpeningHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpeningHours to fetch.
     */
    orderBy?: OpeningHoursOrderByWithRelationInput | OpeningHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpeningHours.
     */
    cursor?: OpeningHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpeningHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpeningHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpeningHours.
     */
    distinct?: OpeningHoursScalarFieldEnum | OpeningHoursScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OpeningHours findFirstOrThrow
   */
  export type OpeningHoursFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpeningHours
     */
    select?: OpeningHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpeningHours
     */
    omit?: OpeningHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpeningHoursInclude<ExtArgs> | null
    /**
     * Filter, which OpeningHours to fetch.
     */
    where?: OpeningHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpeningHours to fetch.
     */
    orderBy?: OpeningHoursOrderByWithRelationInput | OpeningHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpeningHours.
     */
    cursor?: OpeningHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpeningHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpeningHours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpeningHours.
     */
    distinct?: OpeningHoursScalarFieldEnum | OpeningHoursScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OpeningHours findMany
   */
  export type OpeningHoursFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpeningHours
     */
    select?: OpeningHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpeningHours
     */
    omit?: OpeningHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpeningHoursInclude<ExtArgs> | null
    /**
     * Filter, which OpeningHours to fetch.
     */
    where?: OpeningHoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpeningHours to fetch.
     */
    orderBy?: OpeningHoursOrderByWithRelationInput | OpeningHoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OpeningHours.
     */
    cursor?: OpeningHoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpeningHours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpeningHours.
     */
    skip?: number
    distinct?: OpeningHoursScalarFieldEnum | OpeningHoursScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OpeningHours create
   */
  export type OpeningHoursCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpeningHours
     */
    select?: OpeningHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpeningHours
     */
    omit?: OpeningHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpeningHoursInclude<ExtArgs> | null
    /**
     * The data needed to create a OpeningHours.
     */
    data: XOR<OpeningHoursCreateInput, OpeningHoursUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OpeningHours createMany
   */
  export type OpeningHoursCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OpeningHours.
     */
    data: OpeningHoursCreateManyInput | OpeningHoursCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OpeningHours createManyAndReturn
   */
  export type OpeningHoursCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpeningHours
     */
    select?: OpeningHoursSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OpeningHours
     */
    omit?: OpeningHoursOmit<ExtArgs> | null
    /**
     * The data used to create many OpeningHours.
     */
    data: OpeningHoursCreateManyInput | OpeningHoursCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpeningHoursIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OpeningHours update
   */
  export type OpeningHoursUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpeningHours
     */
    select?: OpeningHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpeningHours
     */
    omit?: OpeningHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpeningHoursInclude<ExtArgs> | null
    /**
     * The data needed to update a OpeningHours.
     */
    data: XOR<OpeningHoursUpdateInput, OpeningHoursUncheckedUpdateInput>
    /**
     * Choose, which OpeningHours to update.
     */
    where: OpeningHoursWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OpeningHours updateMany
   */
  export type OpeningHoursUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OpeningHours.
     */
    data: XOR<OpeningHoursUpdateManyMutationInput, OpeningHoursUncheckedUpdateManyInput>
    /**
     * Filter which OpeningHours to update
     */
    where?: OpeningHoursWhereInput
    /**
     * Limit how many OpeningHours to update.
     */
    limit?: number
  }

  /**
   * OpeningHours updateManyAndReturn
   */
  export type OpeningHoursUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpeningHours
     */
    select?: OpeningHoursSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OpeningHours
     */
    omit?: OpeningHoursOmit<ExtArgs> | null
    /**
     * The data used to update OpeningHours.
     */
    data: XOR<OpeningHoursUpdateManyMutationInput, OpeningHoursUncheckedUpdateManyInput>
    /**
     * Filter which OpeningHours to update
     */
    where?: OpeningHoursWhereInput
    /**
     * Limit how many OpeningHours to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpeningHoursIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OpeningHours upsert
   */
  export type OpeningHoursUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpeningHours
     */
    select?: OpeningHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpeningHours
     */
    omit?: OpeningHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpeningHoursInclude<ExtArgs> | null
    /**
     * The filter to search for the OpeningHours to update in case it exists.
     */
    where: OpeningHoursWhereUniqueInput
    /**
     * In case the OpeningHours found by the `where` argument doesn't exist, create a new OpeningHours with this data.
     */
    create: XOR<OpeningHoursCreateInput, OpeningHoursUncheckedCreateInput>
    /**
     * In case the OpeningHours was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpeningHoursUpdateInput, OpeningHoursUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OpeningHours delete
   */
  export type OpeningHoursDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpeningHours
     */
    select?: OpeningHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpeningHours
     */
    omit?: OpeningHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpeningHoursInclude<ExtArgs> | null
    /**
     * Filter which OpeningHours to delete.
     */
    where: OpeningHoursWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OpeningHours deleteMany
   */
  export type OpeningHoursDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpeningHours to delete
     */
    where?: OpeningHoursWhereInput
    /**
     * Limit how many OpeningHours to delete.
     */
    limit?: number
  }

  /**
   * OpeningHours without action
   */
  export type OpeningHoursDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpeningHours
     */
    select?: OpeningHoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpeningHours
     */
    omit?: OpeningHoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpeningHoursInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const HotelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    description_esp: 'description_esp',
    image: 'image',
    country: 'country',
    state: 'state',
    city: 'city',
    locationDescription: 'locationDescription',
    locationDescription_esp: 'locationDescription_esp',
    images: 'images',
    videos: 'videos',
    lat: 'lat',
    lng: 'lng',
    phone: 'phone',
    phone_reservation: 'phone_reservation',
    phone_tollfree: 'phone_tollfree',
    email: 'email',
    website: 'website',
    facebook: 'facebook',
    tripadvisor: 'tripadvisor',
    instagram: 'instagram',
    youtube: 'youtube',
    whatsapp: 'whatsapp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HotelScalarFieldEnum = (typeof HotelScalarFieldEnum)[keyof typeof HotelScalarFieldEnum]


  export const RelationLoadStrategy: {
    query: 'query',
    join: 'join'
  };

  export type RelationLoadStrategy = (typeof RelationLoadStrategy)[keyof typeof RelationLoadStrategy]


  export const AmenitiesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    icon: 'icon',
    image: 'image',
    amenitiestype: 'amenitiestype',
    hotelId: 'hotelId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AmenitiesScalarFieldEnum = (typeof AmenitiesScalarFieldEnum)[keyof typeof AmenitiesScalarFieldEnum]


  export const TourPriceCategoryScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    price: 'price',
    description: 'description',
    description_esp: 'description_esp',
    tourId: 'tourId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TourPriceCategoryScalarFieldEnum = (typeof TourPriceCategoryScalarFieldEnum)[keyof typeof TourPriceCategoryScalarFieldEnum]


  export const TourScalarFieldEnum: {
    id: 'id',
    name: 'name',
    name_esp: 'name_esp',
    description: 'description',
    description_esp: 'description_esp',
    image: 'image',
    hotelId: 'hotelId',
    price: 'price',
    priceKids: 'priceKids',
    category: 'category',
    offer: 'offer',
    discount: 'discount',
    whattobring: 'whattobring',
    included: 'included',
    pickuptime: 'pickuptime',
    maxPeople: 'maxPeople',
    minPeople: 'minPeople',
    minAge: 'minAge',
    bestSeller: 'bestSeller',
    priceInfo: 'priceInfo',
    location: 'location',
    offered: 'offered',
    duration: 'duration',
    videos: 'videos',
    images: 'images',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TourScalarFieldEnum = (typeof TourScalarFieldEnum)[keyof typeof TourScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    name_esp: 'name_esp',
    description: 'description',
    description_esp: 'description_esp',
    image: 'image',
    profileImage: 'profileImage',
    hotelId: 'hotelId',
    type: 'type',
    start: 'start',
    end: 'end',
    price: 'price',
    cashOnly: 'cashOnly',
    freeOfCharge: 'freeOfCharge',
    location: 'location',
    isRecurring: 'isRecurring',
    recurrencePattern: 'recurrencePattern',
    recurrenceDays: 'recurrenceDays',
    recurrenceEndDate: 'recurrenceEndDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const SpaPriceCategoryScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    price: 'price',
    description: 'description',
    description_esp: 'description_esp',
    duration: 'duration',
    spaId: 'spaId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SpaPriceCategoryScalarFieldEnum = (typeof SpaPriceCategoryScalarFieldEnum)[keyof typeof SpaPriceCategoryScalarFieldEnum]


  export const SpaScalarFieldEnum: {
    id: 'id',
    name: 'name',
    name_esp: 'name_esp',
    description: 'description',
    description_esp: 'description_esp',
    hotelId: 'hotelId',
    type: 'type',
    videos: 'videos',
    images: 'images',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SpaScalarFieldEnum = (typeof SpaScalarFieldEnum)[keyof typeof SpaScalarFieldEnum]


  export const TVChannelsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    name_esp: 'name_esp',
    description: 'description',
    description_esp: 'description_esp',
    logo: 'logo',
    channelNo: 'channelNo',
    languages: 'languages',
    channeltype: 'channeltype',
    category: 'category',
    hotelId: 'hotelId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TVChannelsScalarFieldEnum = (typeof TVChannelsScalarFieldEnum)[keyof typeof TVChannelsScalarFieldEnum]


  export const RestaurantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    descriptionshort: 'descriptionshort',
    description_esp: 'description_esp',
    descriptionshort_esp: 'descriptionshort_esp',
    image: 'image',
    address: 'address',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    phone: 'phone',
    email: 'email',
    website: 'website',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    listorder: 'listorder'
  };

  export type RestaurantScalarFieldEnum = (typeof RestaurantScalarFieldEnum)[keyof typeof RestaurantScalarFieldEnum]


  export const MenuScalarFieldEnum: {
    id: 'id',
    position: 'position',
    name: 'name',
    name_esp: 'name_esp',
    description: 'description',
    description_esp: 'description_esp',
    image: 'image',
    price: 'price',
    restaurantId: 'restaurantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isActive: 'isActive'
  };

  export type MenuScalarFieldEnum = (typeof MenuScalarFieldEnum)[keyof typeof MenuScalarFieldEnum]


  export const TableScalarFieldEnum: {
    id: 'id',
    number: 'number',
    capacity: 'capacity',
    location: 'location',
    isActive: 'isActive',
    restaurantId: 'restaurantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TableScalarFieldEnum = (typeof TableScalarFieldEnum)[keyof typeof TableScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const ReservationScalarFieldEnum: {
    id: 'id',
    date: 'date',
    startTime: 'startTime',
    endTime: 'endTime',
    partySize: 'partySize',
    status: 'status',
    notes: 'notes',
    customerId: 'customerId',
    tableId: 'tableId',
    restaurantId: 'restaurantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReservationScalarFieldEnum = (typeof ReservationScalarFieldEnum)[keyof typeof ReservationScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    name_esp: 'name_esp',
    slug: 'slug',
    description: 'description',
    description_esp: 'description_esp',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    restaurantId: 'restaurantId',
    postition: 'postition'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const SubcategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    name_esp: 'name_esp',
    slug: 'slug',
    description: 'description',
    description_esp: 'description_esp',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    parentCategoryId: 'parentCategoryId',
    postition: 'postition'
  };

  export type SubcategoryScalarFieldEnum = (typeof SubcategoryScalarFieldEnum)[keyof typeof SubcategoryScalarFieldEnum]


  export const SubSubcategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    name_esp: 'name_esp',
    slug: 'slug',
    description: 'description',
    description_esp: 'description_esp',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    parentSubcategoryId: 'parentSubcategoryId',
    postition: 'postition'
  };

  export type SubSubcategoryScalarFieldEnum = (typeof SubSubcategoryScalarFieldEnum)[keyof typeof SubSubcategoryScalarFieldEnum]


  export const DishScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    name: 'name',
    name_esp: 'name_esp',
    description: 'description',
    description_esp: 'description_esp',
    price: 'price',
    unit: 'unit',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    restaurantId: 'restaurantId',
    categoryId: 'categoryId',
    subcategoryId: 'subcategoryId',
    subSubcategoryId: 'subSubcategoryId',
    availableAtDayOfWeek: 'availableAtDayOfWeek',
    dietaryInfo: 'dietaryInfo',
    allergens: 'allergens',
    ingredients: 'ingredients',
    prepTime: 'prepTime',
    isPopular: 'isPopular',
    isNew: 'isNew',
    menuId: 'menuId',
    course_number: 'course_number'
  };

  export type DishScalarFieldEnum = (typeof DishScalarFieldEnum)[keyof typeof DishScalarFieldEnum]


  export const OpeningHoursScalarFieldEnum: {
    id: 'id',
    dayOfWeek: 'dayOfWeek',
    openTime: 'openTime',
    closeTime: 'closeTime',
    isClosed: 'isClosed',
    restaurantId: 'restaurantId'
  };

  export type OpeningHoursScalarFieldEnum = (typeof OpeningHoursScalarFieldEnum)[keyof typeof OpeningHoursScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const HotelOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    description_esp: 'description_esp',
    image: 'image',
    country: 'country',
    state: 'state',
    city: 'city',
    locationDescription: 'locationDescription',
    locationDescription_esp: 'locationDescription_esp',
    images: 'images',
    videos: 'videos',
    phone: 'phone',
    phone_reservation: 'phone_reservation',
    phone_tollfree: 'phone_tollfree',
    email: 'email',
    website: 'website',
    facebook: 'facebook',
    tripadvisor: 'tripadvisor',
    instagram: 'instagram',
    youtube: 'youtube',
    whatsapp: 'whatsapp'
  };

  export type HotelOrderByRelevanceFieldEnum = (typeof HotelOrderByRelevanceFieldEnum)[keyof typeof HotelOrderByRelevanceFieldEnum]


  export const AmenitiesOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    icon: 'icon',
    image: 'image',
    hotelId: 'hotelId'
  };

  export type AmenitiesOrderByRelevanceFieldEnum = (typeof AmenitiesOrderByRelevanceFieldEnum)[keyof typeof AmenitiesOrderByRelevanceFieldEnum]


  export const TourPriceCategoryOrderByRelevanceFieldEnum: {
    id: 'id',
    description: 'description',
    description_esp: 'description_esp',
    tourId: 'tourId'
  };

  export type TourPriceCategoryOrderByRelevanceFieldEnum = (typeof TourPriceCategoryOrderByRelevanceFieldEnum)[keyof typeof TourPriceCategoryOrderByRelevanceFieldEnum]


  export const TourOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    name_esp: 'name_esp',
    description: 'description',
    description_esp: 'description_esp',
    image: 'image',
    hotelId: 'hotelId',
    category: 'category',
    whattobring: 'whattobring',
    included: 'included',
    priceInfo: 'priceInfo',
    location: 'location',
    offered: 'offered',
    videos: 'videos',
    images: 'images'
  };

  export type TourOrderByRelevanceFieldEnum = (typeof TourOrderByRelevanceFieldEnum)[keyof typeof TourOrderByRelevanceFieldEnum]


  export const ActivityOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    name_esp: 'name_esp',
    description: 'description',
    description_esp: 'description_esp',
    image: 'image',
    profileImage: 'profileImage',
    hotelId: 'hotelId',
    type: 'type',
    location: 'location',
    recurrenceDays: 'recurrenceDays'
  };

  export type ActivityOrderByRelevanceFieldEnum = (typeof ActivityOrderByRelevanceFieldEnum)[keyof typeof ActivityOrderByRelevanceFieldEnum]


  export const SpaPriceCategoryOrderByRelevanceFieldEnum: {
    id: 'id',
    description: 'description',
    description_esp: 'description_esp',
    spaId: 'spaId'
  };

  export type SpaPriceCategoryOrderByRelevanceFieldEnum = (typeof SpaPriceCategoryOrderByRelevanceFieldEnum)[keyof typeof SpaPriceCategoryOrderByRelevanceFieldEnum]


  export const SpaOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    name_esp: 'name_esp',
    description: 'description',
    description_esp: 'description_esp',
    hotelId: 'hotelId',
    type: 'type',
    videos: 'videos',
    images: 'images'
  };

  export type SpaOrderByRelevanceFieldEnum = (typeof SpaOrderByRelevanceFieldEnum)[keyof typeof SpaOrderByRelevanceFieldEnum]


  export const TVChannelsOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    name_esp: 'name_esp',
    description: 'description',
    description_esp: 'description_esp',
    logo: 'logo',
    channelNo: 'channelNo',
    category: 'category',
    hotelId: 'hotelId'
  };

  export type TVChannelsOrderByRelevanceFieldEnum = (typeof TVChannelsOrderByRelevanceFieldEnum)[keyof typeof TVChannelsOrderByRelevanceFieldEnum]


  export const RestaurantOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    descriptionshort: 'descriptionshort',
    description_esp: 'description_esp',
    descriptionshort_esp: 'descriptionshort_esp',
    image: 'image',
    address: 'address',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    phone: 'phone',
    email: 'email',
    website: 'website'
  };

  export type RestaurantOrderByRelevanceFieldEnum = (typeof RestaurantOrderByRelevanceFieldEnum)[keyof typeof RestaurantOrderByRelevanceFieldEnum]


  export const MenuOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    name_esp: 'name_esp',
    description: 'description',
    description_esp: 'description_esp',
    image: 'image',
    restaurantId: 'restaurantId'
  };

  export type MenuOrderByRelevanceFieldEnum = (typeof MenuOrderByRelevanceFieldEnum)[keyof typeof MenuOrderByRelevanceFieldEnum]


  export const TableOrderByRelevanceFieldEnum: {
    id: 'id',
    location: 'location',
    restaurantId: 'restaurantId'
  };

  export type TableOrderByRelevanceFieldEnum = (typeof TableOrderByRelevanceFieldEnum)[keyof typeof TableOrderByRelevanceFieldEnum]


  export const CustomerOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone'
  };

  export type CustomerOrderByRelevanceFieldEnum = (typeof CustomerOrderByRelevanceFieldEnum)[keyof typeof CustomerOrderByRelevanceFieldEnum]


  export const ReservationOrderByRelevanceFieldEnum: {
    id: 'id',
    notes: 'notes',
    customerId: 'customerId',
    tableId: 'tableId',
    restaurantId: 'restaurantId'
  };

  export type ReservationOrderByRelevanceFieldEnum = (typeof ReservationOrderByRelevanceFieldEnum)[keyof typeof ReservationOrderByRelevanceFieldEnum]


  export const CategoryOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    name_esp: 'name_esp',
    slug: 'slug',
    description: 'description',
    description_esp: 'description_esp',
    image: 'image',
    restaurantId: 'restaurantId'
  };

  export type CategoryOrderByRelevanceFieldEnum = (typeof CategoryOrderByRelevanceFieldEnum)[keyof typeof CategoryOrderByRelevanceFieldEnum]


  export const SubcategoryOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    name_esp: 'name_esp',
    slug: 'slug',
    description: 'description',
    description_esp: 'description_esp',
    image: 'image',
    parentCategoryId: 'parentCategoryId'
  };

  export type SubcategoryOrderByRelevanceFieldEnum = (typeof SubcategoryOrderByRelevanceFieldEnum)[keyof typeof SubcategoryOrderByRelevanceFieldEnum]


  export const SubSubcategoryOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    name_esp: 'name_esp',
    slug: 'slug',
    description: 'description',
    description_esp: 'description_esp',
    image: 'image',
    parentSubcategoryId: 'parentSubcategoryId'
  };

  export type SubSubcategoryOrderByRelevanceFieldEnum = (typeof SubSubcategoryOrderByRelevanceFieldEnum)[keyof typeof SubSubcategoryOrderByRelevanceFieldEnum]


  export const DishOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    name_esp: 'name_esp',
    description: 'description',
    description_esp: 'description_esp',
    unit: 'unit',
    image: 'image',
    restaurantId: 'restaurantId',
    categoryId: 'categoryId',
    subcategoryId: 'subcategoryId',
    subSubcategoryId: 'subSubcategoryId',
    dietaryInfo: 'dietaryInfo',
    allergens: 'allergens',
    ingredients: 'ingredients',
    menuId: 'menuId'
  };

  export type DishOrderByRelevanceFieldEnum = (typeof DishOrderByRelevanceFieldEnum)[keyof typeof DishOrderByRelevanceFieldEnum]


  export const OpeningHoursOrderByRelevanceFieldEnum: {
    id: 'id',
    openTime: 'openTime',
    closeTime: 'closeTime',
    restaurantId: 'restaurantId'
  };

  export type OpeningHoursOrderByRelevanceFieldEnum = (typeof OpeningHoursOrderByRelevanceFieldEnum)[keyof typeof OpeningHoursOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'AMENITIESTYPE'
   */
  export type EnumAMENITIESTYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AMENITIESTYPE'>
    


  /**
   * Reference to a field of type 'AMENITIESTYPE[]'
   */
  export type ListEnumAMENITIESTYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AMENITIESTYPE[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'RECURRINGPATTERN'
   */
  export type EnumRECURRINGPATTERNFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RECURRINGPATTERN'>
    


  /**
   * Reference to a field of type 'RECURRINGPATTERN[]'
   */
  export type ListEnumRECURRINGPATTERNFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RECURRINGPATTERN[]'>
    


  /**
   * Reference to a field of type 'TVChannelLanguages'
   */
  export type EnumTVChannelLanguagesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TVChannelLanguages'>
    


  /**
   * Reference to a field of type 'TVChannelLanguages[]'
   */
  export type ListEnumTVChannelLanguagesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TVChannelLanguages[]'>
    


  /**
   * Reference to a field of type 'TVCHANNELTYPE'
   */
  export type EnumTVCHANNELTYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TVCHANNELTYPE'>
    


  /**
   * Reference to a field of type 'TVCHANNELTYPE[]'
   */
  export type ListEnumTVCHANNELTYPEFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TVCHANNELTYPE[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ReservationStatus'
   */
  export type EnumReservationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReservationStatus'>
    


  /**
   * Reference to a field of type 'ReservationStatus[]'
   */
  export type ListEnumReservationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReservationStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type HotelWhereInput = {
    AND?: HotelWhereInput | HotelWhereInput[]
    OR?: HotelWhereInput[]
    NOT?: HotelWhereInput | HotelWhereInput[]
    id?: StringFilter<"Hotel"> | string
    name?: StringFilter<"Hotel"> | string
    description?: StringFilter<"Hotel"> | string
    description_esp?: StringFilter<"Hotel"> | string
    image?: StringFilter<"Hotel"> | string
    country?: StringFilter<"Hotel"> | string
    state?: StringFilter<"Hotel"> | string
    city?: StringFilter<"Hotel"> | string
    locationDescription?: StringFilter<"Hotel"> | string
    locationDescription_esp?: StringFilter<"Hotel"> | string
    images?: StringNullableListFilter<"Hotel">
    videos?: StringNullableListFilter<"Hotel">
    lat?: IntFilter<"Hotel"> | number
    lng?: IntFilter<"Hotel"> | number
    phone?: StringFilter<"Hotel"> | string
    phone_reservation?: StringNullableFilter<"Hotel"> | string | null
    phone_tollfree?: StringNullableFilter<"Hotel"> | string | null
    email?: StringFilter<"Hotel"> | string
    website?: StringFilter<"Hotel"> | string
    facebook?: StringNullableFilter<"Hotel"> | string | null
    tripadvisor?: StringNullableFilter<"Hotel"> | string | null
    instagram?: StringNullableFilter<"Hotel"> | string | null
    youtube?: StringNullableFilter<"Hotel"> | string | null
    whatsapp?: StringNullableFilter<"Hotel"> | string | null
    createdAt?: DateTimeFilter<"Hotel"> | Date | string
    updatedAt?: DateTimeFilter<"Hotel"> | Date | string
    activities?: ActivityListRelationFilter
    tours?: TourListRelationFilter
    spa?: SpaListRelationFilter
    amenities?: AmenitiesListRelationFilter
    tvchannels?: TVChannelsListRelationFilter
  }

  export type HotelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    locationDescription?: SortOrder
    locationDescription_esp?: SortOrder
    images?: SortOrder
    videos?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    phone?: SortOrder
    phone_reservation?: SortOrderInput | SortOrder
    phone_tollfree?: SortOrderInput | SortOrder
    email?: SortOrder
    website?: SortOrder
    facebook?: SortOrderInput | SortOrder
    tripadvisor?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    youtube?: SortOrderInput | SortOrder
    whatsapp?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    activities?: ActivityOrderByRelationAggregateInput
    tours?: TourOrderByRelationAggregateInput
    spa?: SpaOrderByRelationAggregateInput
    amenities?: AmenitiesOrderByRelationAggregateInput
    tvchannels?: TVChannelsOrderByRelationAggregateInput
    _relevance?: HotelOrderByRelevanceInput
  }

  export type HotelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HotelWhereInput | HotelWhereInput[]
    OR?: HotelWhereInput[]
    NOT?: HotelWhereInput | HotelWhereInput[]
    name?: StringFilter<"Hotel"> | string
    description?: StringFilter<"Hotel"> | string
    description_esp?: StringFilter<"Hotel"> | string
    image?: StringFilter<"Hotel"> | string
    country?: StringFilter<"Hotel"> | string
    state?: StringFilter<"Hotel"> | string
    city?: StringFilter<"Hotel"> | string
    locationDescription?: StringFilter<"Hotel"> | string
    locationDescription_esp?: StringFilter<"Hotel"> | string
    images?: StringNullableListFilter<"Hotel">
    videos?: StringNullableListFilter<"Hotel">
    lat?: IntFilter<"Hotel"> | number
    lng?: IntFilter<"Hotel"> | number
    phone?: StringFilter<"Hotel"> | string
    phone_reservation?: StringNullableFilter<"Hotel"> | string | null
    phone_tollfree?: StringNullableFilter<"Hotel"> | string | null
    email?: StringFilter<"Hotel"> | string
    website?: StringFilter<"Hotel"> | string
    facebook?: StringNullableFilter<"Hotel"> | string | null
    tripadvisor?: StringNullableFilter<"Hotel"> | string | null
    instagram?: StringNullableFilter<"Hotel"> | string | null
    youtube?: StringNullableFilter<"Hotel"> | string | null
    whatsapp?: StringNullableFilter<"Hotel"> | string | null
    createdAt?: DateTimeFilter<"Hotel"> | Date | string
    updatedAt?: DateTimeFilter<"Hotel"> | Date | string
    activities?: ActivityListRelationFilter
    tours?: TourListRelationFilter
    spa?: SpaListRelationFilter
    amenities?: AmenitiesListRelationFilter
    tvchannels?: TVChannelsListRelationFilter
  }, "id">

  export type HotelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    locationDescription?: SortOrder
    locationDescription_esp?: SortOrder
    images?: SortOrder
    videos?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    phone?: SortOrder
    phone_reservation?: SortOrderInput | SortOrder
    phone_tollfree?: SortOrderInput | SortOrder
    email?: SortOrder
    website?: SortOrder
    facebook?: SortOrderInput | SortOrder
    tripadvisor?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    youtube?: SortOrderInput | SortOrder
    whatsapp?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HotelCountOrderByAggregateInput
    _avg?: HotelAvgOrderByAggregateInput
    _max?: HotelMaxOrderByAggregateInput
    _min?: HotelMinOrderByAggregateInput
    _sum?: HotelSumOrderByAggregateInput
  }

  export type HotelScalarWhereWithAggregatesInput = {
    AND?: HotelScalarWhereWithAggregatesInput | HotelScalarWhereWithAggregatesInput[]
    OR?: HotelScalarWhereWithAggregatesInput[]
    NOT?: HotelScalarWhereWithAggregatesInput | HotelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Hotel"> | string
    name?: StringWithAggregatesFilter<"Hotel"> | string
    description?: StringWithAggregatesFilter<"Hotel"> | string
    description_esp?: StringWithAggregatesFilter<"Hotel"> | string
    image?: StringWithAggregatesFilter<"Hotel"> | string
    country?: StringWithAggregatesFilter<"Hotel"> | string
    state?: StringWithAggregatesFilter<"Hotel"> | string
    city?: StringWithAggregatesFilter<"Hotel"> | string
    locationDescription?: StringWithAggregatesFilter<"Hotel"> | string
    locationDescription_esp?: StringWithAggregatesFilter<"Hotel"> | string
    images?: StringNullableListFilter<"Hotel">
    videos?: StringNullableListFilter<"Hotel">
    lat?: IntWithAggregatesFilter<"Hotel"> | number
    lng?: IntWithAggregatesFilter<"Hotel"> | number
    phone?: StringWithAggregatesFilter<"Hotel"> | string
    phone_reservation?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    phone_tollfree?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    email?: StringWithAggregatesFilter<"Hotel"> | string
    website?: StringWithAggregatesFilter<"Hotel"> | string
    facebook?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    tripadvisor?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    youtube?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    whatsapp?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Hotel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Hotel"> | Date | string
  }

  export type AmenitiesWhereInput = {
    AND?: AmenitiesWhereInput | AmenitiesWhereInput[]
    OR?: AmenitiesWhereInput[]
    NOT?: AmenitiesWhereInput | AmenitiesWhereInput[]
    id?: StringFilter<"Amenities"> | string
    name?: StringFilter<"Amenities"> | string
    description?: StringFilter<"Amenities"> | string
    icon?: StringFilter<"Amenities"> | string
    image?: StringFilter<"Amenities"> | string
    amenitiestype?: EnumAMENITIESTYPEFilter<"Amenities"> | $Enums.AMENITIESTYPE
    hotelId?: StringFilter<"Amenities"> | string
    createdAt?: DateTimeFilter<"Amenities"> | Date | string
    updatedAt?: DateTimeFilter<"Amenities"> | Date | string
    Hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }

  export type AmenitiesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    image?: SortOrder
    amenitiestype?: SortOrder
    hotelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Hotel?: HotelOrderByWithRelationInput
    _relevance?: AmenitiesOrderByRelevanceInput
  }

  export type AmenitiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AmenitiesWhereInput | AmenitiesWhereInput[]
    OR?: AmenitiesWhereInput[]
    NOT?: AmenitiesWhereInput | AmenitiesWhereInput[]
    name?: StringFilter<"Amenities"> | string
    description?: StringFilter<"Amenities"> | string
    icon?: StringFilter<"Amenities"> | string
    image?: StringFilter<"Amenities"> | string
    amenitiestype?: EnumAMENITIESTYPEFilter<"Amenities"> | $Enums.AMENITIESTYPE
    hotelId?: StringFilter<"Amenities"> | string
    createdAt?: DateTimeFilter<"Amenities"> | Date | string
    updatedAt?: DateTimeFilter<"Amenities"> | Date | string
    Hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }, "id">

  export type AmenitiesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    image?: SortOrder
    amenitiestype?: SortOrder
    hotelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AmenitiesCountOrderByAggregateInput
    _max?: AmenitiesMaxOrderByAggregateInput
    _min?: AmenitiesMinOrderByAggregateInput
  }

  export type AmenitiesScalarWhereWithAggregatesInput = {
    AND?: AmenitiesScalarWhereWithAggregatesInput | AmenitiesScalarWhereWithAggregatesInput[]
    OR?: AmenitiesScalarWhereWithAggregatesInput[]
    NOT?: AmenitiesScalarWhereWithAggregatesInput | AmenitiesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Amenities"> | string
    name?: StringWithAggregatesFilter<"Amenities"> | string
    description?: StringWithAggregatesFilter<"Amenities"> | string
    icon?: StringWithAggregatesFilter<"Amenities"> | string
    image?: StringWithAggregatesFilter<"Amenities"> | string
    amenitiestype?: EnumAMENITIESTYPEWithAggregatesFilter<"Amenities"> | $Enums.AMENITIESTYPE
    hotelId?: StringWithAggregatesFilter<"Amenities"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Amenities"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Amenities"> | Date | string
  }

  export type TourPriceCategoryWhereInput = {
    AND?: TourPriceCategoryWhereInput | TourPriceCategoryWhereInput[]
    OR?: TourPriceCategoryWhereInput[]
    NOT?: TourPriceCategoryWhereInput | TourPriceCategoryWhereInput[]
    id?: StringFilter<"TourPriceCategory"> | string
    sku?: IntFilter<"TourPriceCategory"> | number
    price?: IntFilter<"TourPriceCategory"> | number
    description?: StringFilter<"TourPriceCategory"> | string
    description_esp?: StringFilter<"TourPriceCategory"> | string
    tourId?: StringFilter<"TourPriceCategory"> | string
    createdAt?: DateTimeFilter<"TourPriceCategory"> | Date | string
    updatedAt?: DateTimeFilter<"TourPriceCategory"> | Date | string
    Tour?: XOR<TourNullableScalarRelationFilter, TourWhereInput> | null
  }

  export type TourPriceCategoryOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    tourId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Tour?: TourOrderByWithRelationInput
    _relevance?: TourPriceCategoryOrderByRelevanceInput
  }

  export type TourPriceCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: number
    AND?: TourPriceCategoryWhereInput | TourPriceCategoryWhereInput[]
    OR?: TourPriceCategoryWhereInput[]
    NOT?: TourPriceCategoryWhereInput | TourPriceCategoryWhereInput[]
    price?: IntFilter<"TourPriceCategory"> | number
    description?: StringFilter<"TourPriceCategory"> | string
    description_esp?: StringFilter<"TourPriceCategory"> | string
    tourId?: StringFilter<"TourPriceCategory"> | string
    createdAt?: DateTimeFilter<"TourPriceCategory"> | Date | string
    updatedAt?: DateTimeFilter<"TourPriceCategory"> | Date | string
    Tour?: XOR<TourNullableScalarRelationFilter, TourWhereInput> | null
  }, "id" | "sku">

  export type TourPriceCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    tourId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TourPriceCategoryCountOrderByAggregateInput
    _avg?: TourPriceCategoryAvgOrderByAggregateInput
    _max?: TourPriceCategoryMaxOrderByAggregateInput
    _min?: TourPriceCategoryMinOrderByAggregateInput
    _sum?: TourPriceCategorySumOrderByAggregateInput
  }

  export type TourPriceCategoryScalarWhereWithAggregatesInput = {
    AND?: TourPriceCategoryScalarWhereWithAggregatesInput | TourPriceCategoryScalarWhereWithAggregatesInput[]
    OR?: TourPriceCategoryScalarWhereWithAggregatesInput[]
    NOT?: TourPriceCategoryScalarWhereWithAggregatesInput | TourPriceCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TourPriceCategory"> | string
    sku?: IntWithAggregatesFilter<"TourPriceCategory"> | number
    price?: IntWithAggregatesFilter<"TourPriceCategory"> | number
    description?: StringWithAggregatesFilter<"TourPriceCategory"> | string
    description_esp?: StringWithAggregatesFilter<"TourPriceCategory"> | string
    tourId?: StringWithAggregatesFilter<"TourPriceCategory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TourPriceCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TourPriceCategory"> | Date | string
  }

  export type TourWhereInput = {
    AND?: TourWhereInput | TourWhereInput[]
    OR?: TourWhereInput[]
    NOT?: TourWhereInput | TourWhereInput[]
    id?: StringFilter<"Tour"> | string
    name?: StringFilter<"Tour"> | string
    name_esp?: StringFilter<"Tour"> | string
    description?: StringFilter<"Tour"> | string
    description_esp?: StringFilter<"Tour"> | string
    image?: StringFilter<"Tour"> | string
    hotelId?: StringFilter<"Tour"> | string
    price?: IntFilter<"Tour"> | number
    priceKids?: IntFilter<"Tour"> | number
    category?: StringFilter<"Tour"> | string
    offer?: BoolFilter<"Tour"> | boolean
    discount?: IntFilter<"Tour"> | number
    whattobring?: StringFilter<"Tour"> | string
    included?: StringNullableListFilter<"Tour">
    pickuptime?: DateTimeFilter<"Tour"> | Date | string
    maxPeople?: IntFilter<"Tour"> | number
    minPeople?: IntFilter<"Tour"> | number
    minAge?: IntFilter<"Tour"> | number
    bestSeller?: BoolFilter<"Tour"> | boolean
    priceInfo?: StringFilter<"Tour"> | string
    location?: StringFilter<"Tour"> | string
    offered?: StringNullableListFilter<"Tour">
    duration?: IntFilter<"Tour"> | number
    videos?: StringNullableListFilter<"Tour">
    images?: StringNullableListFilter<"Tour">
    createdAt?: DateTimeFilter<"Tour"> | Date | string
    updatedAt?: DateTimeFilter<"Tour"> | Date | string
    pricecategory?: TourPriceCategoryListRelationFilter
    Hotel?: XOR<HotelScalarRelationFilter, HotelWhereInput>
  }

  export type TourOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    hotelId?: SortOrder
    price?: SortOrder
    priceKids?: SortOrder
    category?: SortOrder
    offer?: SortOrder
    discount?: SortOrder
    whattobring?: SortOrder
    included?: SortOrder
    pickuptime?: SortOrder
    maxPeople?: SortOrder
    minPeople?: SortOrder
    minAge?: SortOrder
    bestSeller?: SortOrder
    priceInfo?: SortOrder
    location?: SortOrder
    offered?: SortOrder
    duration?: SortOrder
    videos?: SortOrder
    images?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pricecategory?: TourPriceCategoryOrderByRelationAggregateInput
    Hotel?: HotelOrderByWithRelationInput
    _relevance?: TourOrderByRelevanceInput
  }

  export type TourWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TourWhereInput | TourWhereInput[]
    OR?: TourWhereInput[]
    NOT?: TourWhereInput | TourWhereInput[]
    name?: StringFilter<"Tour"> | string
    name_esp?: StringFilter<"Tour"> | string
    description?: StringFilter<"Tour"> | string
    description_esp?: StringFilter<"Tour"> | string
    image?: StringFilter<"Tour"> | string
    hotelId?: StringFilter<"Tour"> | string
    price?: IntFilter<"Tour"> | number
    priceKids?: IntFilter<"Tour"> | number
    category?: StringFilter<"Tour"> | string
    offer?: BoolFilter<"Tour"> | boolean
    discount?: IntFilter<"Tour"> | number
    whattobring?: StringFilter<"Tour"> | string
    included?: StringNullableListFilter<"Tour">
    pickuptime?: DateTimeFilter<"Tour"> | Date | string
    maxPeople?: IntFilter<"Tour"> | number
    minPeople?: IntFilter<"Tour"> | number
    minAge?: IntFilter<"Tour"> | number
    bestSeller?: BoolFilter<"Tour"> | boolean
    priceInfo?: StringFilter<"Tour"> | string
    location?: StringFilter<"Tour"> | string
    offered?: StringNullableListFilter<"Tour">
    duration?: IntFilter<"Tour"> | number
    videos?: StringNullableListFilter<"Tour">
    images?: StringNullableListFilter<"Tour">
    createdAt?: DateTimeFilter<"Tour"> | Date | string
    updatedAt?: DateTimeFilter<"Tour"> | Date | string
    pricecategory?: TourPriceCategoryListRelationFilter
    Hotel?: XOR<HotelScalarRelationFilter, HotelWhereInput>
  }, "id">

  export type TourOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    hotelId?: SortOrder
    price?: SortOrder
    priceKids?: SortOrder
    category?: SortOrder
    offer?: SortOrder
    discount?: SortOrder
    whattobring?: SortOrder
    included?: SortOrder
    pickuptime?: SortOrder
    maxPeople?: SortOrder
    minPeople?: SortOrder
    minAge?: SortOrder
    bestSeller?: SortOrder
    priceInfo?: SortOrder
    location?: SortOrder
    offered?: SortOrder
    duration?: SortOrder
    videos?: SortOrder
    images?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TourCountOrderByAggregateInput
    _avg?: TourAvgOrderByAggregateInput
    _max?: TourMaxOrderByAggregateInput
    _min?: TourMinOrderByAggregateInput
    _sum?: TourSumOrderByAggregateInput
  }

  export type TourScalarWhereWithAggregatesInput = {
    AND?: TourScalarWhereWithAggregatesInput | TourScalarWhereWithAggregatesInput[]
    OR?: TourScalarWhereWithAggregatesInput[]
    NOT?: TourScalarWhereWithAggregatesInput | TourScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tour"> | string
    name?: StringWithAggregatesFilter<"Tour"> | string
    name_esp?: StringWithAggregatesFilter<"Tour"> | string
    description?: StringWithAggregatesFilter<"Tour"> | string
    description_esp?: StringWithAggregatesFilter<"Tour"> | string
    image?: StringWithAggregatesFilter<"Tour"> | string
    hotelId?: StringWithAggregatesFilter<"Tour"> | string
    price?: IntWithAggregatesFilter<"Tour"> | number
    priceKids?: IntWithAggregatesFilter<"Tour"> | number
    category?: StringWithAggregatesFilter<"Tour"> | string
    offer?: BoolWithAggregatesFilter<"Tour"> | boolean
    discount?: IntWithAggregatesFilter<"Tour"> | number
    whattobring?: StringWithAggregatesFilter<"Tour"> | string
    included?: StringNullableListFilter<"Tour">
    pickuptime?: DateTimeWithAggregatesFilter<"Tour"> | Date | string
    maxPeople?: IntWithAggregatesFilter<"Tour"> | number
    minPeople?: IntWithAggregatesFilter<"Tour"> | number
    minAge?: IntWithAggregatesFilter<"Tour"> | number
    bestSeller?: BoolWithAggregatesFilter<"Tour"> | boolean
    priceInfo?: StringWithAggregatesFilter<"Tour"> | string
    location?: StringWithAggregatesFilter<"Tour"> | string
    offered?: StringNullableListFilter<"Tour">
    duration?: IntWithAggregatesFilter<"Tour"> | number
    videos?: StringNullableListFilter<"Tour">
    images?: StringNullableListFilter<"Tour">
    createdAt?: DateTimeWithAggregatesFilter<"Tour"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tour"> | Date | string
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    name?: StringFilter<"Activity"> | string
    name_esp?: StringFilter<"Activity"> | string
    description?: StringFilter<"Activity"> | string
    description_esp?: StringFilter<"Activity"> | string
    image?: StringFilter<"Activity"> | string
    profileImage?: StringNullableFilter<"Activity"> | string | null
    hotelId?: StringFilter<"Activity"> | string
    type?: StringFilter<"Activity"> | string
    start?: DateTimeFilter<"Activity"> | Date | string
    end?: DateTimeFilter<"Activity"> | Date | string
    price?: IntFilter<"Activity"> | number
    cashOnly?: BoolFilter<"Activity"> | boolean
    freeOfCharge?: BoolFilter<"Activity"> | boolean
    location?: StringFilter<"Activity"> | string
    isRecurring?: BoolFilter<"Activity"> | boolean
    recurrencePattern?: EnumRECURRINGPATTERNFilter<"Activity"> | $Enums.RECURRINGPATTERN
    recurrenceDays?: StringNullableListFilter<"Activity">
    recurrenceEndDate?: DateTimeFilter<"Activity"> | Date | string
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    Hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    hotelId?: SortOrder
    type?: SortOrder
    start?: SortOrder
    end?: SortOrder
    price?: SortOrder
    cashOnly?: SortOrder
    freeOfCharge?: SortOrder
    location?: SortOrder
    isRecurring?: SortOrder
    recurrencePattern?: SortOrder
    recurrenceDays?: SortOrder
    recurrenceEndDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Hotel?: HotelOrderByWithRelationInput
    _relevance?: ActivityOrderByRelevanceInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    name?: StringFilter<"Activity"> | string
    name_esp?: StringFilter<"Activity"> | string
    description?: StringFilter<"Activity"> | string
    description_esp?: StringFilter<"Activity"> | string
    image?: StringFilter<"Activity"> | string
    profileImage?: StringNullableFilter<"Activity"> | string | null
    hotelId?: StringFilter<"Activity"> | string
    type?: StringFilter<"Activity"> | string
    start?: DateTimeFilter<"Activity"> | Date | string
    end?: DateTimeFilter<"Activity"> | Date | string
    price?: IntFilter<"Activity"> | number
    cashOnly?: BoolFilter<"Activity"> | boolean
    freeOfCharge?: BoolFilter<"Activity"> | boolean
    location?: StringFilter<"Activity"> | string
    isRecurring?: BoolFilter<"Activity"> | boolean
    recurrencePattern?: EnumRECURRINGPATTERNFilter<"Activity"> | $Enums.RECURRINGPATTERN
    recurrenceDays?: StringNullableListFilter<"Activity">
    recurrenceEndDate?: DateTimeFilter<"Activity"> | Date | string
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    Hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    hotelId?: SortOrder
    type?: SortOrder
    start?: SortOrder
    end?: SortOrder
    price?: SortOrder
    cashOnly?: SortOrder
    freeOfCharge?: SortOrder
    location?: SortOrder
    isRecurring?: SortOrder
    recurrencePattern?: SortOrder
    recurrenceDays?: SortOrder
    recurrenceEndDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _avg?: ActivityAvgOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
    _sum?: ActivitySumOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    name?: StringWithAggregatesFilter<"Activity"> | string
    name_esp?: StringWithAggregatesFilter<"Activity"> | string
    description?: StringWithAggregatesFilter<"Activity"> | string
    description_esp?: StringWithAggregatesFilter<"Activity"> | string
    image?: StringWithAggregatesFilter<"Activity"> | string
    profileImage?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    hotelId?: StringWithAggregatesFilter<"Activity"> | string
    type?: StringWithAggregatesFilter<"Activity"> | string
    start?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    end?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    price?: IntWithAggregatesFilter<"Activity"> | number
    cashOnly?: BoolWithAggregatesFilter<"Activity"> | boolean
    freeOfCharge?: BoolWithAggregatesFilter<"Activity"> | boolean
    location?: StringWithAggregatesFilter<"Activity"> | string
    isRecurring?: BoolWithAggregatesFilter<"Activity"> | boolean
    recurrencePattern?: EnumRECURRINGPATTERNWithAggregatesFilter<"Activity"> | $Enums.RECURRINGPATTERN
    recurrenceDays?: StringNullableListFilter<"Activity">
    recurrenceEndDate?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
  }

  export type SpaPriceCategoryWhereInput = {
    AND?: SpaPriceCategoryWhereInput | SpaPriceCategoryWhereInput[]
    OR?: SpaPriceCategoryWhereInput[]
    NOT?: SpaPriceCategoryWhereInput | SpaPriceCategoryWhereInput[]
    id?: StringFilter<"SpaPriceCategory"> | string
    sku?: IntFilter<"SpaPriceCategory"> | number
    price?: IntFilter<"SpaPriceCategory"> | number
    description?: StringFilter<"SpaPriceCategory"> | string
    description_esp?: StringFilter<"SpaPriceCategory"> | string
    duration?: IntFilter<"SpaPriceCategory"> | number
    spaId?: StringFilter<"SpaPriceCategory"> | string
    createdAt?: DateTimeFilter<"SpaPriceCategory"> | Date | string
    updatedAt?: DateTimeFilter<"SpaPriceCategory"> | Date | string
    spa?: XOR<SpaNullableScalarRelationFilter, SpaWhereInput> | null
  }

  export type SpaPriceCategoryOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    duration?: SortOrder
    spaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    spa?: SpaOrderByWithRelationInput
    _relevance?: SpaPriceCategoryOrderByRelevanceInput
  }

  export type SpaPriceCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpaPriceCategoryWhereInput | SpaPriceCategoryWhereInput[]
    OR?: SpaPriceCategoryWhereInput[]
    NOT?: SpaPriceCategoryWhereInput | SpaPriceCategoryWhereInput[]
    sku?: IntFilter<"SpaPriceCategory"> | number
    price?: IntFilter<"SpaPriceCategory"> | number
    description?: StringFilter<"SpaPriceCategory"> | string
    description_esp?: StringFilter<"SpaPriceCategory"> | string
    duration?: IntFilter<"SpaPriceCategory"> | number
    spaId?: StringFilter<"SpaPriceCategory"> | string
    createdAt?: DateTimeFilter<"SpaPriceCategory"> | Date | string
    updatedAt?: DateTimeFilter<"SpaPriceCategory"> | Date | string
    spa?: XOR<SpaNullableScalarRelationFilter, SpaWhereInput> | null
  }, "id">

  export type SpaPriceCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    duration?: SortOrder
    spaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SpaPriceCategoryCountOrderByAggregateInput
    _avg?: SpaPriceCategoryAvgOrderByAggregateInput
    _max?: SpaPriceCategoryMaxOrderByAggregateInput
    _min?: SpaPriceCategoryMinOrderByAggregateInput
    _sum?: SpaPriceCategorySumOrderByAggregateInput
  }

  export type SpaPriceCategoryScalarWhereWithAggregatesInput = {
    AND?: SpaPriceCategoryScalarWhereWithAggregatesInput | SpaPriceCategoryScalarWhereWithAggregatesInput[]
    OR?: SpaPriceCategoryScalarWhereWithAggregatesInput[]
    NOT?: SpaPriceCategoryScalarWhereWithAggregatesInput | SpaPriceCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpaPriceCategory"> | string
    sku?: IntWithAggregatesFilter<"SpaPriceCategory"> | number
    price?: IntWithAggregatesFilter<"SpaPriceCategory"> | number
    description?: StringWithAggregatesFilter<"SpaPriceCategory"> | string
    description_esp?: StringWithAggregatesFilter<"SpaPriceCategory"> | string
    duration?: IntWithAggregatesFilter<"SpaPriceCategory"> | number
    spaId?: StringWithAggregatesFilter<"SpaPriceCategory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SpaPriceCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SpaPriceCategory"> | Date | string
  }

  export type SpaWhereInput = {
    AND?: SpaWhereInput | SpaWhereInput[]
    OR?: SpaWhereInput[]
    NOT?: SpaWhereInput | SpaWhereInput[]
    id?: StringFilter<"Spa"> | string
    name?: StringFilter<"Spa"> | string
    name_esp?: StringFilter<"Spa"> | string
    description?: StringFilter<"Spa"> | string
    description_esp?: StringFilter<"Spa"> | string
    hotelId?: StringFilter<"Spa"> | string
    type?: StringFilter<"Spa"> | string
    videos?: StringNullableListFilter<"Spa">
    images?: StringNullableListFilter<"Spa">
    createdAt?: DateTimeFilter<"Spa"> | Date | string
    updatedAt?: DateTimeFilter<"Spa"> | Date | string
    pricecategory?: SpaPriceCategoryListRelationFilter
    Hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }

  export type SpaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    hotelId?: SortOrder
    type?: SortOrder
    videos?: SortOrder
    images?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pricecategory?: SpaPriceCategoryOrderByRelationAggregateInput
    Hotel?: HotelOrderByWithRelationInput
    _relevance?: SpaOrderByRelevanceInput
  }

  export type SpaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpaWhereInput | SpaWhereInput[]
    OR?: SpaWhereInput[]
    NOT?: SpaWhereInput | SpaWhereInput[]
    name?: StringFilter<"Spa"> | string
    name_esp?: StringFilter<"Spa"> | string
    description?: StringFilter<"Spa"> | string
    description_esp?: StringFilter<"Spa"> | string
    hotelId?: StringFilter<"Spa"> | string
    type?: StringFilter<"Spa"> | string
    videos?: StringNullableListFilter<"Spa">
    images?: StringNullableListFilter<"Spa">
    createdAt?: DateTimeFilter<"Spa"> | Date | string
    updatedAt?: DateTimeFilter<"Spa"> | Date | string
    pricecategory?: SpaPriceCategoryListRelationFilter
    Hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }, "id">

  export type SpaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    hotelId?: SortOrder
    type?: SortOrder
    videos?: SortOrder
    images?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SpaCountOrderByAggregateInput
    _max?: SpaMaxOrderByAggregateInput
    _min?: SpaMinOrderByAggregateInput
  }

  export type SpaScalarWhereWithAggregatesInput = {
    AND?: SpaScalarWhereWithAggregatesInput | SpaScalarWhereWithAggregatesInput[]
    OR?: SpaScalarWhereWithAggregatesInput[]
    NOT?: SpaScalarWhereWithAggregatesInput | SpaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Spa"> | string
    name?: StringWithAggregatesFilter<"Spa"> | string
    name_esp?: StringWithAggregatesFilter<"Spa"> | string
    description?: StringWithAggregatesFilter<"Spa"> | string
    description_esp?: StringWithAggregatesFilter<"Spa"> | string
    hotelId?: StringWithAggregatesFilter<"Spa"> | string
    type?: StringWithAggregatesFilter<"Spa"> | string
    videos?: StringNullableListFilter<"Spa">
    images?: StringNullableListFilter<"Spa">
    createdAt?: DateTimeWithAggregatesFilter<"Spa"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Spa"> | Date | string
  }

  export type TVChannelsWhereInput = {
    AND?: TVChannelsWhereInput | TVChannelsWhereInput[]
    OR?: TVChannelsWhereInput[]
    NOT?: TVChannelsWhereInput | TVChannelsWhereInput[]
    id?: StringFilter<"TVChannels"> | string
    name?: StringFilter<"TVChannels"> | string
    name_esp?: StringNullableFilter<"TVChannels"> | string | null
    description?: StringFilter<"TVChannels"> | string
    description_esp?: StringNullableFilter<"TVChannels"> | string | null
    logo?: StringNullableFilter<"TVChannels"> | string | null
    channelNo?: StringFilter<"TVChannels"> | string
    languages?: EnumTVChannelLanguagesFilter<"TVChannels"> | $Enums.TVChannelLanguages
    channeltype?: EnumTVCHANNELTYPEFilter<"TVChannels"> | $Enums.TVCHANNELTYPE
    category?: StringFilter<"TVChannels"> | string
    hotelId?: StringFilter<"TVChannels"> | string
    createdAt?: DateTimeFilter<"TVChannels"> | Date | string
    updatedAt?: DateTimeFilter<"TVChannels"> | Date | string
    Hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }

  export type TVChannelsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrderInput | SortOrder
    description?: SortOrder
    description_esp?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    channelNo?: SortOrder
    languages?: SortOrder
    channeltype?: SortOrder
    category?: SortOrder
    hotelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Hotel?: HotelOrderByWithRelationInput
    _relevance?: TVChannelsOrderByRelevanceInput
  }

  export type TVChannelsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TVChannelsWhereInput | TVChannelsWhereInput[]
    OR?: TVChannelsWhereInput[]
    NOT?: TVChannelsWhereInput | TVChannelsWhereInput[]
    name?: StringFilter<"TVChannels"> | string
    name_esp?: StringNullableFilter<"TVChannels"> | string | null
    description?: StringFilter<"TVChannels"> | string
    description_esp?: StringNullableFilter<"TVChannels"> | string | null
    logo?: StringNullableFilter<"TVChannels"> | string | null
    channelNo?: StringFilter<"TVChannels"> | string
    languages?: EnumTVChannelLanguagesFilter<"TVChannels"> | $Enums.TVChannelLanguages
    channeltype?: EnumTVCHANNELTYPEFilter<"TVChannels"> | $Enums.TVCHANNELTYPE
    category?: StringFilter<"TVChannels"> | string
    hotelId?: StringFilter<"TVChannels"> | string
    createdAt?: DateTimeFilter<"TVChannels"> | Date | string
    updatedAt?: DateTimeFilter<"TVChannels"> | Date | string
    Hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }, "id">

  export type TVChannelsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrderInput | SortOrder
    description?: SortOrder
    description_esp?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    channelNo?: SortOrder
    languages?: SortOrder
    channeltype?: SortOrder
    category?: SortOrder
    hotelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TVChannelsCountOrderByAggregateInput
    _max?: TVChannelsMaxOrderByAggregateInput
    _min?: TVChannelsMinOrderByAggregateInput
  }

  export type TVChannelsScalarWhereWithAggregatesInput = {
    AND?: TVChannelsScalarWhereWithAggregatesInput | TVChannelsScalarWhereWithAggregatesInput[]
    OR?: TVChannelsScalarWhereWithAggregatesInput[]
    NOT?: TVChannelsScalarWhereWithAggregatesInput | TVChannelsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TVChannels"> | string
    name?: StringWithAggregatesFilter<"TVChannels"> | string
    name_esp?: StringNullableWithAggregatesFilter<"TVChannels"> | string | null
    description?: StringWithAggregatesFilter<"TVChannels"> | string
    description_esp?: StringNullableWithAggregatesFilter<"TVChannels"> | string | null
    logo?: StringNullableWithAggregatesFilter<"TVChannels"> | string | null
    channelNo?: StringWithAggregatesFilter<"TVChannels"> | string
    languages?: EnumTVChannelLanguagesWithAggregatesFilter<"TVChannels"> | $Enums.TVChannelLanguages
    channeltype?: EnumTVCHANNELTYPEWithAggregatesFilter<"TVChannels"> | $Enums.TVCHANNELTYPE
    category?: StringWithAggregatesFilter<"TVChannels"> | string
    hotelId?: StringWithAggregatesFilter<"TVChannels"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TVChannels"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TVChannels"> | Date | string
  }

  export type RestaurantWhereInput = {
    AND?: RestaurantWhereInput | RestaurantWhereInput[]
    OR?: RestaurantWhereInput[]
    NOT?: RestaurantWhereInput | RestaurantWhereInput[]
    id?: StringFilter<"Restaurant"> | string
    name?: StringFilter<"Restaurant"> | string
    description?: StringNullableFilter<"Restaurant"> | string | null
    descriptionshort?: StringNullableFilter<"Restaurant"> | string | null
    description_esp?: StringNullableFilter<"Restaurant"> | string | null
    descriptionshort_esp?: StringNullableFilter<"Restaurant"> | string | null
    image?: StringNullableFilter<"Restaurant"> | string | null
    address?: StringNullableFilter<"Restaurant"> | string | null
    city?: StringNullableFilter<"Restaurant"> | string | null
    state?: StringNullableFilter<"Restaurant"> | string | null
    zipCode?: StringNullableFilter<"Restaurant"> | string | null
    phone?: StringNullableFilter<"Restaurant"> | string | null
    email?: StringNullableFilter<"Restaurant"> | string | null
    website?: StringNullableFilter<"Restaurant"> | string | null
    createdAt?: DateTimeFilter<"Restaurant"> | Date | string
    updatedAt?: DateTimeFilter<"Restaurant"> | Date | string
    listorder?: IntFilter<"Restaurant"> | number
    categories?: CategoryListRelationFilter
    dishes?: DishListRelationFilter
    menus?: MenuListRelationFilter
    tables?: TableListRelationFilter
    reservations?: ReservationListRelationFilter
    openingHours?: OpeningHoursListRelationFilter
  }

  export type RestaurantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    descriptionshort?: SortOrderInput | SortOrder
    description_esp?: SortOrderInput | SortOrder
    descriptionshort_esp?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    listorder?: SortOrder
    categories?: CategoryOrderByRelationAggregateInput
    dishes?: DishOrderByRelationAggregateInput
    menus?: MenuOrderByRelationAggregateInput
    tables?: TableOrderByRelationAggregateInput
    reservations?: ReservationOrderByRelationAggregateInput
    openingHours?: OpeningHoursOrderByRelationAggregateInput
    _relevance?: RestaurantOrderByRelevanceInput
  }

  export type RestaurantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RestaurantWhereInput | RestaurantWhereInput[]
    OR?: RestaurantWhereInput[]
    NOT?: RestaurantWhereInput | RestaurantWhereInput[]
    name?: StringFilter<"Restaurant"> | string
    description?: StringNullableFilter<"Restaurant"> | string | null
    descriptionshort?: StringNullableFilter<"Restaurant"> | string | null
    description_esp?: StringNullableFilter<"Restaurant"> | string | null
    descriptionshort_esp?: StringNullableFilter<"Restaurant"> | string | null
    image?: StringNullableFilter<"Restaurant"> | string | null
    address?: StringNullableFilter<"Restaurant"> | string | null
    city?: StringNullableFilter<"Restaurant"> | string | null
    state?: StringNullableFilter<"Restaurant"> | string | null
    zipCode?: StringNullableFilter<"Restaurant"> | string | null
    phone?: StringNullableFilter<"Restaurant"> | string | null
    email?: StringNullableFilter<"Restaurant"> | string | null
    website?: StringNullableFilter<"Restaurant"> | string | null
    createdAt?: DateTimeFilter<"Restaurant"> | Date | string
    updatedAt?: DateTimeFilter<"Restaurant"> | Date | string
    listorder?: IntFilter<"Restaurant"> | number
    categories?: CategoryListRelationFilter
    dishes?: DishListRelationFilter
    menus?: MenuListRelationFilter
    tables?: TableListRelationFilter
    reservations?: ReservationListRelationFilter
    openingHours?: OpeningHoursListRelationFilter
  }, "id">

  export type RestaurantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    descriptionshort?: SortOrderInput | SortOrder
    description_esp?: SortOrderInput | SortOrder
    descriptionshort_esp?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    listorder?: SortOrder
    _count?: RestaurantCountOrderByAggregateInput
    _avg?: RestaurantAvgOrderByAggregateInput
    _max?: RestaurantMaxOrderByAggregateInput
    _min?: RestaurantMinOrderByAggregateInput
    _sum?: RestaurantSumOrderByAggregateInput
  }

  export type RestaurantScalarWhereWithAggregatesInput = {
    AND?: RestaurantScalarWhereWithAggregatesInput | RestaurantScalarWhereWithAggregatesInput[]
    OR?: RestaurantScalarWhereWithAggregatesInput[]
    NOT?: RestaurantScalarWhereWithAggregatesInput | RestaurantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Restaurant"> | string
    name?: StringWithAggregatesFilter<"Restaurant"> | string
    description?: StringNullableWithAggregatesFilter<"Restaurant"> | string | null
    descriptionshort?: StringNullableWithAggregatesFilter<"Restaurant"> | string | null
    description_esp?: StringNullableWithAggregatesFilter<"Restaurant"> | string | null
    descriptionshort_esp?: StringNullableWithAggregatesFilter<"Restaurant"> | string | null
    image?: StringNullableWithAggregatesFilter<"Restaurant"> | string | null
    address?: StringNullableWithAggregatesFilter<"Restaurant"> | string | null
    city?: StringNullableWithAggregatesFilter<"Restaurant"> | string | null
    state?: StringNullableWithAggregatesFilter<"Restaurant"> | string | null
    zipCode?: StringNullableWithAggregatesFilter<"Restaurant"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Restaurant"> | string | null
    email?: StringNullableWithAggregatesFilter<"Restaurant"> | string | null
    website?: StringNullableWithAggregatesFilter<"Restaurant"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Restaurant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Restaurant"> | Date | string
    listorder?: IntWithAggregatesFilter<"Restaurant"> | number
  }

  export type MenuWhereInput = {
    AND?: MenuWhereInput | MenuWhereInput[]
    OR?: MenuWhereInput[]
    NOT?: MenuWhereInput | MenuWhereInput[]
    id?: StringFilter<"Menu"> | string
    position?: IntFilter<"Menu"> | number
    name?: StringFilter<"Menu"> | string
    name_esp?: StringFilter<"Menu"> | string
    description?: StringNullableFilter<"Menu"> | string | null
    description_esp?: StringNullableFilter<"Menu"> | string | null
    image?: StringNullableFilter<"Menu"> | string | null
    price?: FloatFilter<"Menu"> | number
    restaurantId?: StringFilter<"Menu"> | string
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
    isActive?: BoolFilter<"Menu"> | boolean
    restaurant?: XOR<RestaurantScalarRelationFilter, RestaurantWhereInput>
    dishes?: DishListRelationFilter
  }

  export type MenuOrderByWithRelationInput = {
    id?: SortOrder
    position?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrderInput | SortOrder
    description_esp?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    price?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    restaurant?: RestaurantOrderByWithRelationInput
    dishes?: DishOrderByRelationAggregateInput
    _relevance?: MenuOrderByRelevanceInput
  }

  export type MenuWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    restaurantId_name?: MenuRestaurantIdNameCompoundUniqueInput
    AND?: MenuWhereInput | MenuWhereInput[]
    OR?: MenuWhereInput[]
    NOT?: MenuWhereInput | MenuWhereInput[]
    position?: IntFilter<"Menu"> | number
    name?: StringFilter<"Menu"> | string
    name_esp?: StringFilter<"Menu"> | string
    description?: StringNullableFilter<"Menu"> | string | null
    description_esp?: StringNullableFilter<"Menu"> | string | null
    image?: StringNullableFilter<"Menu"> | string | null
    price?: FloatFilter<"Menu"> | number
    restaurantId?: StringFilter<"Menu"> | string
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
    isActive?: BoolFilter<"Menu"> | boolean
    restaurant?: XOR<RestaurantScalarRelationFilter, RestaurantWhereInput>
    dishes?: DishListRelationFilter
  }, "id" | "restaurantId_name">

  export type MenuOrderByWithAggregationInput = {
    id?: SortOrder
    position?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrderInput | SortOrder
    description_esp?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    price?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    _count?: MenuCountOrderByAggregateInput
    _avg?: MenuAvgOrderByAggregateInput
    _max?: MenuMaxOrderByAggregateInput
    _min?: MenuMinOrderByAggregateInput
    _sum?: MenuSumOrderByAggregateInput
  }

  export type MenuScalarWhereWithAggregatesInput = {
    AND?: MenuScalarWhereWithAggregatesInput | MenuScalarWhereWithAggregatesInput[]
    OR?: MenuScalarWhereWithAggregatesInput[]
    NOT?: MenuScalarWhereWithAggregatesInput | MenuScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Menu"> | string
    position?: IntWithAggregatesFilter<"Menu"> | number
    name?: StringWithAggregatesFilter<"Menu"> | string
    name_esp?: StringWithAggregatesFilter<"Menu"> | string
    description?: StringNullableWithAggregatesFilter<"Menu"> | string | null
    description_esp?: StringNullableWithAggregatesFilter<"Menu"> | string | null
    image?: StringNullableWithAggregatesFilter<"Menu"> | string | null
    price?: FloatWithAggregatesFilter<"Menu"> | number
    restaurantId?: StringWithAggregatesFilter<"Menu"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Menu"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Menu"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Menu"> | boolean
  }

  export type TableWhereInput = {
    AND?: TableWhereInput | TableWhereInput[]
    OR?: TableWhereInput[]
    NOT?: TableWhereInput | TableWhereInput[]
    id?: StringFilter<"Table"> | string
    number?: IntFilter<"Table"> | number
    capacity?: IntFilter<"Table"> | number
    location?: StringNullableFilter<"Table"> | string | null
    isActive?: BoolFilter<"Table"> | boolean
    restaurantId?: StringFilter<"Table"> | string
    createdAt?: DateTimeFilter<"Table"> | Date | string
    updatedAt?: DateTimeFilter<"Table"> | Date | string
    restaurant?: XOR<RestaurantScalarRelationFilter, RestaurantWhereInput>
    reservations?: ReservationListRelationFilter
  }

  export type TableOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    capacity?: SortOrder
    location?: SortOrderInput | SortOrder
    isActive?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    restaurant?: RestaurantOrderByWithRelationInput
    reservations?: ReservationOrderByRelationAggregateInput
    _relevance?: TableOrderByRelevanceInput
  }

  export type TableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    restaurantId_number?: TableRestaurantIdNumberCompoundUniqueInput
    AND?: TableWhereInput | TableWhereInput[]
    OR?: TableWhereInput[]
    NOT?: TableWhereInput | TableWhereInput[]
    number?: IntFilter<"Table"> | number
    capacity?: IntFilter<"Table"> | number
    location?: StringNullableFilter<"Table"> | string | null
    isActive?: BoolFilter<"Table"> | boolean
    restaurantId?: StringFilter<"Table"> | string
    createdAt?: DateTimeFilter<"Table"> | Date | string
    updatedAt?: DateTimeFilter<"Table"> | Date | string
    restaurant?: XOR<RestaurantScalarRelationFilter, RestaurantWhereInput>
    reservations?: ReservationListRelationFilter
  }, "id" | "restaurantId_number">

  export type TableOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    capacity?: SortOrder
    location?: SortOrderInput | SortOrder
    isActive?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TableCountOrderByAggregateInput
    _avg?: TableAvgOrderByAggregateInput
    _max?: TableMaxOrderByAggregateInput
    _min?: TableMinOrderByAggregateInput
    _sum?: TableSumOrderByAggregateInput
  }

  export type TableScalarWhereWithAggregatesInput = {
    AND?: TableScalarWhereWithAggregatesInput | TableScalarWhereWithAggregatesInput[]
    OR?: TableScalarWhereWithAggregatesInput[]
    NOT?: TableScalarWhereWithAggregatesInput | TableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Table"> | string
    number?: IntWithAggregatesFilter<"Table"> | number
    capacity?: IntWithAggregatesFilter<"Table"> | number
    location?: StringNullableWithAggregatesFilter<"Table"> | string | null
    isActive?: BoolWithAggregatesFilter<"Table"> | boolean
    restaurantId?: StringWithAggregatesFilter<"Table"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Table"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Table"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    email?: StringFilter<"Customer"> | string
    phone?: StringFilter<"Customer"> | string
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    reservations?: ReservationListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reservations?: ReservationOrderByRelationAggregateInput
    _relevance?: CustomerOrderByRelevanceInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    phone?: StringFilter<"Customer"> | string
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    reservations?: ReservationListRelationFilter
  }, "id" | "email">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    email?: StringWithAggregatesFilter<"Customer"> | string
    phone?: StringWithAggregatesFilter<"Customer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type ReservationWhereInput = {
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    id?: StringFilter<"Reservation"> | string
    date?: DateTimeFilter<"Reservation"> | Date | string
    startTime?: DateTimeFilter<"Reservation"> | Date | string
    endTime?: DateTimeFilter<"Reservation"> | Date | string
    partySize?: IntFilter<"Reservation"> | number
    status?: EnumReservationStatusFilter<"Reservation"> | $Enums.ReservationStatus
    notes?: StringNullableFilter<"Reservation"> | string | null
    customerId?: StringFilter<"Reservation"> | string
    tableId?: StringNullableFilter<"Reservation"> | string | null
    restaurantId?: StringFilter<"Reservation"> | string
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeFilter<"Reservation"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    table?: XOR<TableNullableScalarRelationFilter, TableWhereInput> | null
    restaurant?: XOR<RestaurantScalarRelationFilter, RestaurantWhereInput>
  }

  export type ReservationOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    partySize?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    customerId?: SortOrder
    tableId?: SortOrderInput | SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    table?: TableOrderByWithRelationInput
    restaurant?: RestaurantOrderByWithRelationInput
    _relevance?: ReservationOrderByRelevanceInput
  }

  export type ReservationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    date?: DateTimeFilter<"Reservation"> | Date | string
    startTime?: DateTimeFilter<"Reservation"> | Date | string
    endTime?: DateTimeFilter<"Reservation"> | Date | string
    partySize?: IntFilter<"Reservation"> | number
    status?: EnumReservationStatusFilter<"Reservation"> | $Enums.ReservationStatus
    notes?: StringNullableFilter<"Reservation"> | string | null
    customerId?: StringFilter<"Reservation"> | string
    tableId?: StringNullableFilter<"Reservation"> | string | null
    restaurantId?: StringFilter<"Reservation"> | string
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeFilter<"Reservation"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    table?: XOR<TableNullableScalarRelationFilter, TableWhereInput> | null
    restaurant?: XOR<RestaurantScalarRelationFilter, RestaurantWhereInput>
  }, "id">

  export type ReservationOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    partySize?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    customerId?: SortOrder
    tableId?: SortOrderInput | SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReservationCountOrderByAggregateInput
    _avg?: ReservationAvgOrderByAggregateInput
    _max?: ReservationMaxOrderByAggregateInput
    _min?: ReservationMinOrderByAggregateInput
    _sum?: ReservationSumOrderByAggregateInput
  }

  export type ReservationScalarWhereWithAggregatesInput = {
    AND?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    OR?: ReservationScalarWhereWithAggregatesInput[]
    NOT?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reservation"> | string
    date?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    startTime?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    partySize?: IntWithAggregatesFilter<"Reservation"> | number
    status?: EnumReservationStatusWithAggregatesFilter<"Reservation"> | $Enums.ReservationStatus
    notes?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    customerId?: StringWithAggregatesFilter<"Reservation"> | string
    tableId?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    restaurantId?: StringWithAggregatesFilter<"Reservation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    name_esp?: StringNullableFilter<"Category"> | string | null
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    description_esp?: StringNullableFilter<"Category"> | string | null
    image?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    restaurantId?: StringFilter<"Category"> | string
    postition?: IntFilter<"Category"> | number
    restaurant?: XOR<RestaurantScalarRelationFilter, RestaurantWhereInput>
    dishes?: DishListRelationFilter
    subcategories?: SubcategoryListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrderInput | SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    description_esp?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    restaurantId?: SortOrder
    postition?: SortOrder
    restaurant?: RestaurantOrderByWithRelationInput
    dishes?: DishOrderByRelationAggregateInput
    subcategories?: SubcategoryOrderByRelationAggregateInput
    _relevance?: CategoryOrderByRelevanceInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    restaurantId_slug?: CategoryRestaurantIdSlugCompoundUniqueInput
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    name_esp?: StringNullableFilter<"Category"> | string | null
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    description_esp?: StringNullableFilter<"Category"> | string | null
    image?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    restaurantId?: StringFilter<"Category"> | string
    postition?: IntFilter<"Category"> | number
    restaurant?: XOR<RestaurantScalarRelationFilter, RestaurantWhereInput>
    dishes?: DishListRelationFilter
    subcategories?: SubcategoryListRelationFilter
  }, "id" | "restaurantId_slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrderInput | SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    description_esp?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    restaurantId?: SortOrder
    postition?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    name_esp?: StringNullableWithAggregatesFilter<"Category"> | string | null
    slug?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    description_esp?: StringNullableWithAggregatesFilter<"Category"> | string | null
    image?: StringNullableWithAggregatesFilter<"Category"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    restaurantId?: StringWithAggregatesFilter<"Category"> | string
    postition?: IntWithAggregatesFilter<"Category"> | number
  }

  export type SubcategoryWhereInput = {
    AND?: SubcategoryWhereInput | SubcategoryWhereInput[]
    OR?: SubcategoryWhereInput[]
    NOT?: SubcategoryWhereInput | SubcategoryWhereInput[]
    id?: StringFilter<"Subcategory"> | string
    name?: StringFilter<"Subcategory"> | string
    name_esp?: StringNullableFilter<"Subcategory"> | string | null
    slug?: StringFilter<"Subcategory"> | string
    description?: StringNullableFilter<"Subcategory"> | string | null
    description_esp?: StringNullableFilter<"Subcategory"> | string | null
    image?: StringNullableFilter<"Subcategory"> | string | null
    createdAt?: DateTimeFilter<"Subcategory"> | Date | string
    updatedAt?: DateTimeFilter<"Subcategory"> | Date | string
    parentCategoryId?: StringFilter<"Subcategory"> | string
    postition?: IntFilter<"Subcategory"> | number
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    dishes?: DishListRelationFilter
    subSubcategories?: SubSubcategoryListRelationFilter
  }

  export type SubcategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrderInput | SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    description_esp?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentCategoryId?: SortOrder
    postition?: SortOrder
    category?: CategoryOrderByWithRelationInput
    dishes?: DishOrderByRelationAggregateInput
    subSubcategories?: SubSubcategoryOrderByRelationAggregateInput
    _relevance?: SubcategoryOrderByRelevanceInput
  }

  export type SubcategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    parentCategoryId_slug?: SubcategoryParentCategoryIdSlugCompoundUniqueInput
    AND?: SubcategoryWhereInput | SubcategoryWhereInput[]
    OR?: SubcategoryWhereInput[]
    NOT?: SubcategoryWhereInput | SubcategoryWhereInput[]
    name?: StringFilter<"Subcategory"> | string
    name_esp?: StringNullableFilter<"Subcategory"> | string | null
    slug?: StringFilter<"Subcategory"> | string
    description?: StringNullableFilter<"Subcategory"> | string | null
    description_esp?: StringNullableFilter<"Subcategory"> | string | null
    image?: StringNullableFilter<"Subcategory"> | string | null
    createdAt?: DateTimeFilter<"Subcategory"> | Date | string
    updatedAt?: DateTimeFilter<"Subcategory"> | Date | string
    parentCategoryId?: StringFilter<"Subcategory"> | string
    postition?: IntFilter<"Subcategory"> | number
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    dishes?: DishListRelationFilter
    subSubcategories?: SubSubcategoryListRelationFilter
  }, "id" | "parentCategoryId_slug">

  export type SubcategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrderInput | SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    description_esp?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentCategoryId?: SortOrder
    postition?: SortOrder
    _count?: SubcategoryCountOrderByAggregateInput
    _avg?: SubcategoryAvgOrderByAggregateInput
    _max?: SubcategoryMaxOrderByAggregateInput
    _min?: SubcategoryMinOrderByAggregateInput
    _sum?: SubcategorySumOrderByAggregateInput
  }

  export type SubcategoryScalarWhereWithAggregatesInput = {
    AND?: SubcategoryScalarWhereWithAggregatesInput | SubcategoryScalarWhereWithAggregatesInput[]
    OR?: SubcategoryScalarWhereWithAggregatesInput[]
    NOT?: SubcategoryScalarWhereWithAggregatesInput | SubcategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subcategory"> | string
    name?: StringWithAggregatesFilter<"Subcategory"> | string
    name_esp?: StringNullableWithAggregatesFilter<"Subcategory"> | string | null
    slug?: StringWithAggregatesFilter<"Subcategory"> | string
    description?: StringNullableWithAggregatesFilter<"Subcategory"> | string | null
    description_esp?: StringNullableWithAggregatesFilter<"Subcategory"> | string | null
    image?: StringNullableWithAggregatesFilter<"Subcategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subcategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subcategory"> | Date | string
    parentCategoryId?: StringWithAggregatesFilter<"Subcategory"> | string
    postition?: IntWithAggregatesFilter<"Subcategory"> | number
  }

  export type SubSubcategoryWhereInput = {
    AND?: SubSubcategoryWhereInput | SubSubcategoryWhereInput[]
    OR?: SubSubcategoryWhereInput[]
    NOT?: SubSubcategoryWhereInput | SubSubcategoryWhereInput[]
    id?: StringFilter<"SubSubcategory"> | string
    name?: StringFilter<"SubSubcategory"> | string
    name_esp?: StringNullableFilter<"SubSubcategory"> | string | null
    slug?: StringFilter<"SubSubcategory"> | string
    description?: StringNullableFilter<"SubSubcategory"> | string | null
    description_esp?: StringNullableFilter<"SubSubcategory"> | string | null
    image?: StringNullableFilter<"SubSubcategory"> | string | null
    createdAt?: DateTimeFilter<"SubSubcategory"> | Date | string
    updatedAt?: DateTimeFilter<"SubSubcategory"> | Date | string
    parentSubcategoryId?: StringFilter<"SubSubcategory"> | string
    postition?: IntFilter<"SubSubcategory"> | number
    subcategory?: XOR<SubcategoryScalarRelationFilter, SubcategoryWhereInput>
    dishes?: DishListRelationFilter
  }

  export type SubSubcategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrderInput | SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    description_esp?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentSubcategoryId?: SortOrder
    postition?: SortOrder
    subcategory?: SubcategoryOrderByWithRelationInput
    dishes?: DishOrderByRelationAggregateInput
    _relevance?: SubSubcategoryOrderByRelevanceInput
  }

  export type SubSubcategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    parentSubcategoryId_slug?: SubSubcategoryParentSubcategoryIdSlugCompoundUniqueInput
    AND?: SubSubcategoryWhereInput | SubSubcategoryWhereInput[]
    OR?: SubSubcategoryWhereInput[]
    NOT?: SubSubcategoryWhereInput | SubSubcategoryWhereInput[]
    name?: StringFilter<"SubSubcategory"> | string
    name_esp?: StringNullableFilter<"SubSubcategory"> | string | null
    slug?: StringFilter<"SubSubcategory"> | string
    description?: StringNullableFilter<"SubSubcategory"> | string | null
    description_esp?: StringNullableFilter<"SubSubcategory"> | string | null
    image?: StringNullableFilter<"SubSubcategory"> | string | null
    createdAt?: DateTimeFilter<"SubSubcategory"> | Date | string
    updatedAt?: DateTimeFilter<"SubSubcategory"> | Date | string
    parentSubcategoryId?: StringFilter<"SubSubcategory"> | string
    postition?: IntFilter<"SubSubcategory"> | number
    subcategory?: XOR<SubcategoryScalarRelationFilter, SubcategoryWhereInput>
    dishes?: DishListRelationFilter
  }, "id" | "parentSubcategoryId_slug">

  export type SubSubcategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrderInput | SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    description_esp?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentSubcategoryId?: SortOrder
    postition?: SortOrder
    _count?: SubSubcategoryCountOrderByAggregateInput
    _avg?: SubSubcategoryAvgOrderByAggregateInput
    _max?: SubSubcategoryMaxOrderByAggregateInput
    _min?: SubSubcategoryMinOrderByAggregateInput
    _sum?: SubSubcategorySumOrderByAggregateInput
  }

  export type SubSubcategoryScalarWhereWithAggregatesInput = {
    AND?: SubSubcategoryScalarWhereWithAggregatesInput | SubSubcategoryScalarWhereWithAggregatesInput[]
    OR?: SubSubcategoryScalarWhereWithAggregatesInput[]
    NOT?: SubSubcategoryScalarWhereWithAggregatesInput | SubSubcategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubSubcategory"> | string
    name?: StringWithAggregatesFilter<"SubSubcategory"> | string
    name_esp?: StringNullableWithAggregatesFilter<"SubSubcategory"> | string | null
    slug?: StringWithAggregatesFilter<"SubSubcategory"> | string
    description?: StringNullableWithAggregatesFilter<"SubSubcategory"> | string | null
    description_esp?: StringNullableWithAggregatesFilter<"SubSubcategory"> | string | null
    image?: StringNullableWithAggregatesFilter<"SubSubcategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SubSubcategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubSubcategory"> | Date | string
    parentSubcategoryId?: StringWithAggregatesFilter<"SubSubcategory"> | string
    postition?: IntWithAggregatesFilter<"SubSubcategory"> | number
  }

  export type DishWhereInput = {
    AND?: DishWhereInput | DishWhereInput[]
    OR?: DishWhereInput[]
    NOT?: DishWhereInput | DishWhereInput[]
    id?: StringFilter<"Dish"> | string
    sku?: IntFilter<"Dish"> | number
    name?: StringFilter<"Dish"> | string
    name_esp?: StringFilter<"Dish"> | string
    description?: StringFilter<"Dish"> | string
    description_esp?: StringFilter<"Dish"> | string
    price?: FloatFilter<"Dish"> | number
    unit?: StringNullableFilter<"Dish"> | string | null
    image?: StringNullableFilter<"Dish"> | string | null
    createdAt?: DateTimeFilter<"Dish"> | Date | string
    updatedAt?: DateTimeFilter<"Dish"> | Date | string
    restaurantId?: StringFilter<"Dish"> | string
    categoryId?: StringFilter<"Dish"> | string
    subcategoryId?: StringNullableFilter<"Dish"> | string | null
    subSubcategoryId?: StringNullableFilter<"Dish"> | string | null
    availableAtDayOfWeek?: IntFilter<"Dish"> | number
    dietaryInfo?: StringNullableListFilter<"Dish">
    allergens?: StringNullableListFilter<"Dish">
    ingredients?: StringNullableListFilter<"Dish">
    prepTime?: IntNullableFilter<"Dish"> | number | null
    isPopular?: BoolFilter<"Dish"> | boolean
    isNew?: BoolFilter<"Dish"> | boolean
    menuId?: StringNullableFilter<"Dish"> | string | null
    course_number?: IntFilter<"Dish"> | number
    restaurant?: XOR<RestaurantScalarRelationFilter, RestaurantWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    subcategory?: XOR<SubcategoryNullableScalarRelationFilter, SubcategoryWhereInput> | null
    subSubcategory?: XOR<SubSubcategoryNullableScalarRelationFilter, SubSubcategoryWhereInput> | null
    menu?: XOR<MenuNullableScalarRelationFilter, MenuWhereInput> | null
  }

  export type DishOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    price?: SortOrder
    unit?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    restaurantId?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrderInput | SortOrder
    subSubcategoryId?: SortOrderInput | SortOrder
    availableAtDayOfWeek?: SortOrder
    dietaryInfo?: SortOrder
    allergens?: SortOrder
    ingredients?: SortOrder
    prepTime?: SortOrderInput | SortOrder
    isPopular?: SortOrder
    isNew?: SortOrder
    menuId?: SortOrderInput | SortOrder
    course_number?: SortOrder
    restaurant?: RestaurantOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    subcategory?: SubcategoryOrderByWithRelationInput
    subSubcategory?: SubSubcategoryOrderByWithRelationInput
    menu?: MenuOrderByWithRelationInput
    _relevance?: DishOrderByRelevanceInput
  }

  export type DishWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: number
    AND?: DishWhereInput | DishWhereInput[]
    OR?: DishWhereInput[]
    NOT?: DishWhereInput | DishWhereInput[]
    name?: StringFilter<"Dish"> | string
    name_esp?: StringFilter<"Dish"> | string
    description?: StringFilter<"Dish"> | string
    description_esp?: StringFilter<"Dish"> | string
    price?: FloatFilter<"Dish"> | number
    unit?: StringNullableFilter<"Dish"> | string | null
    image?: StringNullableFilter<"Dish"> | string | null
    createdAt?: DateTimeFilter<"Dish"> | Date | string
    updatedAt?: DateTimeFilter<"Dish"> | Date | string
    restaurantId?: StringFilter<"Dish"> | string
    categoryId?: StringFilter<"Dish"> | string
    subcategoryId?: StringNullableFilter<"Dish"> | string | null
    subSubcategoryId?: StringNullableFilter<"Dish"> | string | null
    availableAtDayOfWeek?: IntFilter<"Dish"> | number
    dietaryInfo?: StringNullableListFilter<"Dish">
    allergens?: StringNullableListFilter<"Dish">
    ingredients?: StringNullableListFilter<"Dish">
    prepTime?: IntNullableFilter<"Dish"> | number | null
    isPopular?: BoolFilter<"Dish"> | boolean
    isNew?: BoolFilter<"Dish"> | boolean
    menuId?: StringNullableFilter<"Dish"> | string | null
    course_number?: IntFilter<"Dish"> | number
    restaurant?: XOR<RestaurantScalarRelationFilter, RestaurantWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    subcategory?: XOR<SubcategoryNullableScalarRelationFilter, SubcategoryWhereInput> | null
    subSubcategory?: XOR<SubSubcategoryNullableScalarRelationFilter, SubSubcategoryWhereInput> | null
    menu?: XOR<MenuNullableScalarRelationFilter, MenuWhereInput> | null
  }, "id" | "sku">

  export type DishOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    price?: SortOrder
    unit?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    restaurantId?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrderInput | SortOrder
    subSubcategoryId?: SortOrderInput | SortOrder
    availableAtDayOfWeek?: SortOrder
    dietaryInfo?: SortOrder
    allergens?: SortOrder
    ingredients?: SortOrder
    prepTime?: SortOrderInput | SortOrder
    isPopular?: SortOrder
    isNew?: SortOrder
    menuId?: SortOrderInput | SortOrder
    course_number?: SortOrder
    _count?: DishCountOrderByAggregateInput
    _avg?: DishAvgOrderByAggregateInput
    _max?: DishMaxOrderByAggregateInput
    _min?: DishMinOrderByAggregateInput
    _sum?: DishSumOrderByAggregateInput
  }

  export type DishScalarWhereWithAggregatesInput = {
    AND?: DishScalarWhereWithAggregatesInput | DishScalarWhereWithAggregatesInput[]
    OR?: DishScalarWhereWithAggregatesInput[]
    NOT?: DishScalarWhereWithAggregatesInput | DishScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Dish"> | string
    sku?: IntWithAggregatesFilter<"Dish"> | number
    name?: StringWithAggregatesFilter<"Dish"> | string
    name_esp?: StringWithAggregatesFilter<"Dish"> | string
    description?: StringWithAggregatesFilter<"Dish"> | string
    description_esp?: StringWithAggregatesFilter<"Dish"> | string
    price?: FloatWithAggregatesFilter<"Dish"> | number
    unit?: StringNullableWithAggregatesFilter<"Dish"> | string | null
    image?: StringNullableWithAggregatesFilter<"Dish"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Dish"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Dish"> | Date | string
    restaurantId?: StringWithAggregatesFilter<"Dish"> | string
    categoryId?: StringWithAggregatesFilter<"Dish"> | string
    subcategoryId?: StringNullableWithAggregatesFilter<"Dish"> | string | null
    subSubcategoryId?: StringNullableWithAggregatesFilter<"Dish"> | string | null
    availableAtDayOfWeek?: IntWithAggregatesFilter<"Dish"> | number
    dietaryInfo?: StringNullableListFilter<"Dish">
    allergens?: StringNullableListFilter<"Dish">
    ingredients?: StringNullableListFilter<"Dish">
    prepTime?: IntNullableWithAggregatesFilter<"Dish"> | number | null
    isPopular?: BoolWithAggregatesFilter<"Dish"> | boolean
    isNew?: BoolWithAggregatesFilter<"Dish"> | boolean
    menuId?: StringNullableWithAggregatesFilter<"Dish"> | string | null
    course_number?: IntWithAggregatesFilter<"Dish"> | number
  }

  export type OpeningHoursWhereInput = {
    AND?: OpeningHoursWhereInput | OpeningHoursWhereInput[]
    OR?: OpeningHoursWhereInput[]
    NOT?: OpeningHoursWhereInput | OpeningHoursWhereInput[]
    id?: StringFilter<"OpeningHours"> | string
    dayOfWeek?: IntFilter<"OpeningHours"> | number
    openTime?: StringFilter<"OpeningHours"> | string
    closeTime?: StringFilter<"OpeningHours"> | string
    isClosed?: BoolFilter<"OpeningHours"> | boolean
    restaurantId?: StringFilter<"OpeningHours"> | string
    restaurant?: XOR<RestaurantScalarRelationFilter, RestaurantWhereInput>
  }

  export type OpeningHoursOrderByWithRelationInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    isClosed?: SortOrder
    restaurantId?: SortOrder
    restaurant?: RestaurantOrderByWithRelationInput
    _relevance?: OpeningHoursOrderByRelevanceInput
  }

  export type OpeningHoursWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    restaurantId_dayOfWeek?: OpeningHoursRestaurantIdDayOfWeekCompoundUniqueInput
    AND?: OpeningHoursWhereInput | OpeningHoursWhereInput[]
    OR?: OpeningHoursWhereInput[]
    NOT?: OpeningHoursWhereInput | OpeningHoursWhereInput[]
    dayOfWeek?: IntFilter<"OpeningHours"> | number
    openTime?: StringFilter<"OpeningHours"> | string
    closeTime?: StringFilter<"OpeningHours"> | string
    isClosed?: BoolFilter<"OpeningHours"> | boolean
    restaurantId?: StringFilter<"OpeningHours"> | string
    restaurant?: XOR<RestaurantScalarRelationFilter, RestaurantWhereInput>
  }, "id" | "restaurantId_dayOfWeek">

  export type OpeningHoursOrderByWithAggregationInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    isClosed?: SortOrder
    restaurantId?: SortOrder
    _count?: OpeningHoursCountOrderByAggregateInput
    _avg?: OpeningHoursAvgOrderByAggregateInput
    _max?: OpeningHoursMaxOrderByAggregateInput
    _min?: OpeningHoursMinOrderByAggregateInput
    _sum?: OpeningHoursSumOrderByAggregateInput
  }

  export type OpeningHoursScalarWhereWithAggregatesInput = {
    AND?: OpeningHoursScalarWhereWithAggregatesInput | OpeningHoursScalarWhereWithAggregatesInput[]
    OR?: OpeningHoursScalarWhereWithAggregatesInput[]
    NOT?: OpeningHoursScalarWhereWithAggregatesInput | OpeningHoursScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OpeningHours"> | string
    dayOfWeek?: IntWithAggregatesFilter<"OpeningHours"> | number
    openTime?: StringWithAggregatesFilter<"OpeningHours"> | string
    closeTime?: StringWithAggregatesFilter<"OpeningHours"> | string
    isClosed?: BoolWithAggregatesFilter<"OpeningHours"> | boolean
    restaurantId?: StringWithAggregatesFilter<"OpeningHours"> | string
  }

  export type HotelCreateInput = {
    id?: string
    name: string
    description: string
    description_esp: string
    image: string
    country: string
    state: string
    city: string
    locationDescription: string
    locationDescription_esp: string
    images?: HotelCreateimagesInput | string[]
    videos?: HotelCreatevideosInput | string[]
    lat: number
    lng: number
    phone: string
    phone_reservation?: string | null
    phone_tollfree?: string | null
    email: string
    website?: string
    facebook?: string | null
    tripadvisor?: string | null
    instagram?: string | null
    youtube?: string | null
    whatsapp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutHotelInput
    tours?: TourCreateNestedManyWithoutHotelInput
    spa?: SpaCreateNestedManyWithoutHotelInput
    amenities?: AmenitiesCreateNestedManyWithoutHotelInput
    tvchannels?: TVChannelsCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    description_esp: string
    image: string
    country: string
    state: string
    city: string
    locationDescription: string
    locationDescription_esp: string
    images?: HotelCreateimagesInput | string[]
    videos?: HotelCreatevideosInput | string[]
    lat: number
    lng: number
    phone: string
    phone_reservation?: string | null
    phone_tollfree?: string | null
    email: string
    website?: string
    facebook?: string | null
    tripadvisor?: string | null
    instagram?: string | null
    youtube?: string | null
    whatsapp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutHotelInput
    tours?: TourUncheckedCreateNestedManyWithoutHotelInput
    spa?: SpaUncheckedCreateNestedManyWithoutHotelInput
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutHotelInput
    tvchannels?: TVChannelsUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    locationDescription?: StringFieldUpdateOperationsInput | string
    locationDescription_esp?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    videos?: HotelUpdatevideosInput | string[]
    lat?: IntFieldUpdateOperationsInput | number
    lng?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    phone_reservation?: NullableStringFieldUpdateOperationsInput | string | null
    phone_tollfree?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tripadvisor?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutHotelNestedInput
    tours?: TourUpdateManyWithoutHotelNestedInput
    spa?: SpaUpdateManyWithoutHotelNestedInput
    amenities?: AmenitiesUpdateManyWithoutHotelNestedInput
    tvchannels?: TVChannelsUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    locationDescription?: StringFieldUpdateOperationsInput | string
    locationDescription_esp?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    videos?: HotelUpdatevideosInput | string[]
    lat?: IntFieldUpdateOperationsInput | number
    lng?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    phone_reservation?: NullableStringFieldUpdateOperationsInput | string | null
    phone_tollfree?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tripadvisor?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutHotelNestedInput
    tours?: TourUncheckedUpdateManyWithoutHotelNestedInput
    spa?: SpaUncheckedUpdateManyWithoutHotelNestedInput
    amenities?: AmenitiesUncheckedUpdateManyWithoutHotelNestedInput
    tvchannels?: TVChannelsUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type HotelCreateManyInput = {
    id?: string
    name: string
    description: string
    description_esp: string
    image: string
    country: string
    state: string
    city: string
    locationDescription: string
    locationDescription_esp: string
    images?: HotelCreateimagesInput | string[]
    videos?: HotelCreatevideosInput | string[]
    lat: number
    lng: number
    phone: string
    phone_reservation?: string | null
    phone_tollfree?: string | null
    email: string
    website?: string
    facebook?: string | null
    tripadvisor?: string | null
    instagram?: string | null
    youtube?: string | null
    whatsapp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    locationDescription?: StringFieldUpdateOperationsInput | string
    locationDescription_esp?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    videos?: HotelUpdatevideosInput | string[]
    lat?: IntFieldUpdateOperationsInput | number
    lng?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    phone_reservation?: NullableStringFieldUpdateOperationsInput | string | null
    phone_tollfree?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tripadvisor?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    locationDescription?: StringFieldUpdateOperationsInput | string
    locationDescription_esp?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    videos?: HotelUpdatevideosInput | string[]
    lat?: IntFieldUpdateOperationsInput | number
    lng?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    phone_reservation?: NullableStringFieldUpdateOperationsInput | string | null
    phone_tollfree?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tripadvisor?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenitiesCreateInput = {
    id?: string
    name: string
    description?: string
    icon?: string
    image?: string
    amenitiestype: $Enums.AMENITIESTYPE
    createdAt?: Date | string
    updatedAt?: Date | string
    Hotel?: HotelCreateNestedOneWithoutAmenitiesInput
  }

  export type AmenitiesUncheckedCreateInput = {
    id?: string
    name: string
    description?: string
    icon?: string
    image?: string
    amenitiestype: $Enums.AMENITIESTYPE
    hotelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenitiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    amenitiestype?: EnumAMENITIESTYPEFieldUpdateOperationsInput | $Enums.AMENITIESTYPE
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hotel?: HotelUpdateOneWithoutAmenitiesNestedInput
  }

  export type AmenitiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    amenitiestype?: EnumAMENITIESTYPEFieldUpdateOperationsInput | $Enums.AMENITIESTYPE
    hotelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenitiesCreateManyInput = {
    id?: string
    name: string
    description?: string
    icon?: string
    image?: string
    amenitiestype: $Enums.AMENITIESTYPE
    hotelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenitiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    amenitiestype?: EnumAMENITIESTYPEFieldUpdateOperationsInput | $Enums.AMENITIESTYPE
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenitiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    amenitiestype?: EnumAMENITIESTYPEFieldUpdateOperationsInput | $Enums.AMENITIESTYPE
    hotelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourPriceCategoryCreateInput = {
    id?: string
    sku: number
    price: number
    description?: string
    description_esp?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Tour?: TourCreateNestedOneWithoutPricecategoryInput
  }

  export type TourPriceCategoryUncheckedCreateInput = {
    id?: string
    sku: number
    price: number
    description?: string
    description_esp?: string
    tourId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourPriceCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Tour?: TourUpdateOneWithoutPricecategoryNestedInput
  }

  export type TourPriceCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    tourId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourPriceCategoryCreateManyInput = {
    id?: string
    sku: number
    price: number
    description?: string
    description_esp?: string
    tourId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourPriceCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourPriceCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    tourId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourCreateInput = {
    id?: string
    name?: string
    name_esp?: string
    description?: string
    description_esp?: string
    image?: string
    price: number
    priceKids?: number
    category?: string
    offer?: boolean
    discount?: number
    whattobring?: string
    included?: TourCreateincludedInput | string[]
    pickuptime: Date | string
    maxPeople?: number
    minPeople?: number
    minAge?: number
    bestSeller?: boolean
    priceInfo?: string
    location?: string
    offered?: TourCreateofferedInput | string[]
    duration?: number
    videos?: TourCreatevideosInput | string[]
    images?: TourCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    pricecategory?: TourPriceCategoryCreateNestedManyWithoutTourInput
    Hotel?: HotelCreateNestedOneWithoutToursInput
  }

  export type TourUncheckedCreateInput = {
    id?: string
    name?: string
    name_esp?: string
    description?: string
    description_esp?: string
    image?: string
    hotelId?: string
    price: number
    priceKids?: number
    category?: string
    offer?: boolean
    discount?: number
    whattobring?: string
    included?: TourCreateincludedInput | string[]
    pickuptime: Date | string
    maxPeople?: number
    minPeople?: number
    minAge?: number
    bestSeller?: boolean
    priceInfo?: string
    location?: string
    offered?: TourCreateofferedInput | string[]
    duration?: number
    videos?: TourCreatevideosInput | string[]
    images?: TourCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    pricecategory?: TourPriceCategoryUncheckedCreateNestedManyWithoutTourInput
  }

  export type TourUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    priceKids?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    offer?: BoolFieldUpdateOperationsInput | boolean
    discount?: IntFieldUpdateOperationsInput | number
    whattobring?: StringFieldUpdateOperationsInput | string
    included?: TourUpdateincludedInput | string[]
    pickuptime?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPeople?: IntFieldUpdateOperationsInput | number
    minPeople?: IntFieldUpdateOperationsInput | number
    minAge?: IntFieldUpdateOperationsInput | number
    bestSeller?: BoolFieldUpdateOperationsInput | boolean
    priceInfo?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    offered?: TourUpdateofferedInput | string[]
    duration?: IntFieldUpdateOperationsInput | number
    videos?: TourUpdatevideosInput | string[]
    images?: TourUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricecategory?: TourPriceCategoryUpdateManyWithoutTourNestedInput
    Hotel?: HotelUpdateOneRequiredWithoutToursNestedInput
  }

  export type TourUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    priceKids?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    offer?: BoolFieldUpdateOperationsInput | boolean
    discount?: IntFieldUpdateOperationsInput | number
    whattobring?: StringFieldUpdateOperationsInput | string
    included?: TourUpdateincludedInput | string[]
    pickuptime?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPeople?: IntFieldUpdateOperationsInput | number
    minPeople?: IntFieldUpdateOperationsInput | number
    minAge?: IntFieldUpdateOperationsInput | number
    bestSeller?: BoolFieldUpdateOperationsInput | boolean
    priceInfo?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    offered?: TourUpdateofferedInput | string[]
    duration?: IntFieldUpdateOperationsInput | number
    videos?: TourUpdatevideosInput | string[]
    images?: TourUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricecategory?: TourPriceCategoryUncheckedUpdateManyWithoutTourNestedInput
  }

  export type TourCreateManyInput = {
    id?: string
    name?: string
    name_esp?: string
    description?: string
    description_esp?: string
    image?: string
    hotelId?: string
    price: number
    priceKids?: number
    category?: string
    offer?: boolean
    discount?: number
    whattobring?: string
    included?: TourCreateincludedInput | string[]
    pickuptime: Date | string
    maxPeople?: number
    minPeople?: number
    minAge?: number
    bestSeller?: boolean
    priceInfo?: string
    location?: string
    offered?: TourCreateofferedInput | string[]
    duration?: number
    videos?: TourCreatevideosInput | string[]
    images?: TourCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    priceKids?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    offer?: BoolFieldUpdateOperationsInput | boolean
    discount?: IntFieldUpdateOperationsInput | number
    whattobring?: StringFieldUpdateOperationsInput | string
    included?: TourUpdateincludedInput | string[]
    pickuptime?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPeople?: IntFieldUpdateOperationsInput | number
    minPeople?: IntFieldUpdateOperationsInput | number
    minAge?: IntFieldUpdateOperationsInput | number
    bestSeller?: BoolFieldUpdateOperationsInput | boolean
    priceInfo?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    offered?: TourUpdateofferedInput | string[]
    duration?: IntFieldUpdateOperationsInput | number
    videos?: TourUpdatevideosInput | string[]
    images?: TourUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    priceKids?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    offer?: BoolFieldUpdateOperationsInput | boolean
    discount?: IntFieldUpdateOperationsInput | number
    whattobring?: StringFieldUpdateOperationsInput | string
    included?: TourUpdateincludedInput | string[]
    pickuptime?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPeople?: IntFieldUpdateOperationsInput | number
    minPeople?: IntFieldUpdateOperationsInput | number
    minAge?: IntFieldUpdateOperationsInput | number
    bestSeller?: BoolFieldUpdateOperationsInput | boolean
    priceInfo?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    offered?: TourUpdateofferedInput | string[]
    duration?: IntFieldUpdateOperationsInput | number
    videos?: TourUpdatevideosInput | string[]
    images?: TourUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateInput = {
    id?: string
    name?: string
    name_esp?: string
    description?: string
    description_esp?: string
    image?: string
    profileImage?: string | null
    type?: string
    start: Date | string
    end: Date | string
    price: number
    cashOnly?: boolean
    freeOfCharge?: boolean
    location?: string
    isRecurring?: boolean
    recurrencePattern?: $Enums.RECURRINGPATTERN
    recurrenceDays?: ActivityCreaterecurrenceDaysInput | string[]
    recurrenceEndDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    Hotel?: HotelCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    name?: string
    name_esp?: string
    description?: string
    description_esp?: string
    image?: string
    profileImage?: string | null
    hotelId?: string
    type?: string
    start: Date | string
    end: Date | string
    price: number
    cashOnly?: boolean
    freeOfCharge?: boolean
    location?: string
    isRecurring?: boolean
    recurrencePattern?: $Enums.RECURRINGPATTERN
    recurrenceDays?: ActivityCreaterecurrenceDaysInput | string[]
    recurrenceEndDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    cashOnly?: BoolFieldUpdateOperationsInput | boolean
    freeOfCharge?: BoolFieldUpdateOperationsInput | boolean
    location?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrencePattern?: EnumRECURRINGPATTERNFieldUpdateOperationsInput | $Enums.RECURRINGPATTERN
    recurrenceDays?: ActivityUpdaterecurrenceDaysInput | string[]
    recurrenceEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hotel?: HotelUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    hotelId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    cashOnly?: BoolFieldUpdateOperationsInput | boolean
    freeOfCharge?: BoolFieldUpdateOperationsInput | boolean
    location?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrencePattern?: EnumRECURRINGPATTERNFieldUpdateOperationsInput | $Enums.RECURRINGPATTERN
    recurrenceDays?: ActivityUpdaterecurrenceDaysInput | string[]
    recurrenceEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyInput = {
    id?: string
    name?: string
    name_esp?: string
    description?: string
    description_esp?: string
    image?: string
    profileImage?: string | null
    hotelId?: string
    type?: string
    start: Date | string
    end: Date | string
    price: number
    cashOnly?: boolean
    freeOfCharge?: boolean
    location?: string
    isRecurring?: boolean
    recurrencePattern?: $Enums.RECURRINGPATTERN
    recurrenceDays?: ActivityCreaterecurrenceDaysInput | string[]
    recurrenceEndDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    cashOnly?: BoolFieldUpdateOperationsInput | boolean
    freeOfCharge?: BoolFieldUpdateOperationsInput | boolean
    location?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrencePattern?: EnumRECURRINGPATTERNFieldUpdateOperationsInput | $Enums.RECURRINGPATTERN
    recurrenceDays?: ActivityUpdaterecurrenceDaysInput | string[]
    recurrenceEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    hotelId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    cashOnly?: BoolFieldUpdateOperationsInput | boolean
    freeOfCharge?: BoolFieldUpdateOperationsInput | boolean
    location?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrencePattern?: EnumRECURRINGPATTERNFieldUpdateOperationsInput | $Enums.RECURRINGPATTERN
    recurrenceDays?: ActivityUpdaterecurrenceDaysInput | string[]
    recurrenceEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpaPriceCategoryCreateInput = {
    id?: string
    sku: number
    price: number
    description?: string
    description_esp?: string
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
    spa?: SpaCreateNestedOneWithoutPricecategoryInput
  }

  export type SpaPriceCategoryUncheckedCreateInput = {
    id?: string
    sku: number
    price: number
    description?: string
    description_esp?: string
    duration: number
    spaId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpaPriceCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spa?: SpaUpdateOneWithoutPricecategoryNestedInput
  }

  export type SpaPriceCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    spaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpaPriceCategoryCreateManyInput = {
    id?: string
    sku: number
    price: number
    description?: string
    description_esp?: string
    duration: number
    spaId?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpaPriceCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpaPriceCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    spaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpaCreateInput = {
    id?: string
    name?: string
    name_esp?: string
    description?: string
    description_esp?: string
    type?: string
    videos?: SpaCreatevideosInput | string[]
    images?: SpaCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    pricecategory?: SpaPriceCategoryCreateNestedManyWithoutSpaInput
    Hotel?: HotelCreateNestedOneWithoutSpaInput
  }

  export type SpaUncheckedCreateInput = {
    id?: string
    name?: string
    name_esp?: string
    description?: string
    description_esp?: string
    hotelId?: string
    type?: string
    videos?: SpaCreatevideosInput | string[]
    images?: SpaCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    pricecategory?: SpaPriceCategoryUncheckedCreateNestedManyWithoutSpaInput
  }

  export type SpaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    videos?: SpaUpdatevideosInput | string[]
    images?: SpaUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricecategory?: SpaPriceCategoryUpdateManyWithoutSpaNestedInput
    Hotel?: HotelUpdateOneWithoutSpaNestedInput
  }

  export type SpaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    videos?: SpaUpdatevideosInput | string[]
    images?: SpaUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricecategory?: SpaPriceCategoryUncheckedUpdateManyWithoutSpaNestedInput
  }

  export type SpaCreateManyInput = {
    id?: string
    name?: string
    name_esp?: string
    description?: string
    description_esp?: string
    hotelId?: string
    type?: string
    videos?: SpaCreatevideosInput | string[]
    images?: SpaCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    videos?: SpaUpdatevideosInput | string[]
    images?: SpaUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    videos?: SpaUpdatevideosInput | string[]
    images?: SpaUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TVChannelsCreateInput = {
    id?: string
    name: string
    name_esp?: string | null
    description: string
    description_esp?: string | null
    logo?: string | null
    channelNo: string
    languages?: $Enums.TVChannelLanguages
    channeltype?: $Enums.TVCHANNELTYPE
    category?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Hotel?: HotelCreateNestedOneWithoutTvchannelsInput
  }

  export type TVChannelsUncheckedCreateInput = {
    id?: string
    name: string
    name_esp?: string | null
    description: string
    description_esp?: string | null
    logo?: string | null
    channelNo: string
    languages?: $Enums.TVChannelLanguages
    channeltype?: $Enums.TVCHANNELTYPE
    category?: string
    hotelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TVChannelsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    channelNo?: StringFieldUpdateOperationsInput | string
    languages?: EnumTVChannelLanguagesFieldUpdateOperationsInput | $Enums.TVChannelLanguages
    channeltype?: EnumTVCHANNELTYPEFieldUpdateOperationsInput | $Enums.TVCHANNELTYPE
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hotel?: HotelUpdateOneWithoutTvchannelsNestedInput
  }

  export type TVChannelsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    channelNo?: StringFieldUpdateOperationsInput | string
    languages?: EnumTVChannelLanguagesFieldUpdateOperationsInput | $Enums.TVChannelLanguages
    channeltype?: EnumTVCHANNELTYPEFieldUpdateOperationsInput | $Enums.TVCHANNELTYPE
    category?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TVChannelsCreateManyInput = {
    id?: string
    name: string
    name_esp?: string | null
    description: string
    description_esp?: string | null
    logo?: string | null
    channelNo: string
    languages?: $Enums.TVChannelLanguages
    channeltype?: $Enums.TVCHANNELTYPE
    category?: string
    hotelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TVChannelsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    channelNo?: StringFieldUpdateOperationsInput | string
    languages?: EnumTVChannelLanguagesFieldUpdateOperationsInput | $Enums.TVChannelLanguages
    channeltype?: EnumTVCHANNELTYPEFieldUpdateOperationsInput | $Enums.TVCHANNELTYPE
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TVChannelsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    channelNo?: StringFieldUpdateOperationsInput | string
    languages?: EnumTVChannelLanguagesFieldUpdateOperationsInput | $Enums.TVChannelLanguages
    channeltype?: EnumTVCHANNELTYPEFieldUpdateOperationsInput | $Enums.TVCHANNELTYPE
    category?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RestaurantCreateInput = {
    id?: string
    name?: string
    description?: string | null
    descriptionshort?: string | null
    description_esp?: string | null
    descriptionshort_esp?: string | null
    image?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listorder?: number
    categories?: CategoryCreateNestedManyWithoutRestaurantInput
    dishes?: DishCreateNestedManyWithoutRestaurantInput
    menus?: MenuCreateNestedManyWithoutRestaurantInput
    tables?: TableCreateNestedManyWithoutRestaurantInput
    reservations?: ReservationCreateNestedManyWithoutRestaurantInput
    openingHours?: OpeningHoursCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUncheckedCreateInput = {
    id?: string
    name?: string
    description?: string | null
    descriptionshort?: string | null
    description_esp?: string | null
    descriptionshort_esp?: string | null
    image?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listorder?: number
    categories?: CategoryUncheckedCreateNestedManyWithoutRestaurantInput
    dishes?: DishUncheckedCreateNestedManyWithoutRestaurantInput
    menus?: MenuUncheckedCreateNestedManyWithoutRestaurantInput
    tables?: TableUncheckedCreateNestedManyWithoutRestaurantInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutRestaurantInput
    openingHours?: OpeningHoursUncheckedCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listorder?: IntFieldUpdateOperationsInput | number
    categories?: CategoryUpdateManyWithoutRestaurantNestedInput
    dishes?: DishUpdateManyWithoutRestaurantNestedInput
    menus?: MenuUpdateManyWithoutRestaurantNestedInput
    tables?: TableUpdateManyWithoutRestaurantNestedInput
    reservations?: ReservationUpdateManyWithoutRestaurantNestedInput
    openingHours?: OpeningHoursUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listorder?: IntFieldUpdateOperationsInput | number
    categories?: CategoryUncheckedUpdateManyWithoutRestaurantNestedInput
    dishes?: DishUncheckedUpdateManyWithoutRestaurantNestedInput
    menus?: MenuUncheckedUpdateManyWithoutRestaurantNestedInput
    tables?: TableUncheckedUpdateManyWithoutRestaurantNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutRestaurantNestedInput
    openingHours?: OpeningHoursUncheckedUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantCreateManyInput = {
    id?: string
    name?: string
    description?: string | null
    descriptionshort?: string | null
    description_esp?: string | null
    descriptionshort_esp?: string | null
    image?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listorder?: number
  }

  export type RestaurantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listorder?: IntFieldUpdateOperationsInput | number
  }

  export type RestaurantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listorder?: IntFieldUpdateOperationsInput | number
  }

  export type MenuCreateInput = {
    id?: string
    position?: number
    name: string
    name_esp: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    restaurant: RestaurantCreateNestedOneWithoutMenusInput
    dishes?: DishCreateNestedManyWithoutMenuInput
  }

  export type MenuUncheckedCreateInput = {
    id?: string
    position?: number
    name: string
    name_esp: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    price: number
    restaurantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    dishes?: DishUncheckedCreateNestedManyWithoutMenuInput
  }

  export type MenuUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    restaurant?: RestaurantUpdateOneRequiredWithoutMenusNestedInput
    dishes?: DishUpdateManyWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    restaurantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dishes?: DishUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type MenuCreateManyInput = {
    id?: string
    position?: number
    name: string
    name_esp: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    price: number
    restaurantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type MenuUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MenuUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    restaurantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TableCreateInput = {
    id?: string
    number: number
    capacity: number
    location?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    restaurant: RestaurantCreateNestedOneWithoutTablesInput
    reservations?: ReservationCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateInput = {
    id?: string
    number: number
    capacity: number
    location?: string | null
    isActive?: boolean
    restaurantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    restaurant?: RestaurantUpdateOneRequiredWithoutTablesNestedInput
    reservations?: ReservationUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    restaurantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutTableNestedInput
  }

  export type TableCreateManyInput = {
    id?: string
    number: number
    capacity: number
    location?: string | null
    isActive?: boolean
    restaurantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    restaurantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationCreateInput = {
    id?: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    partySize: number
    status?: $Enums.ReservationStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutReservationsInput
    table?: TableCreateNestedOneWithoutReservationsInput
    restaurant: RestaurantCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateInput = {
    id?: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    partySize: number
    status?: $Enums.ReservationStatus
    notes?: string | null
    customerId: string
    tableId?: string | null
    restaurantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    partySize?: IntFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutReservationsNestedInput
    table?: TableUpdateOneWithoutReservationsNestedInput
    restaurant?: RestaurantUpdateOneRequiredWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    partySize?: IntFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    restaurantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationCreateManyInput = {
    id?: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    partySize: number
    status?: $Enums.ReservationStatus
    notes?: string | null
    customerId: string
    tableId?: string | null
    restaurantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    partySize?: IntFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    partySize?: IntFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    restaurantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postition?: number
    restaurant: RestaurantCreateNestedOneWithoutCategoriesInput
    dishes?: DishCreateNestedManyWithoutCategoryInput
    subcategories?: SubcategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    restaurantId: string
    postition?: number
    dishes?: DishUncheckedCreateNestedManyWithoutCategoryInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postition?: IntFieldUpdateOperationsInput | number
    restaurant?: RestaurantUpdateOneRequiredWithoutCategoriesNestedInput
    dishes?: DishUpdateManyWithoutCategoryNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    postition?: IntFieldUpdateOperationsInput | number
    dishes?: DishUncheckedUpdateManyWithoutCategoryNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    restaurantId: string
    postition?: number
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postition?: IntFieldUpdateOperationsInput | number
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    postition?: IntFieldUpdateOperationsInput | number
  }

  export type SubcategoryCreateInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postition?: number
    category: CategoryCreateNestedOneWithoutSubcategoriesInput
    dishes?: DishCreateNestedManyWithoutSubcategoryInput
    subSubcategories?: SubSubcategoryCreateNestedManyWithoutSubcategoryInput
  }

  export type SubcategoryUncheckedCreateInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentCategoryId: string
    postition?: number
    dishes?: DishUncheckedCreateNestedManyWithoutSubcategoryInput
    subSubcategories?: SubSubcategoryUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type SubcategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postition?: IntFieldUpdateOperationsInput | number
    category?: CategoryUpdateOneRequiredWithoutSubcategoriesNestedInput
    dishes?: DishUpdateManyWithoutSubcategoryNestedInput
    subSubcategories?: SubSubcategoryUpdateManyWithoutSubcategoryNestedInput
  }

  export type SubcategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentCategoryId?: StringFieldUpdateOperationsInput | string
    postition?: IntFieldUpdateOperationsInput | number
    dishes?: DishUncheckedUpdateManyWithoutSubcategoryNestedInput
    subSubcategories?: SubSubcategoryUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type SubcategoryCreateManyInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentCategoryId: string
    postition?: number
  }

  export type SubcategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postition?: IntFieldUpdateOperationsInput | number
  }

  export type SubcategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentCategoryId?: StringFieldUpdateOperationsInput | string
    postition?: IntFieldUpdateOperationsInput | number
  }

  export type SubSubcategoryCreateInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postition?: number
    subcategory: SubcategoryCreateNestedOneWithoutSubSubcategoriesInput
    dishes?: DishCreateNestedManyWithoutSubSubcategoryInput
  }

  export type SubSubcategoryUncheckedCreateInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentSubcategoryId: string
    postition?: number
    dishes?: DishUncheckedCreateNestedManyWithoutSubSubcategoryInput
  }

  export type SubSubcategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postition?: IntFieldUpdateOperationsInput | number
    subcategory?: SubcategoryUpdateOneRequiredWithoutSubSubcategoriesNestedInput
    dishes?: DishUpdateManyWithoutSubSubcategoryNestedInput
  }

  export type SubSubcategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentSubcategoryId?: StringFieldUpdateOperationsInput | string
    postition?: IntFieldUpdateOperationsInput | number
    dishes?: DishUncheckedUpdateManyWithoutSubSubcategoryNestedInput
  }

  export type SubSubcategoryCreateManyInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentSubcategoryId: string
    postition?: number
  }

  export type SubSubcategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postition?: IntFieldUpdateOperationsInput | number
  }

  export type SubSubcategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentSubcategoryId?: StringFieldUpdateOperationsInput | string
    postition?: IntFieldUpdateOperationsInput | number
  }

  export type DishCreateInput = {
    id?: string
    sku: number
    name: string
    name_esp: string
    description: string
    description_esp: string
    price: number
    unit?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availableAtDayOfWeek?: number
    dietaryInfo?: DishCreatedietaryInfoInput | string[]
    allergens?: DishCreateallergensInput | string[]
    ingredients?: DishCreateingredientsInput | string[]
    prepTime?: number | null
    isPopular?: boolean
    isNew?: boolean
    course_number?: number
    restaurant: RestaurantCreateNestedOneWithoutDishesInput
    category: CategoryCreateNestedOneWithoutDishesInput
    subcategory?: SubcategoryCreateNestedOneWithoutDishesInput
    subSubcategory?: SubSubcategoryCreateNestedOneWithoutDishesInput
    menu?: MenuCreateNestedOneWithoutDishesInput
  }

  export type DishUncheckedCreateInput = {
    id?: string
    sku: number
    name: string
    name_esp: string
    description: string
    description_esp: string
    price: number
    unit?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    restaurantId: string
    categoryId: string
    subcategoryId?: string | null
    subSubcategoryId?: string | null
    availableAtDayOfWeek?: number
    dietaryInfo?: DishCreatedietaryInfoInput | string[]
    allergens?: DishCreateallergensInput | string[]
    ingredients?: DishCreateingredientsInput | string[]
    prepTime?: number | null
    isPopular?: boolean
    isNew?: boolean
    menuId?: string | null
    course_number?: number
  }

  export type DishUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availableAtDayOfWeek?: IntFieldUpdateOperationsInput | number
    dietaryInfo?: DishUpdatedietaryInfoInput | string[]
    allergens?: DishUpdateallergensInput | string[]
    ingredients?: DishUpdateingredientsInput | string[]
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    course_number?: IntFieldUpdateOperationsInput | number
    restaurant?: RestaurantUpdateOneRequiredWithoutDishesNestedInput
    category?: CategoryUpdateOneRequiredWithoutDishesNestedInput
    subcategory?: SubcategoryUpdateOneWithoutDishesNestedInput
    subSubcategory?: SubSubcategoryUpdateOneWithoutDishesNestedInput
    menu?: MenuUpdateOneWithoutDishesNestedInput
  }

  export type DishUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subSubcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    availableAtDayOfWeek?: IntFieldUpdateOperationsInput | number
    dietaryInfo?: DishUpdatedietaryInfoInput | string[]
    allergens?: DishUpdateallergensInput | string[]
    ingredients?: DishUpdateingredientsInput | string[]
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    menuId?: NullableStringFieldUpdateOperationsInput | string | null
    course_number?: IntFieldUpdateOperationsInput | number
  }

  export type DishCreateManyInput = {
    id?: string
    sku: number
    name: string
    name_esp: string
    description: string
    description_esp: string
    price: number
    unit?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    restaurantId: string
    categoryId: string
    subcategoryId?: string | null
    subSubcategoryId?: string | null
    availableAtDayOfWeek?: number
    dietaryInfo?: DishCreatedietaryInfoInput | string[]
    allergens?: DishCreateallergensInput | string[]
    ingredients?: DishCreateingredientsInput | string[]
    prepTime?: number | null
    isPopular?: boolean
    isNew?: boolean
    menuId?: string | null
    course_number?: number
  }

  export type DishUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availableAtDayOfWeek?: IntFieldUpdateOperationsInput | number
    dietaryInfo?: DishUpdatedietaryInfoInput | string[]
    allergens?: DishUpdateallergensInput | string[]
    ingredients?: DishUpdateingredientsInput | string[]
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    course_number?: IntFieldUpdateOperationsInput | number
  }

  export type DishUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subSubcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    availableAtDayOfWeek?: IntFieldUpdateOperationsInput | number
    dietaryInfo?: DishUpdatedietaryInfoInput | string[]
    allergens?: DishUpdateallergensInput | string[]
    ingredients?: DishUpdateingredientsInput | string[]
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    menuId?: NullableStringFieldUpdateOperationsInput | string | null
    course_number?: IntFieldUpdateOperationsInput | number
  }

  export type OpeningHoursCreateInput = {
    id?: string
    dayOfWeek: number
    openTime: string
    closeTime: string
    isClosed?: boolean
    restaurant: RestaurantCreateNestedOneWithoutOpeningHoursInput
  }

  export type OpeningHoursUncheckedCreateInput = {
    id?: string
    dayOfWeek: number
    openTime: string
    closeTime: string
    isClosed?: boolean
    restaurantId: string
  }

  export type OpeningHoursUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    restaurant?: RestaurantUpdateOneRequiredWithoutOpeningHoursNestedInput
  }

  export type OpeningHoursUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    restaurantId?: StringFieldUpdateOperationsInput | string
  }

  export type OpeningHoursCreateManyInput = {
    id?: string
    dayOfWeek: number
    openTime: string
    closeTime: string
    isClosed?: boolean
    restaurantId: string
  }

  export type OpeningHoursUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OpeningHoursUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    restaurantId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type TourListRelationFilter = {
    every?: TourWhereInput
    some?: TourWhereInput
    none?: TourWhereInput
  }

  export type SpaListRelationFilter = {
    every?: SpaWhereInput
    some?: SpaWhereInput
    none?: SpaWhereInput
  }

  export type AmenitiesListRelationFilter = {
    every?: AmenitiesWhereInput
    some?: AmenitiesWhereInput
    none?: AmenitiesWhereInput
  }

  export type TVChannelsListRelationFilter = {
    every?: TVChannelsWhereInput
    some?: TVChannelsWhereInput
    none?: TVChannelsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TourOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AmenitiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TVChannelsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelOrderByRelevanceInput = {
    fields: HotelOrderByRelevanceFieldEnum | HotelOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type HotelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    locationDescription?: SortOrder
    locationDescription_esp?: SortOrder
    images?: SortOrder
    videos?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    phone?: SortOrder
    phone_reservation?: SortOrder
    phone_tollfree?: SortOrder
    email?: SortOrder
    website?: SortOrder
    facebook?: SortOrder
    tripadvisor?: SortOrder
    instagram?: SortOrder
    youtube?: SortOrder
    whatsapp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelAvgOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
  }

  export type HotelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    locationDescription?: SortOrder
    locationDescription_esp?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    phone?: SortOrder
    phone_reservation?: SortOrder
    phone_tollfree?: SortOrder
    email?: SortOrder
    website?: SortOrder
    facebook?: SortOrder
    tripadvisor?: SortOrder
    instagram?: SortOrder
    youtube?: SortOrder
    whatsapp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    locationDescription?: SortOrder
    locationDescription_esp?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    phone?: SortOrder
    phone_reservation?: SortOrder
    phone_tollfree?: SortOrder
    email?: SortOrder
    website?: SortOrder
    facebook?: SortOrder
    tripadvisor?: SortOrder
    instagram?: SortOrder
    youtube?: SortOrder
    whatsapp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelSumOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumAMENITIESTYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.AMENITIESTYPE | EnumAMENITIESTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.AMENITIESTYPE[] | ListEnumAMENITIESTYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.AMENITIESTYPE[] | ListEnumAMENITIESTYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumAMENITIESTYPEFilter<$PrismaModel> | $Enums.AMENITIESTYPE
  }

  export type HotelNullableScalarRelationFilter = {
    is?: HotelWhereInput | null
    isNot?: HotelWhereInput | null
  }

  export type AmenitiesOrderByRelevanceInput = {
    fields: AmenitiesOrderByRelevanceFieldEnum | AmenitiesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AmenitiesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    image?: SortOrder
    amenitiestype?: SortOrder
    hotelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmenitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    image?: SortOrder
    amenitiestype?: SortOrder
    hotelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmenitiesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    image?: SortOrder
    amenitiestype?: SortOrder
    hotelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAMENITIESTYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AMENITIESTYPE | EnumAMENITIESTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.AMENITIESTYPE[] | ListEnumAMENITIESTYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.AMENITIESTYPE[] | ListEnumAMENITIESTYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumAMENITIESTYPEWithAggregatesFilter<$PrismaModel> | $Enums.AMENITIESTYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAMENITIESTYPEFilter<$PrismaModel>
    _max?: NestedEnumAMENITIESTYPEFilter<$PrismaModel>
  }

  export type TourNullableScalarRelationFilter = {
    is?: TourWhereInput | null
    isNot?: TourWhereInput | null
  }

  export type TourPriceCategoryOrderByRelevanceInput = {
    fields: TourPriceCategoryOrderByRelevanceFieldEnum | TourPriceCategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TourPriceCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    tourId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TourPriceCategoryAvgOrderByAggregateInput = {
    sku?: SortOrder
    price?: SortOrder
  }

  export type TourPriceCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    tourId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TourPriceCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    tourId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TourPriceCategorySumOrderByAggregateInput = {
    sku?: SortOrder
    price?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type TourPriceCategoryListRelationFilter = {
    every?: TourPriceCategoryWhereInput
    some?: TourPriceCategoryWhereInput
    none?: TourPriceCategoryWhereInput
  }

  export type HotelScalarRelationFilter = {
    is?: HotelWhereInput
    isNot?: HotelWhereInput
  }

  export type TourPriceCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TourOrderByRelevanceInput = {
    fields: TourOrderByRelevanceFieldEnum | TourOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TourCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    hotelId?: SortOrder
    price?: SortOrder
    priceKids?: SortOrder
    category?: SortOrder
    offer?: SortOrder
    discount?: SortOrder
    whattobring?: SortOrder
    included?: SortOrder
    pickuptime?: SortOrder
    maxPeople?: SortOrder
    minPeople?: SortOrder
    minAge?: SortOrder
    bestSeller?: SortOrder
    priceInfo?: SortOrder
    location?: SortOrder
    offered?: SortOrder
    duration?: SortOrder
    videos?: SortOrder
    images?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TourAvgOrderByAggregateInput = {
    price?: SortOrder
    priceKids?: SortOrder
    discount?: SortOrder
    maxPeople?: SortOrder
    minPeople?: SortOrder
    minAge?: SortOrder
    duration?: SortOrder
  }

  export type TourMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    hotelId?: SortOrder
    price?: SortOrder
    priceKids?: SortOrder
    category?: SortOrder
    offer?: SortOrder
    discount?: SortOrder
    whattobring?: SortOrder
    pickuptime?: SortOrder
    maxPeople?: SortOrder
    minPeople?: SortOrder
    minAge?: SortOrder
    bestSeller?: SortOrder
    priceInfo?: SortOrder
    location?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TourMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    hotelId?: SortOrder
    price?: SortOrder
    priceKids?: SortOrder
    category?: SortOrder
    offer?: SortOrder
    discount?: SortOrder
    whattobring?: SortOrder
    pickuptime?: SortOrder
    maxPeople?: SortOrder
    minPeople?: SortOrder
    minAge?: SortOrder
    bestSeller?: SortOrder
    priceInfo?: SortOrder
    location?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TourSumOrderByAggregateInput = {
    price?: SortOrder
    priceKids?: SortOrder
    discount?: SortOrder
    maxPeople?: SortOrder
    minPeople?: SortOrder
    minAge?: SortOrder
    duration?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumRECURRINGPATTERNFilter<$PrismaModel = never> = {
    equals?: $Enums.RECURRINGPATTERN | EnumRECURRINGPATTERNFieldRefInput<$PrismaModel>
    in?: $Enums.RECURRINGPATTERN[] | ListEnumRECURRINGPATTERNFieldRefInput<$PrismaModel>
    notIn?: $Enums.RECURRINGPATTERN[] | ListEnumRECURRINGPATTERNFieldRefInput<$PrismaModel>
    not?: NestedEnumRECURRINGPATTERNFilter<$PrismaModel> | $Enums.RECURRINGPATTERN
  }

  export type ActivityOrderByRelevanceInput = {
    fields: ActivityOrderByRelevanceFieldEnum | ActivityOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    profileImage?: SortOrder
    hotelId?: SortOrder
    type?: SortOrder
    start?: SortOrder
    end?: SortOrder
    price?: SortOrder
    cashOnly?: SortOrder
    freeOfCharge?: SortOrder
    location?: SortOrder
    isRecurring?: SortOrder
    recurrencePattern?: SortOrder
    recurrenceDays?: SortOrder
    recurrenceEndDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    profileImage?: SortOrder
    hotelId?: SortOrder
    type?: SortOrder
    start?: SortOrder
    end?: SortOrder
    price?: SortOrder
    cashOnly?: SortOrder
    freeOfCharge?: SortOrder
    location?: SortOrder
    isRecurring?: SortOrder
    recurrencePattern?: SortOrder
    recurrenceEndDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    profileImage?: SortOrder
    hotelId?: SortOrder
    type?: SortOrder
    start?: SortOrder
    end?: SortOrder
    price?: SortOrder
    cashOnly?: SortOrder
    freeOfCharge?: SortOrder
    location?: SortOrder
    isRecurring?: SortOrder
    recurrencePattern?: SortOrder
    recurrenceEndDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivitySumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumRECURRINGPATTERNWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RECURRINGPATTERN | EnumRECURRINGPATTERNFieldRefInput<$PrismaModel>
    in?: $Enums.RECURRINGPATTERN[] | ListEnumRECURRINGPATTERNFieldRefInput<$PrismaModel>
    notIn?: $Enums.RECURRINGPATTERN[] | ListEnumRECURRINGPATTERNFieldRefInput<$PrismaModel>
    not?: NestedEnumRECURRINGPATTERNWithAggregatesFilter<$PrismaModel> | $Enums.RECURRINGPATTERN
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRECURRINGPATTERNFilter<$PrismaModel>
    _max?: NestedEnumRECURRINGPATTERNFilter<$PrismaModel>
  }

  export type SpaNullableScalarRelationFilter = {
    is?: SpaWhereInput | null
    isNot?: SpaWhereInput | null
  }

  export type SpaPriceCategoryOrderByRelevanceInput = {
    fields: SpaPriceCategoryOrderByRelevanceFieldEnum | SpaPriceCategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SpaPriceCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    duration?: SortOrder
    spaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpaPriceCategoryAvgOrderByAggregateInput = {
    sku?: SortOrder
    price?: SortOrder
    duration?: SortOrder
  }

  export type SpaPriceCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    duration?: SortOrder
    spaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpaPriceCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    duration?: SortOrder
    spaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpaPriceCategorySumOrderByAggregateInput = {
    sku?: SortOrder
    price?: SortOrder
    duration?: SortOrder
  }

  export type SpaPriceCategoryListRelationFilter = {
    every?: SpaPriceCategoryWhereInput
    some?: SpaPriceCategoryWhereInput
    none?: SpaPriceCategoryWhereInput
  }

  export type SpaPriceCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpaOrderByRelevanceInput = {
    fields: SpaOrderByRelevanceFieldEnum | SpaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SpaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    hotelId?: SortOrder
    type?: SortOrder
    videos?: SortOrder
    images?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    hotelId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    hotelId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTVChannelLanguagesFilter<$PrismaModel = never> = {
    equals?: $Enums.TVChannelLanguages | EnumTVChannelLanguagesFieldRefInput<$PrismaModel>
    in?: $Enums.TVChannelLanguages[] | ListEnumTVChannelLanguagesFieldRefInput<$PrismaModel>
    notIn?: $Enums.TVChannelLanguages[] | ListEnumTVChannelLanguagesFieldRefInput<$PrismaModel>
    not?: NestedEnumTVChannelLanguagesFilter<$PrismaModel> | $Enums.TVChannelLanguages
  }

  export type EnumTVCHANNELTYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.TVCHANNELTYPE | EnumTVCHANNELTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.TVCHANNELTYPE[] | ListEnumTVCHANNELTYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.TVCHANNELTYPE[] | ListEnumTVCHANNELTYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumTVCHANNELTYPEFilter<$PrismaModel> | $Enums.TVCHANNELTYPE
  }

  export type TVChannelsOrderByRelevanceInput = {
    fields: TVChannelsOrderByRelevanceFieldEnum | TVChannelsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TVChannelsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    logo?: SortOrder
    channelNo?: SortOrder
    languages?: SortOrder
    channeltype?: SortOrder
    category?: SortOrder
    hotelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TVChannelsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    logo?: SortOrder
    channelNo?: SortOrder
    languages?: SortOrder
    channeltype?: SortOrder
    category?: SortOrder
    hotelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TVChannelsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    logo?: SortOrder
    channelNo?: SortOrder
    languages?: SortOrder
    channeltype?: SortOrder
    category?: SortOrder
    hotelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTVChannelLanguagesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TVChannelLanguages | EnumTVChannelLanguagesFieldRefInput<$PrismaModel>
    in?: $Enums.TVChannelLanguages[] | ListEnumTVChannelLanguagesFieldRefInput<$PrismaModel>
    notIn?: $Enums.TVChannelLanguages[] | ListEnumTVChannelLanguagesFieldRefInput<$PrismaModel>
    not?: NestedEnumTVChannelLanguagesWithAggregatesFilter<$PrismaModel> | $Enums.TVChannelLanguages
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTVChannelLanguagesFilter<$PrismaModel>
    _max?: NestedEnumTVChannelLanguagesFilter<$PrismaModel>
  }

  export type EnumTVCHANNELTYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TVCHANNELTYPE | EnumTVCHANNELTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.TVCHANNELTYPE[] | ListEnumTVCHANNELTYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.TVCHANNELTYPE[] | ListEnumTVCHANNELTYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumTVCHANNELTYPEWithAggregatesFilter<$PrismaModel> | $Enums.TVCHANNELTYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTVCHANNELTYPEFilter<$PrismaModel>
    _max?: NestedEnumTVCHANNELTYPEFilter<$PrismaModel>
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type DishListRelationFilter = {
    every?: DishWhereInput
    some?: DishWhereInput
    none?: DishWhereInput
  }

  export type MenuListRelationFilter = {
    every?: MenuWhereInput
    some?: MenuWhereInput
    none?: MenuWhereInput
  }

  export type TableListRelationFilter = {
    every?: TableWhereInput
    some?: TableWhereInput
    none?: TableWhereInput
  }

  export type ReservationListRelationFilter = {
    every?: ReservationWhereInput
    some?: ReservationWhereInput
    none?: ReservationWhereInput
  }

  export type OpeningHoursListRelationFilter = {
    every?: OpeningHoursWhereInput
    some?: OpeningHoursWhereInput
    none?: OpeningHoursWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DishOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OpeningHoursOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RestaurantOrderByRelevanceInput = {
    fields: RestaurantOrderByRelevanceFieldEnum | RestaurantOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RestaurantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    descriptionshort?: SortOrder
    description_esp?: SortOrder
    descriptionshort_esp?: SortOrder
    image?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    listorder?: SortOrder
  }

  export type RestaurantAvgOrderByAggregateInput = {
    listorder?: SortOrder
  }

  export type RestaurantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    descriptionshort?: SortOrder
    description_esp?: SortOrder
    descriptionshort_esp?: SortOrder
    image?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    listorder?: SortOrder
  }

  export type RestaurantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    descriptionshort?: SortOrder
    description_esp?: SortOrder
    descriptionshort_esp?: SortOrder
    image?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    listorder?: SortOrder
  }

  export type RestaurantSumOrderByAggregateInput = {
    listorder?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type RestaurantScalarRelationFilter = {
    is?: RestaurantWhereInput
    isNot?: RestaurantWhereInput
  }

  export type MenuOrderByRelevanceInput = {
    fields: MenuOrderByRelevanceFieldEnum | MenuOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MenuRestaurantIdNameCompoundUniqueInput = {
    restaurantId: string
    name: string
  }

  export type MenuCountOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    price?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type MenuAvgOrderByAggregateInput = {
    position?: SortOrder
    price?: SortOrder
  }

  export type MenuMaxOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    price?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type MenuMinOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    price?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type MenuSumOrderByAggregateInput = {
    position?: SortOrder
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type TableOrderByRelevanceInput = {
    fields: TableOrderByRelevanceFieldEnum | TableOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TableRestaurantIdNumberCompoundUniqueInput = {
    restaurantId: string
    number: number
  }

  export type TableCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    capacity?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TableAvgOrderByAggregateInput = {
    number?: SortOrder
    capacity?: SortOrder
  }

  export type TableMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    capacity?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TableMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    capacity?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TableSumOrderByAggregateInput = {
    number?: SortOrder
    capacity?: SortOrder
  }

  export type CustomerOrderByRelevanceInput = {
    fields: CustomerOrderByRelevanceFieldEnum | CustomerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumReservationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReservationStatus | EnumReservationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReservationStatus[] | ListEnumReservationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReservationStatus[] | ListEnumReservationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReservationStatusFilter<$PrismaModel> | $Enums.ReservationStatus
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type TableNullableScalarRelationFilter = {
    is?: TableWhereInput | null
    isNot?: TableWhereInput | null
  }

  export type ReservationOrderByRelevanceInput = {
    fields: ReservationOrderByRelevanceFieldEnum | ReservationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReservationCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    partySize?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    customerId?: SortOrder
    tableId?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReservationAvgOrderByAggregateInput = {
    partySize?: SortOrder
  }

  export type ReservationMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    partySize?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    customerId?: SortOrder
    tableId?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReservationMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    partySize?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    customerId?: SortOrder
    tableId?: SortOrder
    restaurantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReservationSumOrderByAggregateInput = {
    partySize?: SortOrder
  }

  export type EnumReservationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReservationStatus | EnumReservationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReservationStatus[] | ListEnumReservationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReservationStatus[] | ListEnumReservationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReservationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReservationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReservationStatusFilter<$PrismaModel>
    _max?: NestedEnumReservationStatusFilter<$PrismaModel>
  }

  export type SubcategoryListRelationFilter = {
    every?: SubcategoryWhereInput
    some?: SubcategoryWhereInput
    none?: SubcategoryWhereInput
  }

  export type SubcategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelevanceInput = {
    fields: CategoryOrderByRelevanceFieldEnum | CategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CategoryRestaurantIdSlugCompoundUniqueInput = {
    restaurantId: string
    slug: string
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    restaurantId?: SortOrder
    postition?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    postition?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    restaurantId?: SortOrder
    postition?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    restaurantId?: SortOrder
    postition?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    postition?: SortOrder
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type SubSubcategoryListRelationFilter = {
    every?: SubSubcategoryWhereInput
    some?: SubSubcategoryWhereInput
    none?: SubSubcategoryWhereInput
  }

  export type SubSubcategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubcategoryOrderByRelevanceInput = {
    fields: SubcategoryOrderByRelevanceFieldEnum | SubcategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubcategoryParentCategoryIdSlugCompoundUniqueInput = {
    parentCategoryId: string
    slug: string
  }

  export type SubcategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentCategoryId?: SortOrder
    postition?: SortOrder
  }

  export type SubcategoryAvgOrderByAggregateInput = {
    postition?: SortOrder
  }

  export type SubcategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentCategoryId?: SortOrder
    postition?: SortOrder
  }

  export type SubcategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentCategoryId?: SortOrder
    postition?: SortOrder
  }

  export type SubcategorySumOrderByAggregateInput = {
    postition?: SortOrder
  }

  export type SubcategoryScalarRelationFilter = {
    is?: SubcategoryWhereInput
    isNot?: SubcategoryWhereInput
  }

  export type SubSubcategoryOrderByRelevanceInput = {
    fields: SubSubcategoryOrderByRelevanceFieldEnum | SubSubcategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubSubcategoryParentSubcategoryIdSlugCompoundUniqueInput = {
    parentSubcategoryId: string
    slug: string
  }

  export type SubSubcategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentSubcategoryId?: SortOrder
    postition?: SortOrder
  }

  export type SubSubcategoryAvgOrderByAggregateInput = {
    postition?: SortOrder
  }

  export type SubSubcategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentSubcategoryId?: SortOrder
    postition?: SortOrder
  }

  export type SubSubcategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentSubcategoryId?: SortOrder
    postition?: SortOrder
  }

  export type SubSubcategorySumOrderByAggregateInput = {
    postition?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SubcategoryNullableScalarRelationFilter = {
    is?: SubcategoryWhereInput | null
    isNot?: SubcategoryWhereInput | null
  }

  export type SubSubcategoryNullableScalarRelationFilter = {
    is?: SubSubcategoryWhereInput | null
    isNot?: SubSubcategoryWhereInput | null
  }

  export type MenuNullableScalarRelationFilter = {
    is?: MenuWhereInput | null
    isNot?: MenuWhereInput | null
  }

  export type DishOrderByRelevanceInput = {
    fields: DishOrderByRelevanceFieldEnum | DishOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DishCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    restaurantId?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
    subSubcategoryId?: SortOrder
    availableAtDayOfWeek?: SortOrder
    dietaryInfo?: SortOrder
    allergens?: SortOrder
    ingredients?: SortOrder
    prepTime?: SortOrder
    isPopular?: SortOrder
    isNew?: SortOrder
    menuId?: SortOrder
    course_number?: SortOrder
  }

  export type DishAvgOrderByAggregateInput = {
    sku?: SortOrder
    price?: SortOrder
    availableAtDayOfWeek?: SortOrder
    prepTime?: SortOrder
    course_number?: SortOrder
  }

  export type DishMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    restaurantId?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
    subSubcategoryId?: SortOrder
    availableAtDayOfWeek?: SortOrder
    prepTime?: SortOrder
    isPopular?: SortOrder
    isNew?: SortOrder
    menuId?: SortOrder
    course_number?: SortOrder
  }

  export type DishMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    name_esp?: SortOrder
    description?: SortOrder
    description_esp?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    restaurantId?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
    subSubcategoryId?: SortOrder
    availableAtDayOfWeek?: SortOrder
    prepTime?: SortOrder
    isPopular?: SortOrder
    isNew?: SortOrder
    menuId?: SortOrder
    course_number?: SortOrder
  }

  export type DishSumOrderByAggregateInput = {
    sku?: SortOrder
    price?: SortOrder
    availableAtDayOfWeek?: SortOrder
    prepTime?: SortOrder
    course_number?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type OpeningHoursOrderByRelevanceInput = {
    fields: OpeningHoursOrderByRelevanceFieldEnum | OpeningHoursOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OpeningHoursRestaurantIdDayOfWeekCompoundUniqueInput = {
    restaurantId: string
    dayOfWeek: number
  }

  export type OpeningHoursCountOrderByAggregateInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    isClosed?: SortOrder
    restaurantId?: SortOrder
  }

  export type OpeningHoursAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type OpeningHoursMaxOrderByAggregateInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    isClosed?: SortOrder
    restaurantId?: SortOrder
  }

  export type OpeningHoursMinOrderByAggregateInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    openTime?: SortOrder
    closeTime?: SortOrder
    isClosed?: SortOrder
    restaurantId?: SortOrder
  }

  export type OpeningHoursSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type HotelCreateimagesInput = {
    set: string[]
  }

  export type HotelCreatevideosInput = {
    set: string[]
  }

  export type ActivityCreateNestedManyWithoutHotelInput = {
    create?: XOR<ActivityCreateWithoutHotelInput, ActivityUncheckedCreateWithoutHotelInput> | ActivityCreateWithoutHotelInput[] | ActivityUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutHotelInput | ActivityCreateOrConnectWithoutHotelInput[]
    createMany?: ActivityCreateManyHotelInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type TourCreateNestedManyWithoutHotelInput = {
    create?: XOR<TourCreateWithoutHotelInput, TourUncheckedCreateWithoutHotelInput> | TourCreateWithoutHotelInput[] | TourUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: TourCreateOrConnectWithoutHotelInput | TourCreateOrConnectWithoutHotelInput[]
    createMany?: TourCreateManyHotelInputEnvelope
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
  }

  export type SpaCreateNestedManyWithoutHotelInput = {
    create?: XOR<SpaCreateWithoutHotelInput, SpaUncheckedCreateWithoutHotelInput> | SpaCreateWithoutHotelInput[] | SpaUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: SpaCreateOrConnectWithoutHotelInput | SpaCreateOrConnectWithoutHotelInput[]
    createMany?: SpaCreateManyHotelInputEnvelope
    connect?: SpaWhereUniqueInput | SpaWhereUniqueInput[]
  }

  export type AmenitiesCreateNestedManyWithoutHotelInput = {
    create?: XOR<AmenitiesCreateWithoutHotelInput, AmenitiesUncheckedCreateWithoutHotelInput> | AmenitiesCreateWithoutHotelInput[] | AmenitiesUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: AmenitiesCreateOrConnectWithoutHotelInput | AmenitiesCreateOrConnectWithoutHotelInput[]
    createMany?: AmenitiesCreateManyHotelInputEnvelope
    connect?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
  }

  export type TVChannelsCreateNestedManyWithoutHotelInput = {
    create?: XOR<TVChannelsCreateWithoutHotelInput, TVChannelsUncheckedCreateWithoutHotelInput> | TVChannelsCreateWithoutHotelInput[] | TVChannelsUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: TVChannelsCreateOrConnectWithoutHotelInput | TVChannelsCreateOrConnectWithoutHotelInput[]
    createMany?: TVChannelsCreateManyHotelInputEnvelope
    connect?: TVChannelsWhereUniqueInput | TVChannelsWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<ActivityCreateWithoutHotelInput, ActivityUncheckedCreateWithoutHotelInput> | ActivityCreateWithoutHotelInput[] | ActivityUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutHotelInput | ActivityCreateOrConnectWithoutHotelInput[]
    createMany?: ActivityCreateManyHotelInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type TourUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<TourCreateWithoutHotelInput, TourUncheckedCreateWithoutHotelInput> | TourCreateWithoutHotelInput[] | TourUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: TourCreateOrConnectWithoutHotelInput | TourCreateOrConnectWithoutHotelInput[]
    createMany?: TourCreateManyHotelInputEnvelope
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
  }

  export type SpaUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<SpaCreateWithoutHotelInput, SpaUncheckedCreateWithoutHotelInput> | SpaCreateWithoutHotelInput[] | SpaUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: SpaCreateOrConnectWithoutHotelInput | SpaCreateOrConnectWithoutHotelInput[]
    createMany?: SpaCreateManyHotelInputEnvelope
    connect?: SpaWhereUniqueInput | SpaWhereUniqueInput[]
  }

  export type AmenitiesUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<AmenitiesCreateWithoutHotelInput, AmenitiesUncheckedCreateWithoutHotelInput> | AmenitiesCreateWithoutHotelInput[] | AmenitiesUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: AmenitiesCreateOrConnectWithoutHotelInput | AmenitiesCreateOrConnectWithoutHotelInput[]
    createMany?: AmenitiesCreateManyHotelInputEnvelope
    connect?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
  }

  export type TVChannelsUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<TVChannelsCreateWithoutHotelInput, TVChannelsUncheckedCreateWithoutHotelInput> | TVChannelsCreateWithoutHotelInput[] | TVChannelsUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: TVChannelsCreateOrConnectWithoutHotelInput | TVChannelsCreateOrConnectWithoutHotelInput[]
    createMany?: TVChannelsCreateManyHotelInputEnvelope
    connect?: TVChannelsWhereUniqueInput | TVChannelsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type HotelUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type HotelUpdatevideosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ActivityUpdateManyWithoutHotelNestedInput = {
    create?: XOR<ActivityCreateWithoutHotelInput, ActivityUncheckedCreateWithoutHotelInput> | ActivityCreateWithoutHotelInput[] | ActivityUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutHotelInput | ActivityCreateOrConnectWithoutHotelInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutHotelInput | ActivityUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: ActivityCreateManyHotelInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutHotelInput | ActivityUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutHotelInput | ActivityUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type TourUpdateManyWithoutHotelNestedInput = {
    create?: XOR<TourCreateWithoutHotelInput, TourUncheckedCreateWithoutHotelInput> | TourCreateWithoutHotelInput[] | TourUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: TourCreateOrConnectWithoutHotelInput | TourCreateOrConnectWithoutHotelInput[]
    upsert?: TourUpsertWithWhereUniqueWithoutHotelInput | TourUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: TourCreateManyHotelInputEnvelope
    set?: TourWhereUniqueInput | TourWhereUniqueInput[]
    disconnect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    delete?: TourWhereUniqueInput | TourWhereUniqueInput[]
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    update?: TourUpdateWithWhereUniqueWithoutHotelInput | TourUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: TourUpdateManyWithWhereWithoutHotelInput | TourUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: TourScalarWhereInput | TourScalarWhereInput[]
  }

  export type SpaUpdateManyWithoutHotelNestedInput = {
    create?: XOR<SpaCreateWithoutHotelInput, SpaUncheckedCreateWithoutHotelInput> | SpaCreateWithoutHotelInput[] | SpaUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: SpaCreateOrConnectWithoutHotelInput | SpaCreateOrConnectWithoutHotelInput[]
    upsert?: SpaUpsertWithWhereUniqueWithoutHotelInput | SpaUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: SpaCreateManyHotelInputEnvelope
    set?: SpaWhereUniqueInput | SpaWhereUniqueInput[]
    disconnect?: SpaWhereUniqueInput | SpaWhereUniqueInput[]
    delete?: SpaWhereUniqueInput | SpaWhereUniqueInput[]
    connect?: SpaWhereUniqueInput | SpaWhereUniqueInput[]
    update?: SpaUpdateWithWhereUniqueWithoutHotelInput | SpaUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: SpaUpdateManyWithWhereWithoutHotelInput | SpaUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: SpaScalarWhereInput | SpaScalarWhereInput[]
  }

  export type AmenitiesUpdateManyWithoutHotelNestedInput = {
    create?: XOR<AmenitiesCreateWithoutHotelInput, AmenitiesUncheckedCreateWithoutHotelInput> | AmenitiesCreateWithoutHotelInput[] | AmenitiesUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: AmenitiesCreateOrConnectWithoutHotelInput | AmenitiesCreateOrConnectWithoutHotelInput[]
    upsert?: AmenitiesUpsertWithWhereUniqueWithoutHotelInput | AmenitiesUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: AmenitiesCreateManyHotelInputEnvelope
    set?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    disconnect?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    delete?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    connect?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    update?: AmenitiesUpdateWithWhereUniqueWithoutHotelInput | AmenitiesUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: AmenitiesUpdateManyWithWhereWithoutHotelInput | AmenitiesUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: AmenitiesScalarWhereInput | AmenitiesScalarWhereInput[]
  }

  export type TVChannelsUpdateManyWithoutHotelNestedInput = {
    create?: XOR<TVChannelsCreateWithoutHotelInput, TVChannelsUncheckedCreateWithoutHotelInput> | TVChannelsCreateWithoutHotelInput[] | TVChannelsUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: TVChannelsCreateOrConnectWithoutHotelInput | TVChannelsCreateOrConnectWithoutHotelInput[]
    upsert?: TVChannelsUpsertWithWhereUniqueWithoutHotelInput | TVChannelsUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: TVChannelsCreateManyHotelInputEnvelope
    set?: TVChannelsWhereUniqueInput | TVChannelsWhereUniqueInput[]
    disconnect?: TVChannelsWhereUniqueInput | TVChannelsWhereUniqueInput[]
    delete?: TVChannelsWhereUniqueInput | TVChannelsWhereUniqueInput[]
    connect?: TVChannelsWhereUniqueInput | TVChannelsWhereUniqueInput[]
    update?: TVChannelsUpdateWithWhereUniqueWithoutHotelInput | TVChannelsUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: TVChannelsUpdateManyWithWhereWithoutHotelInput | TVChannelsUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: TVChannelsScalarWhereInput | TVChannelsScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<ActivityCreateWithoutHotelInput, ActivityUncheckedCreateWithoutHotelInput> | ActivityCreateWithoutHotelInput[] | ActivityUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutHotelInput | ActivityCreateOrConnectWithoutHotelInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutHotelInput | ActivityUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: ActivityCreateManyHotelInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutHotelInput | ActivityUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutHotelInput | ActivityUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type TourUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<TourCreateWithoutHotelInput, TourUncheckedCreateWithoutHotelInput> | TourCreateWithoutHotelInput[] | TourUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: TourCreateOrConnectWithoutHotelInput | TourCreateOrConnectWithoutHotelInput[]
    upsert?: TourUpsertWithWhereUniqueWithoutHotelInput | TourUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: TourCreateManyHotelInputEnvelope
    set?: TourWhereUniqueInput | TourWhereUniqueInput[]
    disconnect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    delete?: TourWhereUniqueInput | TourWhereUniqueInput[]
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    update?: TourUpdateWithWhereUniqueWithoutHotelInput | TourUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: TourUpdateManyWithWhereWithoutHotelInput | TourUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: TourScalarWhereInput | TourScalarWhereInput[]
  }

  export type SpaUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<SpaCreateWithoutHotelInput, SpaUncheckedCreateWithoutHotelInput> | SpaCreateWithoutHotelInput[] | SpaUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: SpaCreateOrConnectWithoutHotelInput | SpaCreateOrConnectWithoutHotelInput[]
    upsert?: SpaUpsertWithWhereUniqueWithoutHotelInput | SpaUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: SpaCreateManyHotelInputEnvelope
    set?: SpaWhereUniqueInput | SpaWhereUniqueInput[]
    disconnect?: SpaWhereUniqueInput | SpaWhereUniqueInput[]
    delete?: SpaWhereUniqueInput | SpaWhereUniqueInput[]
    connect?: SpaWhereUniqueInput | SpaWhereUniqueInput[]
    update?: SpaUpdateWithWhereUniqueWithoutHotelInput | SpaUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: SpaUpdateManyWithWhereWithoutHotelInput | SpaUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: SpaScalarWhereInput | SpaScalarWhereInput[]
  }

  export type AmenitiesUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<AmenitiesCreateWithoutHotelInput, AmenitiesUncheckedCreateWithoutHotelInput> | AmenitiesCreateWithoutHotelInput[] | AmenitiesUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: AmenitiesCreateOrConnectWithoutHotelInput | AmenitiesCreateOrConnectWithoutHotelInput[]
    upsert?: AmenitiesUpsertWithWhereUniqueWithoutHotelInput | AmenitiesUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: AmenitiesCreateManyHotelInputEnvelope
    set?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    disconnect?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    delete?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    connect?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    update?: AmenitiesUpdateWithWhereUniqueWithoutHotelInput | AmenitiesUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: AmenitiesUpdateManyWithWhereWithoutHotelInput | AmenitiesUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: AmenitiesScalarWhereInput | AmenitiesScalarWhereInput[]
  }

  export type TVChannelsUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<TVChannelsCreateWithoutHotelInput, TVChannelsUncheckedCreateWithoutHotelInput> | TVChannelsCreateWithoutHotelInput[] | TVChannelsUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: TVChannelsCreateOrConnectWithoutHotelInput | TVChannelsCreateOrConnectWithoutHotelInput[]
    upsert?: TVChannelsUpsertWithWhereUniqueWithoutHotelInput | TVChannelsUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: TVChannelsCreateManyHotelInputEnvelope
    set?: TVChannelsWhereUniqueInput | TVChannelsWhereUniqueInput[]
    disconnect?: TVChannelsWhereUniqueInput | TVChannelsWhereUniqueInput[]
    delete?: TVChannelsWhereUniqueInput | TVChannelsWhereUniqueInput[]
    connect?: TVChannelsWhereUniqueInput | TVChannelsWhereUniqueInput[]
    update?: TVChannelsUpdateWithWhereUniqueWithoutHotelInput | TVChannelsUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: TVChannelsUpdateManyWithWhereWithoutHotelInput | TVChannelsUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: TVChannelsScalarWhereInput | TVChannelsScalarWhereInput[]
  }

  export type HotelCreateNestedOneWithoutAmenitiesInput = {
    create?: XOR<HotelCreateWithoutAmenitiesInput, HotelUncheckedCreateWithoutAmenitiesInput>
    connectOrCreate?: HotelCreateOrConnectWithoutAmenitiesInput
    connect?: HotelWhereUniqueInput
  }

  export type EnumAMENITIESTYPEFieldUpdateOperationsInput = {
    set?: $Enums.AMENITIESTYPE
  }

  export type HotelUpdateOneWithoutAmenitiesNestedInput = {
    create?: XOR<HotelCreateWithoutAmenitiesInput, HotelUncheckedCreateWithoutAmenitiesInput>
    connectOrCreate?: HotelCreateOrConnectWithoutAmenitiesInput
    upsert?: HotelUpsertWithoutAmenitiesInput
    disconnect?: HotelWhereInput | boolean
    delete?: HotelWhereInput | boolean
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutAmenitiesInput, HotelUpdateWithoutAmenitiesInput>, HotelUncheckedUpdateWithoutAmenitiesInput>
  }

  export type TourCreateNestedOneWithoutPricecategoryInput = {
    create?: XOR<TourCreateWithoutPricecategoryInput, TourUncheckedCreateWithoutPricecategoryInput>
    connectOrCreate?: TourCreateOrConnectWithoutPricecategoryInput
    connect?: TourWhereUniqueInput
  }

  export type TourUpdateOneWithoutPricecategoryNestedInput = {
    create?: XOR<TourCreateWithoutPricecategoryInput, TourUncheckedCreateWithoutPricecategoryInput>
    connectOrCreate?: TourCreateOrConnectWithoutPricecategoryInput
    upsert?: TourUpsertWithoutPricecategoryInput
    disconnect?: TourWhereInput | boolean
    delete?: TourWhereInput | boolean
    connect?: TourWhereUniqueInput
    update?: XOR<XOR<TourUpdateToOneWithWhereWithoutPricecategoryInput, TourUpdateWithoutPricecategoryInput>, TourUncheckedUpdateWithoutPricecategoryInput>
  }

  export type TourCreateincludedInput = {
    set: string[]
  }

  export type TourCreateofferedInput = {
    set: string[]
  }

  export type TourCreatevideosInput = {
    set: string[]
  }

  export type TourCreateimagesInput = {
    set: string[]
  }

  export type TourPriceCategoryCreateNestedManyWithoutTourInput = {
    create?: XOR<TourPriceCategoryCreateWithoutTourInput, TourPriceCategoryUncheckedCreateWithoutTourInput> | TourPriceCategoryCreateWithoutTourInput[] | TourPriceCategoryUncheckedCreateWithoutTourInput[]
    connectOrCreate?: TourPriceCategoryCreateOrConnectWithoutTourInput | TourPriceCategoryCreateOrConnectWithoutTourInput[]
    createMany?: TourPriceCategoryCreateManyTourInputEnvelope
    connect?: TourPriceCategoryWhereUniqueInput | TourPriceCategoryWhereUniqueInput[]
  }

  export type HotelCreateNestedOneWithoutToursInput = {
    create?: XOR<HotelCreateWithoutToursInput, HotelUncheckedCreateWithoutToursInput>
    connectOrCreate?: HotelCreateOrConnectWithoutToursInput
    connect?: HotelWhereUniqueInput
  }

  export type TourPriceCategoryUncheckedCreateNestedManyWithoutTourInput = {
    create?: XOR<TourPriceCategoryCreateWithoutTourInput, TourPriceCategoryUncheckedCreateWithoutTourInput> | TourPriceCategoryCreateWithoutTourInput[] | TourPriceCategoryUncheckedCreateWithoutTourInput[]
    connectOrCreate?: TourPriceCategoryCreateOrConnectWithoutTourInput | TourPriceCategoryCreateOrConnectWithoutTourInput[]
    createMany?: TourPriceCategoryCreateManyTourInputEnvelope
    connect?: TourPriceCategoryWhereUniqueInput | TourPriceCategoryWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TourUpdateincludedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TourUpdateofferedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TourUpdatevideosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TourUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TourPriceCategoryUpdateManyWithoutTourNestedInput = {
    create?: XOR<TourPriceCategoryCreateWithoutTourInput, TourPriceCategoryUncheckedCreateWithoutTourInput> | TourPriceCategoryCreateWithoutTourInput[] | TourPriceCategoryUncheckedCreateWithoutTourInput[]
    connectOrCreate?: TourPriceCategoryCreateOrConnectWithoutTourInput | TourPriceCategoryCreateOrConnectWithoutTourInput[]
    upsert?: TourPriceCategoryUpsertWithWhereUniqueWithoutTourInput | TourPriceCategoryUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: TourPriceCategoryCreateManyTourInputEnvelope
    set?: TourPriceCategoryWhereUniqueInput | TourPriceCategoryWhereUniqueInput[]
    disconnect?: TourPriceCategoryWhereUniqueInput | TourPriceCategoryWhereUniqueInput[]
    delete?: TourPriceCategoryWhereUniqueInput | TourPriceCategoryWhereUniqueInput[]
    connect?: TourPriceCategoryWhereUniqueInput | TourPriceCategoryWhereUniqueInput[]
    update?: TourPriceCategoryUpdateWithWhereUniqueWithoutTourInput | TourPriceCategoryUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: TourPriceCategoryUpdateManyWithWhereWithoutTourInput | TourPriceCategoryUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: TourPriceCategoryScalarWhereInput | TourPriceCategoryScalarWhereInput[]
  }

  export type HotelUpdateOneRequiredWithoutToursNestedInput = {
    create?: XOR<HotelCreateWithoutToursInput, HotelUncheckedCreateWithoutToursInput>
    connectOrCreate?: HotelCreateOrConnectWithoutToursInput
    upsert?: HotelUpsertWithoutToursInput
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutToursInput, HotelUpdateWithoutToursInput>, HotelUncheckedUpdateWithoutToursInput>
  }

  export type TourPriceCategoryUncheckedUpdateManyWithoutTourNestedInput = {
    create?: XOR<TourPriceCategoryCreateWithoutTourInput, TourPriceCategoryUncheckedCreateWithoutTourInput> | TourPriceCategoryCreateWithoutTourInput[] | TourPriceCategoryUncheckedCreateWithoutTourInput[]
    connectOrCreate?: TourPriceCategoryCreateOrConnectWithoutTourInput | TourPriceCategoryCreateOrConnectWithoutTourInput[]
    upsert?: TourPriceCategoryUpsertWithWhereUniqueWithoutTourInput | TourPriceCategoryUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: TourPriceCategoryCreateManyTourInputEnvelope
    set?: TourPriceCategoryWhereUniqueInput | TourPriceCategoryWhereUniqueInput[]
    disconnect?: TourPriceCategoryWhereUniqueInput | TourPriceCategoryWhereUniqueInput[]
    delete?: TourPriceCategoryWhereUniqueInput | TourPriceCategoryWhereUniqueInput[]
    connect?: TourPriceCategoryWhereUniqueInput | TourPriceCategoryWhereUniqueInput[]
    update?: TourPriceCategoryUpdateWithWhereUniqueWithoutTourInput | TourPriceCategoryUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: TourPriceCategoryUpdateManyWithWhereWithoutTourInput | TourPriceCategoryUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: TourPriceCategoryScalarWhereInput | TourPriceCategoryScalarWhereInput[]
  }

  export type ActivityCreaterecurrenceDaysInput = {
    set: string[]
  }

  export type HotelCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<HotelCreateWithoutActivitiesInput, HotelUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: HotelCreateOrConnectWithoutActivitiesInput
    connect?: HotelWhereUniqueInput
  }

  export type EnumRECURRINGPATTERNFieldUpdateOperationsInput = {
    set?: $Enums.RECURRINGPATTERN
  }

  export type ActivityUpdaterecurrenceDaysInput = {
    set?: string[]
    push?: string | string[]
  }

  export type HotelUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<HotelCreateWithoutActivitiesInput, HotelUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: HotelCreateOrConnectWithoutActivitiesInput
    upsert?: HotelUpsertWithoutActivitiesInput
    disconnect?: HotelWhereInput | boolean
    delete?: HotelWhereInput | boolean
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutActivitiesInput, HotelUpdateWithoutActivitiesInput>, HotelUncheckedUpdateWithoutActivitiesInput>
  }

  export type SpaCreateNestedOneWithoutPricecategoryInput = {
    create?: XOR<SpaCreateWithoutPricecategoryInput, SpaUncheckedCreateWithoutPricecategoryInput>
    connectOrCreate?: SpaCreateOrConnectWithoutPricecategoryInput
    connect?: SpaWhereUniqueInput
  }

  export type SpaUpdateOneWithoutPricecategoryNestedInput = {
    create?: XOR<SpaCreateWithoutPricecategoryInput, SpaUncheckedCreateWithoutPricecategoryInput>
    connectOrCreate?: SpaCreateOrConnectWithoutPricecategoryInput
    upsert?: SpaUpsertWithoutPricecategoryInput
    disconnect?: SpaWhereInput | boolean
    delete?: SpaWhereInput | boolean
    connect?: SpaWhereUniqueInput
    update?: XOR<XOR<SpaUpdateToOneWithWhereWithoutPricecategoryInput, SpaUpdateWithoutPricecategoryInput>, SpaUncheckedUpdateWithoutPricecategoryInput>
  }

  export type SpaCreatevideosInput = {
    set: string[]
  }

  export type SpaCreateimagesInput = {
    set: string[]
  }

  export type SpaPriceCategoryCreateNestedManyWithoutSpaInput = {
    create?: XOR<SpaPriceCategoryCreateWithoutSpaInput, SpaPriceCategoryUncheckedCreateWithoutSpaInput> | SpaPriceCategoryCreateWithoutSpaInput[] | SpaPriceCategoryUncheckedCreateWithoutSpaInput[]
    connectOrCreate?: SpaPriceCategoryCreateOrConnectWithoutSpaInput | SpaPriceCategoryCreateOrConnectWithoutSpaInput[]
    createMany?: SpaPriceCategoryCreateManySpaInputEnvelope
    connect?: SpaPriceCategoryWhereUniqueInput | SpaPriceCategoryWhereUniqueInput[]
  }

  export type HotelCreateNestedOneWithoutSpaInput = {
    create?: XOR<HotelCreateWithoutSpaInput, HotelUncheckedCreateWithoutSpaInput>
    connectOrCreate?: HotelCreateOrConnectWithoutSpaInput
    connect?: HotelWhereUniqueInput
  }

  export type SpaPriceCategoryUncheckedCreateNestedManyWithoutSpaInput = {
    create?: XOR<SpaPriceCategoryCreateWithoutSpaInput, SpaPriceCategoryUncheckedCreateWithoutSpaInput> | SpaPriceCategoryCreateWithoutSpaInput[] | SpaPriceCategoryUncheckedCreateWithoutSpaInput[]
    connectOrCreate?: SpaPriceCategoryCreateOrConnectWithoutSpaInput | SpaPriceCategoryCreateOrConnectWithoutSpaInput[]
    createMany?: SpaPriceCategoryCreateManySpaInputEnvelope
    connect?: SpaPriceCategoryWhereUniqueInput | SpaPriceCategoryWhereUniqueInput[]
  }

  export type SpaUpdatevideosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SpaUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SpaPriceCategoryUpdateManyWithoutSpaNestedInput = {
    create?: XOR<SpaPriceCategoryCreateWithoutSpaInput, SpaPriceCategoryUncheckedCreateWithoutSpaInput> | SpaPriceCategoryCreateWithoutSpaInput[] | SpaPriceCategoryUncheckedCreateWithoutSpaInput[]
    connectOrCreate?: SpaPriceCategoryCreateOrConnectWithoutSpaInput | SpaPriceCategoryCreateOrConnectWithoutSpaInput[]
    upsert?: SpaPriceCategoryUpsertWithWhereUniqueWithoutSpaInput | SpaPriceCategoryUpsertWithWhereUniqueWithoutSpaInput[]
    createMany?: SpaPriceCategoryCreateManySpaInputEnvelope
    set?: SpaPriceCategoryWhereUniqueInput | SpaPriceCategoryWhereUniqueInput[]
    disconnect?: SpaPriceCategoryWhereUniqueInput | SpaPriceCategoryWhereUniqueInput[]
    delete?: SpaPriceCategoryWhereUniqueInput | SpaPriceCategoryWhereUniqueInput[]
    connect?: SpaPriceCategoryWhereUniqueInput | SpaPriceCategoryWhereUniqueInput[]
    update?: SpaPriceCategoryUpdateWithWhereUniqueWithoutSpaInput | SpaPriceCategoryUpdateWithWhereUniqueWithoutSpaInput[]
    updateMany?: SpaPriceCategoryUpdateManyWithWhereWithoutSpaInput | SpaPriceCategoryUpdateManyWithWhereWithoutSpaInput[]
    deleteMany?: SpaPriceCategoryScalarWhereInput | SpaPriceCategoryScalarWhereInput[]
  }

  export type HotelUpdateOneWithoutSpaNestedInput = {
    create?: XOR<HotelCreateWithoutSpaInput, HotelUncheckedCreateWithoutSpaInput>
    connectOrCreate?: HotelCreateOrConnectWithoutSpaInput
    upsert?: HotelUpsertWithoutSpaInput
    disconnect?: HotelWhereInput | boolean
    delete?: HotelWhereInput | boolean
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutSpaInput, HotelUpdateWithoutSpaInput>, HotelUncheckedUpdateWithoutSpaInput>
  }

  export type SpaPriceCategoryUncheckedUpdateManyWithoutSpaNestedInput = {
    create?: XOR<SpaPriceCategoryCreateWithoutSpaInput, SpaPriceCategoryUncheckedCreateWithoutSpaInput> | SpaPriceCategoryCreateWithoutSpaInput[] | SpaPriceCategoryUncheckedCreateWithoutSpaInput[]
    connectOrCreate?: SpaPriceCategoryCreateOrConnectWithoutSpaInput | SpaPriceCategoryCreateOrConnectWithoutSpaInput[]
    upsert?: SpaPriceCategoryUpsertWithWhereUniqueWithoutSpaInput | SpaPriceCategoryUpsertWithWhereUniqueWithoutSpaInput[]
    createMany?: SpaPriceCategoryCreateManySpaInputEnvelope
    set?: SpaPriceCategoryWhereUniqueInput | SpaPriceCategoryWhereUniqueInput[]
    disconnect?: SpaPriceCategoryWhereUniqueInput | SpaPriceCategoryWhereUniqueInput[]
    delete?: SpaPriceCategoryWhereUniqueInput | SpaPriceCategoryWhereUniqueInput[]
    connect?: SpaPriceCategoryWhereUniqueInput | SpaPriceCategoryWhereUniqueInput[]
    update?: SpaPriceCategoryUpdateWithWhereUniqueWithoutSpaInput | SpaPriceCategoryUpdateWithWhereUniqueWithoutSpaInput[]
    updateMany?: SpaPriceCategoryUpdateManyWithWhereWithoutSpaInput | SpaPriceCategoryUpdateManyWithWhereWithoutSpaInput[]
    deleteMany?: SpaPriceCategoryScalarWhereInput | SpaPriceCategoryScalarWhereInput[]
  }

  export type HotelCreateNestedOneWithoutTvchannelsInput = {
    create?: XOR<HotelCreateWithoutTvchannelsInput, HotelUncheckedCreateWithoutTvchannelsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutTvchannelsInput
    connect?: HotelWhereUniqueInput
  }

  export type EnumTVChannelLanguagesFieldUpdateOperationsInput = {
    set?: $Enums.TVChannelLanguages
  }

  export type EnumTVCHANNELTYPEFieldUpdateOperationsInput = {
    set?: $Enums.TVCHANNELTYPE
  }

  export type HotelUpdateOneWithoutTvchannelsNestedInput = {
    create?: XOR<HotelCreateWithoutTvchannelsInput, HotelUncheckedCreateWithoutTvchannelsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutTvchannelsInput
    upsert?: HotelUpsertWithoutTvchannelsInput
    disconnect?: HotelWhereInput | boolean
    delete?: HotelWhereInput | boolean
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutTvchannelsInput, HotelUpdateWithoutTvchannelsInput>, HotelUncheckedUpdateWithoutTvchannelsInput>
  }

  export type CategoryCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<CategoryCreateWithoutRestaurantInput, CategoryUncheckedCreateWithoutRestaurantInput> | CategoryCreateWithoutRestaurantInput[] | CategoryUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutRestaurantInput | CategoryCreateOrConnectWithoutRestaurantInput[]
    createMany?: CategoryCreateManyRestaurantInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type DishCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<DishCreateWithoutRestaurantInput, DishUncheckedCreateWithoutRestaurantInput> | DishCreateWithoutRestaurantInput[] | DishUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: DishCreateOrConnectWithoutRestaurantInput | DishCreateOrConnectWithoutRestaurantInput[]
    createMany?: DishCreateManyRestaurantInputEnvelope
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
  }

  export type MenuCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<MenuCreateWithoutRestaurantInput, MenuUncheckedCreateWithoutRestaurantInput> | MenuCreateWithoutRestaurantInput[] | MenuUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutRestaurantInput | MenuCreateOrConnectWithoutRestaurantInput[]
    createMany?: MenuCreateManyRestaurantInputEnvelope
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
  }

  export type TableCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<TableCreateWithoutRestaurantInput, TableUncheckedCreateWithoutRestaurantInput> | TableCreateWithoutRestaurantInput[] | TableUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: TableCreateOrConnectWithoutRestaurantInput | TableCreateOrConnectWithoutRestaurantInput[]
    createMany?: TableCreateManyRestaurantInputEnvelope
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
  }

  export type ReservationCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<ReservationCreateWithoutRestaurantInput, ReservationUncheckedCreateWithoutRestaurantInput> | ReservationCreateWithoutRestaurantInput[] | ReservationUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutRestaurantInput | ReservationCreateOrConnectWithoutRestaurantInput[]
    createMany?: ReservationCreateManyRestaurantInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type OpeningHoursCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<OpeningHoursCreateWithoutRestaurantInput, OpeningHoursUncheckedCreateWithoutRestaurantInput> | OpeningHoursCreateWithoutRestaurantInput[] | OpeningHoursUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: OpeningHoursCreateOrConnectWithoutRestaurantInput | OpeningHoursCreateOrConnectWithoutRestaurantInput[]
    createMany?: OpeningHoursCreateManyRestaurantInputEnvelope
    connect?: OpeningHoursWhereUniqueInput | OpeningHoursWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<CategoryCreateWithoutRestaurantInput, CategoryUncheckedCreateWithoutRestaurantInput> | CategoryCreateWithoutRestaurantInput[] | CategoryUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutRestaurantInput | CategoryCreateOrConnectWithoutRestaurantInput[]
    createMany?: CategoryCreateManyRestaurantInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type DishUncheckedCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<DishCreateWithoutRestaurantInput, DishUncheckedCreateWithoutRestaurantInput> | DishCreateWithoutRestaurantInput[] | DishUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: DishCreateOrConnectWithoutRestaurantInput | DishCreateOrConnectWithoutRestaurantInput[]
    createMany?: DishCreateManyRestaurantInputEnvelope
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
  }

  export type MenuUncheckedCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<MenuCreateWithoutRestaurantInput, MenuUncheckedCreateWithoutRestaurantInput> | MenuCreateWithoutRestaurantInput[] | MenuUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutRestaurantInput | MenuCreateOrConnectWithoutRestaurantInput[]
    createMany?: MenuCreateManyRestaurantInputEnvelope
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
  }

  export type TableUncheckedCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<TableCreateWithoutRestaurantInput, TableUncheckedCreateWithoutRestaurantInput> | TableCreateWithoutRestaurantInput[] | TableUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: TableCreateOrConnectWithoutRestaurantInput | TableCreateOrConnectWithoutRestaurantInput[]
    createMany?: TableCreateManyRestaurantInputEnvelope
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<ReservationCreateWithoutRestaurantInput, ReservationUncheckedCreateWithoutRestaurantInput> | ReservationCreateWithoutRestaurantInput[] | ReservationUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutRestaurantInput | ReservationCreateOrConnectWithoutRestaurantInput[]
    createMany?: ReservationCreateManyRestaurantInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type OpeningHoursUncheckedCreateNestedManyWithoutRestaurantInput = {
    create?: XOR<OpeningHoursCreateWithoutRestaurantInput, OpeningHoursUncheckedCreateWithoutRestaurantInput> | OpeningHoursCreateWithoutRestaurantInput[] | OpeningHoursUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: OpeningHoursCreateOrConnectWithoutRestaurantInput | OpeningHoursCreateOrConnectWithoutRestaurantInput[]
    createMany?: OpeningHoursCreateManyRestaurantInputEnvelope
    connect?: OpeningHoursWhereUniqueInput | OpeningHoursWhereUniqueInput[]
  }

  export type CategoryUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<CategoryCreateWithoutRestaurantInput, CategoryUncheckedCreateWithoutRestaurantInput> | CategoryCreateWithoutRestaurantInput[] | CategoryUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutRestaurantInput | CategoryCreateOrConnectWithoutRestaurantInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutRestaurantInput | CategoryUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: CategoryCreateManyRestaurantInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutRestaurantInput | CategoryUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutRestaurantInput | CategoryUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type DishUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<DishCreateWithoutRestaurantInput, DishUncheckedCreateWithoutRestaurantInput> | DishCreateWithoutRestaurantInput[] | DishUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: DishCreateOrConnectWithoutRestaurantInput | DishCreateOrConnectWithoutRestaurantInput[]
    upsert?: DishUpsertWithWhereUniqueWithoutRestaurantInput | DishUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: DishCreateManyRestaurantInputEnvelope
    set?: DishWhereUniqueInput | DishWhereUniqueInput[]
    disconnect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    delete?: DishWhereUniqueInput | DishWhereUniqueInput[]
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    update?: DishUpdateWithWhereUniqueWithoutRestaurantInput | DishUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: DishUpdateManyWithWhereWithoutRestaurantInput | DishUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: DishScalarWhereInput | DishScalarWhereInput[]
  }

  export type MenuUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<MenuCreateWithoutRestaurantInput, MenuUncheckedCreateWithoutRestaurantInput> | MenuCreateWithoutRestaurantInput[] | MenuUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutRestaurantInput | MenuCreateOrConnectWithoutRestaurantInput[]
    upsert?: MenuUpsertWithWhereUniqueWithoutRestaurantInput | MenuUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: MenuCreateManyRestaurantInputEnvelope
    set?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    disconnect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    delete?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    update?: MenuUpdateWithWhereUniqueWithoutRestaurantInput | MenuUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: MenuUpdateManyWithWhereWithoutRestaurantInput | MenuUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: MenuScalarWhereInput | MenuScalarWhereInput[]
  }

  export type TableUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<TableCreateWithoutRestaurantInput, TableUncheckedCreateWithoutRestaurantInput> | TableCreateWithoutRestaurantInput[] | TableUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: TableCreateOrConnectWithoutRestaurantInput | TableCreateOrConnectWithoutRestaurantInput[]
    upsert?: TableUpsertWithWhereUniqueWithoutRestaurantInput | TableUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: TableCreateManyRestaurantInputEnvelope
    set?: TableWhereUniqueInput | TableWhereUniqueInput[]
    disconnect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    delete?: TableWhereUniqueInput | TableWhereUniqueInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    update?: TableUpdateWithWhereUniqueWithoutRestaurantInput | TableUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: TableUpdateManyWithWhereWithoutRestaurantInput | TableUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: TableScalarWhereInput | TableScalarWhereInput[]
  }

  export type ReservationUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<ReservationCreateWithoutRestaurantInput, ReservationUncheckedCreateWithoutRestaurantInput> | ReservationCreateWithoutRestaurantInput[] | ReservationUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutRestaurantInput | ReservationCreateOrConnectWithoutRestaurantInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutRestaurantInput | ReservationUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: ReservationCreateManyRestaurantInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutRestaurantInput | ReservationUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutRestaurantInput | ReservationUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type OpeningHoursUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<OpeningHoursCreateWithoutRestaurantInput, OpeningHoursUncheckedCreateWithoutRestaurantInput> | OpeningHoursCreateWithoutRestaurantInput[] | OpeningHoursUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: OpeningHoursCreateOrConnectWithoutRestaurantInput | OpeningHoursCreateOrConnectWithoutRestaurantInput[]
    upsert?: OpeningHoursUpsertWithWhereUniqueWithoutRestaurantInput | OpeningHoursUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: OpeningHoursCreateManyRestaurantInputEnvelope
    set?: OpeningHoursWhereUniqueInput | OpeningHoursWhereUniqueInput[]
    disconnect?: OpeningHoursWhereUniqueInput | OpeningHoursWhereUniqueInput[]
    delete?: OpeningHoursWhereUniqueInput | OpeningHoursWhereUniqueInput[]
    connect?: OpeningHoursWhereUniqueInput | OpeningHoursWhereUniqueInput[]
    update?: OpeningHoursUpdateWithWhereUniqueWithoutRestaurantInput | OpeningHoursUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: OpeningHoursUpdateManyWithWhereWithoutRestaurantInput | OpeningHoursUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: OpeningHoursScalarWhereInput | OpeningHoursScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<CategoryCreateWithoutRestaurantInput, CategoryUncheckedCreateWithoutRestaurantInput> | CategoryCreateWithoutRestaurantInput[] | CategoryUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutRestaurantInput | CategoryCreateOrConnectWithoutRestaurantInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutRestaurantInput | CategoryUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: CategoryCreateManyRestaurantInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutRestaurantInput | CategoryUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutRestaurantInput | CategoryUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type DishUncheckedUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<DishCreateWithoutRestaurantInput, DishUncheckedCreateWithoutRestaurantInput> | DishCreateWithoutRestaurantInput[] | DishUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: DishCreateOrConnectWithoutRestaurantInput | DishCreateOrConnectWithoutRestaurantInput[]
    upsert?: DishUpsertWithWhereUniqueWithoutRestaurantInput | DishUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: DishCreateManyRestaurantInputEnvelope
    set?: DishWhereUniqueInput | DishWhereUniqueInput[]
    disconnect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    delete?: DishWhereUniqueInput | DishWhereUniqueInput[]
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    update?: DishUpdateWithWhereUniqueWithoutRestaurantInput | DishUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: DishUpdateManyWithWhereWithoutRestaurantInput | DishUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: DishScalarWhereInput | DishScalarWhereInput[]
  }

  export type MenuUncheckedUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<MenuCreateWithoutRestaurantInput, MenuUncheckedCreateWithoutRestaurantInput> | MenuCreateWithoutRestaurantInput[] | MenuUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutRestaurantInput | MenuCreateOrConnectWithoutRestaurantInput[]
    upsert?: MenuUpsertWithWhereUniqueWithoutRestaurantInput | MenuUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: MenuCreateManyRestaurantInputEnvelope
    set?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    disconnect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    delete?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    update?: MenuUpdateWithWhereUniqueWithoutRestaurantInput | MenuUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: MenuUpdateManyWithWhereWithoutRestaurantInput | MenuUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: MenuScalarWhereInput | MenuScalarWhereInput[]
  }

  export type TableUncheckedUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<TableCreateWithoutRestaurantInput, TableUncheckedCreateWithoutRestaurantInput> | TableCreateWithoutRestaurantInput[] | TableUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: TableCreateOrConnectWithoutRestaurantInput | TableCreateOrConnectWithoutRestaurantInput[]
    upsert?: TableUpsertWithWhereUniqueWithoutRestaurantInput | TableUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: TableCreateManyRestaurantInputEnvelope
    set?: TableWhereUniqueInput | TableWhereUniqueInput[]
    disconnect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    delete?: TableWhereUniqueInput | TableWhereUniqueInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    update?: TableUpdateWithWhereUniqueWithoutRestaurantInput | TableUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: TableUpdateManyWithWhereWithoutRestaurantInput | TableUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: TableScalarWhereInput | TableScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<ReservationCreateWithoutRestaurantInput, ReservationUncheckedCreateWithoutRestaurantInput> | ReservationCreateWithoutRestaurantInput[] | ReservationUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutRestaurantInput | ReservationCreateOrConnectWithoutRestaurantInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutRestaurantInput | ReservationUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: ReservationCreateManyRestaurantInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutRestaurantInput | ReservationUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutRestaurantInput | ReservationUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type OpeningHoursUncheckedUpdateManyWithoutRestaurantNestedInput = {
    create?: XOR<OpeningHoursCreateWithoutRestaurantInput, OpeningHoursUncheckedCreateWithoutRestaurantInput> | OpeningHoursCreateWithoutRestaurantInput[] | OpeningHoursUncheckedCreateWithoutRestaurantInput[]
    connectOrCreate?: OpeningHoursCreateOrConnectWithoutRestaurantInput | OpeningHoursCreateOrConnectWithoutRestaurantInput[]
    upsert?: OpeningHoursUpsertWithWhereUniqueWithoutRestaurantInput | OpeningHoursUpsertWithWhereUniqueWithoutRestaurantInput[]
    createMany?: OpeningHoursCreateManyRestaurantInputEnvelope
    set?: OpeningHoursWhereUniqueInput | OpeningHoursWhereUniqueInput[]
    disconnect?: OpeningHoursWhereUniqueInput | OpeningHoursWhereUniqueInput[]
    delete?: OpeningHoursWhereUniqueInput | OpeningHoursWhereUniqueInput[]
    connect?: OpeningHoursWhereUniqueInput | OpeningHoursWhereUniqueInput[]
    update?: OpeningHoursUpdateWithWhereUniqueWithoutRestaurantInput | OpeningHoursUpdateWithWhereUniqueWithoutRestaurantInput[]
    updateMany?: OpeningHoursUpdateManyWithWhereWithoutRestaurantInput | OpeningHoursUpdateManyWithWhereWithoutRestaurantInput[]
    deleteMany?: OpeningHoursScalarWhereInput | OpeningHoursScalarWhereInput[]
  }

  export type RestaurantCreateNestedOneWithoutMenusInput = {
    create?: XOR<RestaurantCreateWithoutMenusInput, RestaurantUncheckedCreateWithoutMenusInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutMenusInput
    connect?: RestaurantWhereUniqueInput
  }

  export type DishCreateNestedManyWithoutMenuInput = {
    create?: XOR<DishCreateWithoutMenuInput, DishUncheckedCreateWithoutMenuInput> | DishCreateWithoutMenuInput[] | DishUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: DishCreateOrConnectWithoutMenuInput | DishCreateOrConnectWithoutMenuInput[]
    createMany?: DishCreateManyMenuInputEnvelope
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
  }

  export type DishUncheckedCreateNestedManyWithoutMenuInput = {
    create?: XOR<DishCreateWithoutMenuInput, DishUncheckedCreateWithoutMenuInput> | DishCreateWithoutMenuInput[] | DishUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: DishCreateOrConnectWithoutMenuInput | DishCreateOrConnectWithoutMenuInput[]
    createMany?: DishCreateManyMenuInputEnvelope
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RestaurantUpdateOneRequiredWithoutMenusNestedInput = {
    create?: XOR<RestaurantCreateWithoutMenusInput, RestaurantUncheckedCreateWithoutMenusInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutMenusInput
    upsert?: RestaurantUpsertWithoutMenusInput
    connect?: RestaurantWhereUniqueInput
    update?: XOR<XOR<RestaurantUpdateToOneWithWhereWithoutMenusInput, RestaurantUpdateWithoutMenusInput>, RestaurantUncheckedUpdateWithoutMenusInput>
  }

  export type DishUpdateManyWithoutMenuNestedInput = {
    create?: XOR<DishCreateWithoutMenuInput, DishUncheckedCreateWithoutMenuInput> | DishCreateWithoutMenuInput[] | DishUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: DishCreateOrConnectWithoutMenuInput | DishCreateOrConnectWithoutMenuInput[]
    upsert?: DishUpsertWithWhereUniqueWithoutMenuInput | DishUpsertWithWhereUniqueWithoutMenuInput[]
    createMany?: DishCreateManyMenuInputEnvelope
    set?: DishWhereUniqueInput | DishWhereUniqueInput[]
    disconnect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    delete?: DishWhereUniqueInput | DishWhereUniqueInput[]
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    update?: DishUpdateWithWhereUniqueWithoutMenuInput | DishUpdateWithWhereUniqueWithoutMenuInput[]
    updateMany?: DishUpdateManyWithWhereWithoutMenuInput | DishUpdateManyWithWhereWithoutMenuInput[]
    deleteMany?: DishScalarWhereInput | DishScalarWhereInput[]
  }

  export type DishUncheckedUpdateManyWithoutMenuNestedInput = {
    create?: XOR<DishCreateWithoutMenuInput, DishUncheckedCreateWithoutMenuInput> | DishCreateWithoutMenuInput[] | DishUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: DishCreateOrConnectWithoutMenuInput | DishCreateOrConnectWithoutMenuInput[]
    upsert?: DishUpsertWithWhereUniqueWithoutMenuInput | DishUpsertWithWhereUniqueWithoutMenuInput[]
    createMany?: DishCreateManyMenuInputEnvelope
    set?: DishWhereUniqueInput | DishWhereUniqueInput[]
    disconnect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    delete?: DishWhereUniqueInput | DishWhereUniqueInput[]
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    update?: DishUpdateWithWhereUniqueWithoutMenuInput | DishUpdateWithWhereUniqueWithoutMenuInput[]
    updateMany?: DishUpdateManyWithWhereWithoutMenuInput | DishUpdateManyWithWhereWithoutMenuInput[]
    deleteMany?: DishScalarWhereInput | DishScalarWhereInput[]
  }

  export type RestaurantCreateNestedOneWithoutTablesInput = {
    create?: XOR<RestaurantCreateWithoutTablesInput, RestaurantUncheckedCreateWithoutTablesInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutTablesInput
    connect?: RestaurantWhereUniqueInput
  }

  export type ReservationCreateNestedManyWithoutTableInput = {
    create?: XOR<ReservationCreateWithoutTableInput, ReservationUncheckedCreateWithoutTableInput> | ReservationCreateWithoutTableInput[] | ReservationUncheckedCreateWithoutTableInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutTableInput | ReservationCreateOrConnectWithoutTableInput[]
    createMany?: ReservationCreateManyTableInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutTableInput = {
    create?: XOR<ReservationCreateWithoutTableInput, ReservationUncheckedCreateWithoutTableInput> | ReservationCreateWithoutTableInput[] | ReservationUncheckedCreateWithoutTableInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutTableInput | ReservationCreateOrConnectWithoutTableInput[]
    createMany?: ReservationCreateManyTableInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type RestaurantUpdateOneRequiredWithoutTablesNestedInput = {
    create?: XOR<RestaurantCreateWithoutTablesInput, RestaurantUncheckedCreateWithoutTablesInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutTablesInput
    upsert?: RestaurantUpsertWithoutTablesInput
    connect?: RestaurantWhereUniqueInput
    update?: XOR<XOR<RestaurantUpdateToOneWithWhereWithoutTablesInput, RestaurantUpdateWithoutTablesInput>, RestaurantUncheckedUpdateWithoutTablesInput>
  }

  export type ReservationUpdateManyWithoutTableNestedInput = {
    create?: XOR<ReservationCreateWithoutTableInput, ReservationUncheckedCreateWithoutTableInput> | ReservationCreateWithoutTableInput[] | ReservationUncheckedCreateWithoutTableInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutTableInput | ReservationCreateOrConnectWithoutTableInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutTableInput | ReservationUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: ReservationCreateManyTableInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutTableInput | ReservationUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutTableInput | ReservationUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutTableNestedInput = {
    create?: XOR<ReservationCreateWithoutTableInput, ReservationUncheckedCreateWithoutTableInput> | ReservationCreateWithoutTableInput[] | ReservationUncheckedCreateWithoutTableInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutTableInput | ReservationCreateOrConnectWithoutTableInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutTableInput | ReservationUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: ReservationCreateManyTableInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutTableInput | ReservationUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutTableInput | ReservationUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type ReservationCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ReservationCreateWithoutCustomerInput, ReservationUncheckedCreateWithoutCustomerInput> | ReservationCreateWithoutCustomerInput[] | ReservationUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutCustomerInput | ReservationCreateOrConnectWithoutCustomerInput[]
    createMany?: ReservationCreateManyCustomerInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ReservationCreateWithoutCustomerInput, ReservationUncheckedCreateWithoutCustomerInput> | ReservationCreateWithoutCustomerInput[] | ReservationUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutCustomerInput | ReservationCreateOrConnectWithoutCustomerInput[]
    createMany?: ReservationCreateManyCustomerInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type ReservationUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ReservationCreateWithoutCustomerInput, ReservationUncheckedCreateWithoutCustomerInput> | ReservationCreateWithoutCustomerInput[] | ReservationUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutCustomerInput | ReservationCreateOrConnectWithoutCustomerInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutCustomerInput | ReservationUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ReservationCreateManyCustomerInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutCustomerInput | ReservationUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutCustomerInput | ReservationUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ReservationCreateWithoutCustomerInput, ReservationUncheckedCreateWithoutCustomerInput> | ReservationCreateWithoutCustomerInput[] | ReservationUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutCustomerInput | ReservationCreateOrConnectWithoutCustomerInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutCustomerInput | ReservationUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ReservationCreateManyCustomerInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutCustomerInput | ReservationUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutCustomerInput | ReservationUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutReservationsInput = {
    create?: XOR<CustomerCreateWithoutReservationsInput, CustomerUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutReservationsInput
    connect?: CustomerWhereUniqueInput
  }

  export type TableCreateNestedOneWithoutReservationsInput = {
    create?: XOR<TableCreateWithoutReservationsInput, TableUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: TableCreateOrConnectWithoutReservationsInput
    connect?: TableWhereUniqueInput
  }

  export type RestaurantCreateNestedOneWithoutReservationsInput = {
    create?: XOR<RestaurantCreateWithoutReservationsInput, RestaurantUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutReservationsInput
    connect?: RestaurantWhereUniqueInput
  }

  export type EnumReservationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReservationStatus
  }

  export type CustomerUpdateOneRequiredWithoutReservationsNestedInput = {
    create?: XOR<CustomerCreateWithoutReservationsInput, CustomerUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutReservationsInput
    upsert?: CustomerUpsertWithoutReservationsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutReservationsInput, CustomerUpdateWithoutReservationsInput>, CustomerUncheckedUpdateWithoutReservationsInput>
  }

  export type TableUpdateOneWithoutReservationsNestedInput = {
    create?: XOR<TableCreateWithoutReservationsInput, TableUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: TableCreateOrConnectWithoutReservationsInput
    upsert?: TableUpsertWithoutReservationsInput
    disconnect?: TableWhereInput | boolean
    delete?: TableWhereInput | boolean
    connect?: TableWhereUniqueInput
    update?: XOR<XOR<TableUpdateToOneWithWhereWithoutReservationsInput, TableUpdateWithoutReservationsInput>, TableUncheckedUpdateWithoutReservationsInput>
  }

  export type RestaurantUpdateOneRequiredWithoutReservationsNestedInput = {
    create?: XOR<RestaurantCreateWithoutReservationsInput, RestaurantUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutReservationsInput
    upsert?: RestaurantUpsertWithoutReservationsInput
    connect?: RestaurantWhereUniqueInput
    update?: XOR<XOR<RestaurantUpdateToOneWithWhereWithoutReservationsInput, RestaurantUpdateWithoutReservationsInput>, RestaurantUncheckedUpdateWithoutReservationsInput>
  }

  export type RestaurantCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<RestaurantCreateWithoutCategoriesInput, RestaurantUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutCategoriesInput
    connect?: RestaurantWhereUniqueInput
  }

  export type DishCreateNestedManyWithoutCategoryInput = {
    create?: XOR<DishCreateWithoutCategoryInput, DishUncheckedCreateWithoutCategoryInput> | DishCreateWithoutCategoryInput[] | DishUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: DishCreateOrConnectWithoutCategoryInput | DishCreateOrConnectWithoutCategoryInput[]
    createMany?: DishCreateManyCategoryInputEnvelope
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
  }

  export type SubcategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput> | SubcategoryCreateWithoutCategoryInput[] | SubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCategoryInput | SubcategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: SubcategoryCreateManyCategoryInputEnvelope
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
  }

  export type DishUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<DishCreateWithoutCategoryInput, DishUncheckedCreateWithoutCategoryInput> | DishCreateWithoutCategoryInput[] | DishUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: DishCreateOrConnectWithoutCategoryInput | DishCreateOrConnectWithoutCategoryInput[]
    createMany?: DishCreateManyCategoryInputEnvelope
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
  }

  export type SubcategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput> | SubcategoryCreateWithoutCategoryInput[] | SubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCategoryInput | SubcategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: SubcategoryCreateManyCategoryInputEnvelope
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
  }

  export type RestaurantUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<RestaurantCreateWithoutCategoriesInput, RestaurantUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutCategoriesInput
    upsert?: RestaurantUpsertWithoutCategoriesInput
    connect?: RestaurantWhereUniqueInput
    update?: XOR<XOR<RestaurantUpdateToOneWithWhereWithoutCategoriesInput, RestaurantUpdateWithoutCategoriesInput>, RestaurantUncheckedUpdateWithoutCategoriesInput>
  }

  export type DishUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<DishCreateWithoutCategoryInput, DishUncheckedCreateWithoutCategoryInput> | DishCreateWithoutCategoryInput[] | DishUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: DishCreateOrConnectWithoutCategoryInput | DishCreateOrConnectWithoutCategoryInput[]
    upsert?: DishUpsertWithWhereUniqueWithoutCategoryInput | DishUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: DishCreateManyCategoryInputEnvelope
    set?: DishWhereUniqueInput | DishWhereUniqueInput[]
    disconnect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    delete?: DishWhereUniqueInput | DishWhereUniqueInput[]
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    update?: DishUpdateWithWhereUniqueWithoutCategoryInput | DishUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: DishUpdateManyWithWhereWithoutCategoryInput | DishUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: DishScalarWhereInput | DishScalarWhereInput[]
  }

  export type SubcategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput> | SubcategoryCreateWithoutCategoryInput[] | SubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCategoryInput | SubcategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: SubcategoryUpsertWithWhereUniqueWithoutCategoryInput | SubcategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SubcategoryCreateManyCategoryInputEnvelope
    set?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    disconnect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    delete?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    update?: SubcategoryUpdateWithWhereUniqueWithoutCategoryInput | SubcategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SubcategoryUpdateManyWithWhereWithoutCategoryInput | SubcategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SubcategoryScalarWhereInput | SubcategoryScalarWhereInput[]
  }

  export type DishUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<DishCreateWithoutCategoryInput, DishUncheckedCreateWithoutCategoryInput> | DishCreateWithoutCategoryInput[] | DishUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: DishCreateOrConnectWithoutCategoryInput | DishCreateOrConnectWithoutCategoryInput[]
    upsert?: DishUpsertWithWhereUniqueWithoutCategoryInput | DishUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: DishCreateManyCategoryInputEnvelope
    set?: DishWhereUniqueInput | DishWhereUniqueInput[]
    disconnect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    delete?: DishWhereUniqueInput | DishWhereUniqueInput[]
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    update?: DishUpdateWithWhereUniqueWithoutCategoryInput | DishUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: DishUpdateManyWithWhereWithoutCategoryInput | DishUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: DishScalarWhereInput | DishScalarWhereInput[]
  }

  export type SubcategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput> | SubcategoryCreateWithoutCategoryInput[] | SubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCategoryInput | SubcategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: SubcategoryUpsertWithWhereUniqueWithoutCategoryInput | SubcategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SubcategoryCreateManyCategoryInputEnvelope
    set?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    disconnect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    delete?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    update?: SubcategoryUpdateWithWhereUniqueWithoutCategoryInput | SubcategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SubcategoryUpdateManyWithWhereWithoutCategoryInput | SubcategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SubcategoryScalarWhereInput | SubcategoryScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutSubcategoriesInput = {
    create?: XOR<CategoryCreateWithoutSubcategoriesInput, CategoryUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubcategoriesInput
    connect?: CategoryWhereUniqueInput
  }

  export type DishCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<DishCreateWithoutSubcategoryInput, DishUncheckedCreateWithoutSubcategoryInput> | DishCreateWithoutSubcategoryInput[] | DishUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: DishCreateOrConnectWithoutSubcategoryInput | DishCreateOrConnectWithoutSubcategoryInput[]
    createMany?: DishCreateManySubcategoryInputEnvelope
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
  }

  export type SubSubcategoryCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<SubSubcategoryCreateWithoutSubcategoryInput, SubSubcategoryUncheckedCreateWithoutSubcategoryInput> | SubSubcategoryCreateWithoutSubcategoryInput[] | SubSubcategoryUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: SubSubcategoryCreateOrConnectWithoutSubcategoryInput | SubSubcategoryCreateOrConnectWithoutSubcategoryInput[]
    createMany?: SubSubcategoryCreateManySubcategoryInputEnvelope
    connect?: SubSubcategoryWhereUniqueInput | SubSubcategoryWhereUniqueInput[]
  }

  export type DishUncheckedCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<DishCreateWithoutSubcategoryInput, DishUncheckedCreateWithoutSubcategoryInput> | DishCreateWithoutSubcategoryInput[] | DishUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: DishCreateOrConnectWithoutSubcategoryInput | DishCreateOrConnectWithoutSubcategoryInput[]
    createMany?: DishCreateManySubcategoryInputEnvelope
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
  }

  export type SubSubcategoryUncheckedCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<SubSubcategoryCreateWithoutSubcategoryInput, SubSubcategoryUncheckedCreateWithoutSubcategoryInput> | SubSubcategoryCreateWithoutSubcategoryInput[] | SubSubcategoryUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: SubSubcategoryCreateOrConnectWithoutSubcategoryInput | SubSubcategoryCreateOrConnectWithoutSubcategoryInput[]
    createMany?: SubSubcategoryCreateManySubcategoryInputEnvelope
    connect?: SubSubcategoryWhereUniqueInput | SubSubcategoryWhereUniqueInput[]
  }

  export type CategoryUpdateOneRequiredWithoutSubcategoriesNestedInput = {
    create?: XOR<CategoryCreateWithoutSubcategoriesInput, CategoryUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubcategoriesInput
    upsert?: CategoryUpsertWithoutSubcategoriesInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutSubcategoriesInput, CategoryUpdateWithoutSubcategoriesInput>, CategoryUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type DishUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<DishCreateWithoutSubcategoryInput, DishUncheckedCreateWithoutSubcategoryInput> | DishCreateWithoutSubcategoryInput[] | DishUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: DishCreateOrConnectWithoutSubcategoryInput | DishCreateOrConnectWithoutSubcategoryInput[]
    upsert?: DishUpsertWithWhereUniqueWithoutSubcategoryInput | DishUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: DishCreateManySubcategoryInputEnvelope
    set?: DishWhereUniqueInput | DishWhereUniqueInput[]
    disconnect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    delete?: DishWhereUniqueInput | DishWhereUniqueInput[]
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    update?: DishUpdateWithWhereUniqueWithoutSubcategoryInput | DishUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: DishUpdateManyWithWhereWithoutSubcategoryInput | DishUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: DishScalarWhereInput | DishScalarWhereInput[]
  }

  export type SubSubcategoryUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<SubSubcategoryCreateWithoutSubcategoryInput, SubSubcategoryUncheckedCreateWithoutSubcategoryInput> | SubSubcategoryCreateWithoutSubcategoryInput[] | SubSubcategoryUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: SubSubcategoryCreateOrConnectWithoutSubcategoryInput | SubSubcategoryCreateOrConnectWithoutSubcategoryInput[]
    upsert?: SubSubcategoryUpsertWithWhereUniqueWithoutSubcategoryInput | SubSubcategoryUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: SubSubcategoryCreateManySubcategoryInputEnvelope
    set?: SubSubcategoryWhereUniqueInput | SubSubcategoryWhereUniqueInput[]
    disconnect?: SubSubcategoryWhereUniqueInput | SubSubcategoryWhereUniqueInput[]
    delete?: SubSubcategoryWhereUniqueInput | SubSubcategoryWhereUniqueInput[]
    connect?: SubSubcategoryWhereUniqueInput | SubSubcategoryWhereUniqueInput[]
    update?: SubSubcategoryUpdateWithWhereUniqueWithoutSubcategoryInput | SubSubcategoryUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: SubSubcategoryUpdateManyWithWhereWithoutSubcategoryInput | SubSubcategoryUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: SubSubcategoryScalarWhereInput | SubSubcategoryScalarWhereInput[]
  }

  export type DishUncheckedUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<DishCreateWithoutSubcategoryInput, DishUncheckedCreateWithoutSubcategoryInput> | DishCreateWithoutSubcategoryInput[] | DishUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: DishCreateOrConnectWithoutSubcategoryInput | DishCreateOrConnectWithoutSubcategoryInput[]
    upsert?: DishUpsertWithWhereUniqueWithoutSubcategoryInput | DishUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: DishCreateManySubcategoryInputEnvelope
    set?: DishWhereUniqueInput | DishWhereUniqueInput[]
    disconnect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    delete?: DishWhereUniqueInput | DishWhereUniqueInput[]
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    update?: DishUpdateWithWhereUniqueWithoutSubcategoryInput | DishUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: DishUpdateManyWithWhereWithoutSubcategoryInput | DishUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: DishScalarWhereInput | DishScalarWhereInput[]
  }

  export type SubSubcategoryUncheckedUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<SubSubcategoryCreateWithoutSubcategoryInput, SubSubcategoryUncheckedCreateWithoutSubcategoryInput> | SubSubcategoryCreateWithoutSubcategoryInput[] | SubSubcategoryUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: SubSubcategoryCreateOrConnectWithoutSubcategoryInput | SubSubcategoryCreateOrConnectWithoutSubcategoryInput[]
    upsert?: SubSubcategoryUpsertWithWhereUniqueWithoutSubcategoryInput | SubSubcategoryUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: SubSubcategoryCreateManySubcategoryInputEnvelope
    set?: SubSubcategoryWhereUniqueInput | SubSubcategoryWhereUniqueInput[]
    disconnect?: SubSubcategoryWhereUniqueInput | SubSubcategoryWhereUniqueInput[]
    delete?: SubSubcategoryWhereUniqueInput | SubSubcategoryWhereUniqueInput[]
    connect?: SubSubcategoryWhereUniqueInput | SubSubcategoryWhereUniqueInput[]
    update?: SubSubcategoryUpdateWithWhereUniqueWithoutSubcategoryInput | SubSubcategoryUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: SubSubcategoryUpdateManyWithWhereWithoutSubcategoryInput | SubSubcategoryUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: SubSubcategoryScalarWhereInput | SubSubcategoryScalarWhereInput[]
  }

  export type SubcategoryCreateNestedOneWithoutSubSubcategoriesInput = {
    create?: XOR<SubcategoryCreateWithoutSubSubcategoriesInput, SubcategoryUncheckedCreateWithoutSubSubcategoriesInput>
    connectOrCreate?: SubcategoryCreateOrConnectWithoutSubSubcategoriesInput
    connect?: SubcategoryWhereUniqueInput
  }

  export type DishCreateNestedManyWithoutSubSubcategoryInput = {
    create?: XOR<DishCreateWithoutSubSubcategoryInput, DishUncheckedCreateWithoutSubSubcategoryInput> | DishCreateWithoutSubSubcategoryInput[] | DishUncheckedCreateWithoutSubSubcategoryInput[]
    connectOrCreate?: DishCreateOrConnectWithoutSubSubcategoryInput | DishCreateOrConnectWithoutSubSubcategoryInput[]
    createMany?: DishCreateManySubSubcategoryInputEnvelope
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
  }

  export type DishUncheckedCreateNestedManyWithoutSubSubcategoryInput = {
    create?: XOR<DishCreateWithoutSubSubcategoryInput, DishUncheckedCreateWithoutSubSubcategoryInput> | DishCreateWithoutSubSubcategoryInput[] | DishUncheckedCreateWithoutSubSubcategoryInput[]
    connectOrCreate?: DishCreateOrConnectWithoutSubSubcategoryInput | DishCreateOrConnectWithoutSubSubcategoryInput[]
    createMany?: DishCreateManySubSubcategoryInputEnvelope
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
  }

  export type SubcategoryUpdateOneRequiredWithoutSubSubcategoriesNestedInput = {
    create?: XOR<SubcategoryCreateWithoutSubSubcategoriesInput, SubcategoryUncheckedCreateWithoutSubSubcategoriesInput>
    connectOrCreate?: SubcategoryCreateOrConnectWithoutSubSubcategoriesInput
    upsert?: SubcategoryUpsertWithoutSubSubcategoriesInput
    connect?: SubcategoryWhereUniqueInput
    update?: XOR<XOR<SubcategoryUpdateToOneWithWhereWithoutSubSubcategoriesInput, SubcategoryUpdateWithoutSubSubcategoriesInput>, SubcategoryUncheckedUpdateWithoutSubSubcategoriesInput>
  }

  export type DishUpdateManyWithoutSubSubcategoryNestedInput = {
    create?: XOR<DishCreateWithoutSubSubcategoryInput, DishUncheckedCreateWithoutSubSubcategoryInput> | DishCreateWithoutSubSubcategoryInput[] | DishUncheckedCreateWithoutSubSubcategoryInput[]
    connectOrCreate?: DishCreateOrConnectWithoutSubSubcategoryInput | DishCreateOrConnectWithoutSubSubcategoryInput[]
    upsert?: DishUpsertWithWhereUniqueWithoutSubSubcategoryInput | DishUpsertWithWhereUniqueWithoutSubSubcategoryInput[]
    createMany?: DishCreateManySubSubcategoryInputEnvelope
    set?: DishWhereUniqueInput | DishWhereUniqueInput[]
    disconnect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    delete?: DishWhereUniqueInput | DishWhereUniqueInput[]
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    update?: DishUpdateWithWhereUniqueWithoutSubSubcategoryInput | DishUpdateWithWhereUniqueWithoutSubSubcategoryInput[]
    updateMany?: DishUpdateManyWithWhereWithoutSubSubcategoryInput | DishUpdateManyWithWhereWithoutSubSubcategoryInput[]
    deleteMany?: DishScalarWhereInput | DishScalarWhereInput[]
  }

  export type DishUncheckedUpdateManyWithoutSubSubcategoryNestedInput = {
    create?: XOR<DishCreateWithoutSubSubcategoryInput, DishUncheckedCreateWithoutSubSubcategoryInput> | DishCreateWithoutSubSubcategoryInput[] | DishUncheckedCreateWithoutSubSubcategoryInput[]
    connectOrCreate?: DishCreateOrConnectWithoutSubSubcategoryInput | DishCreateOrConnectWithoutSubSubcategoryInput[]
    upsert?: DishUpsertWithWhereUniqueWithoutSubSubcategoryInput | DishUpsertWithWhereUniqueWithoutSubSubcategoryInput[]
    createMany?: DishCreateManySubSubcategoryInputEnvelope
    set?: DishWhereUniqueInput | DishWhereUniqueInput[]
    disconnect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    delete?: DishWhereUniqueInput | DishWhereUniqueInput[]
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    update?: DishUpdateWithWhereUniqueWithoutSubSubcategoryInput | DishUpdateWithWhereUniqueWithoutSubSubcategoryInput[]
    updateMany?: DishUpdateManyWithWhereWithoutSubSubcategoryInput | DishUpdateManyWithWhereWithoutSubSubcategoryInput[]
    deleteMany?: DishScalarWhereInput | DishScalarWhereInput[]
  }

  export type DishCreatedietaryInfoInput = {
    set: string[]
  }

  export type DishCreateallergensInput = {
    set: string[]
  }

  export type DishCreateingredientsInput = {
    set: string[]
  }

  export type RestaurantCreateNestedOneWithoutDishesInput = {
    create?: XOR<RestaurantCreateWithoutDishesInput, RestaurantUncheckedCreateWithoutDishesInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutDishesInput
    connect?: RestaurantWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutDishesInput = {
    create?: XOR<CategoryCreateWithoutDishesInput, CategoryUncheckedCreateWithoutDishesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutDishesInput
    connect?: CategoryWhereUniqueInput
  }

  export type SubcategoryCreateNestedOneWithoutDishesInput = {
    create?: XOR<SubcategoryCreateWithoutDishesInput, SubcategoryUncheckedCreateWithoutDishesInput>
    connectOrCreate?: SubcategoryCreateOrConnectWithoutDishesInput
    connect?: SubcategoryWhereUniqueInput
  }

  export type SubSubcategoryCreateNestedOneWithoutDishesInput = {
    create?: XOR<SubSubcategoryCreateWithoutDishesInput, SubSubcategoryUncheckedCreateWithoutDishesInput>
    connectOrCreate?: SubSubcategoryCreateOrConnectWithoutDishesInput
    connect?: SubSubcategoryWhereUniqueInput
  }

  export type MenuCreateNestedOneWithoutDishesInput = {
    create?: XOR<MenuCreateWithoutDishesInput, MenuUncheckedCreateWithoutDishesInput>
    connectOrCreate?: MenuCreateOrConnectWithoutDishesInput
    connect?: MenuWhereUniqueInput
  }

  export type DishUpdatedietaryInfoInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DishUpdateallergensInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DishUpdateingredientsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RestaurantUpdateOneRequiredWithoutDishesNestedInput = {
    create?: XOR<RestaurantCreateWithoutDishesInput, RestaurantUncheckedCreateWithoutDishesInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutDishesInput
    upsert?: RestaurantUpsertWithoutDishesInput
    connect?: RestaurantWhereUniqueInput
    update?: XOR<XOR<RestaurantUpdateToOneWithWhereWithoutDishesInput, RestaurantUpdateWithoutDishesInput>, RestaurantUncheckedUpdateWithoutDishesInput>
  }

  export type CategoryUpdateOneRequiredWithoutDishesNestedInput = {
    create?: XOR<CategoryCreateWithoutDishesInput, CategoryUncheckedCreateWithoutDishesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutDishesInput
    upsert?: CategoryUpsertWithoutDishesInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutDishesInput, CategoryUpdateWithoutDishesInput>, CategoryUncheckedUpdateWithoutDishesInput>
  }

  export type SubcategoryUpdateOneWithoutDishesNestedInput = {
    create?: XOR<SubcategoryCreateWithoutDishesInput, SubcategoryUncheckedCreateWithoutDishesInput>
    connectOrCreate?: SubcategoryCreateOrConnectWithoutDishesInput
    upsert?: SubcategoryUpsertWithoutDishesInput
    disconnect?: SubcategoryWhereInput | boolean
    delete?: SubcategoryWhereInput | boolean
    connect?: SubcategoryWhereUniqueInput
    update?: XOR<XOR<SubcategoryUpdateToOneWithWhereWithoutDishesInput, SubcategoryUpdateWithoutDishesInput>, SubcategoryUncheckedUpdateWithoutDishesInput>
  }

  export type SubSubcategoryUpdateOneWithoutDishesNestedInput = {
    create?: XOR<SubSubcategoryCreateWithoutDishesInput, SubSubcategoryUncheckedCreateWithoutDishesInput>
    connectOrCreate?: SubSubcategoryCreateOrConnectWithoutDishesInput
    upsert?: SubSubcategoryUpsertWithoutDishesInput
    disconnect?: SubSubcategoryWhereInput | boolean
    delete?: SubSubcategoryWhereInput | boolean
    connect?: SubSubcategoryWhereUniqueInput
    update?: XOR<XOR<SubSubcategoryUpdateToOneWithWhereWithoutDishesInput, SubSubcategoryUpdateWithoutDishesInput>, SubSubcategoryUncheckedUpdateWithoutDishesInput>
  }

  export type MenuUpdateOneWithoutDishesNestedInput = {
    create?: XOR<MenuCreateWithoutDishesInput, MenuUncheckedCreateWithoutDishesInput>
    connectOrCreate?: MenuCreateOrConnectWithoutDishesInput
    upsert?: MenuUpsertWithoutDishesInput
    disconnect?: MenuWhereInput | boolean
    delete?: MenuWhereInput | boolean
    connect?: MenuWhereUniqueInput
    update?: XOR<XOR<MenuUpdateToOneWithWhereWithoutDishesInput, MenuUpdateWithoutDishesInput>, MenuUncheckedUpdateWithoutDishesInput>
  }

  export type RestaurantCreateNestedOneWithoutOpeningHoursInput = {
    create?: XOR<RestaurantCreateWithoutOpeningHoursInput, RestaurantUncheckedCreateWithoutOpeningHoursInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutOpeningHoursInput
    connect?: RestaurantWhereUniqueInput
  }

  export type RestaurantUpdateOneRequiredWithoutOpeningHoursNestedInput = {
    create?: XOR<RestaurantCreateWithoutOpeningHoursInput, RestaurantUncheckedCreateWithoutOpeningHoursInput>
    connectOrCreate?: RestaurantCreateOrConnectWithoutOpeningHoursInput
    upsert?: RestaurantUpsertWithoutOpeningHoursInput
    connect?: RestaurantWhereUniqueInput
    update?: XOR<XOR<RestaurantUpdateToOneWithWhereWithoutOpeningHoursInput, RestaurantUpdateWithoutOpeningHoursInput>, RestaurantUncheckedUpdateWithoutOpeningHoursInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumAMENITIESTYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.AMENITIESTYPE | EnumAMENITIESTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.AMENITIESTYPE[] | ListEnumAMENITIESTYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.AMENITIESTYPE[] | ListEnumAMENITIESTYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumAMENITIESTYPEFilter<$PrismaModel> | $Enums.AMENITIESTYPE
  }

  export type NestedEnumAMENITIESTYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AMENITIESTYPE | EnumAMENITIESTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.AMENITIESTYPE[] | ListEnumAMENITIESTYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.AMENITIESTYPE[] | ListEnumAMENITIESTYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumAMENITIESTYPEWithAggregatesFilter<$PrismaModel> | $Enums.AMENITIESTYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAMENITIESTYPEFilter<$PrismaModel>
    _max?: NestedEnumAMENITIESTYPEFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumRECURRINGPATTERNFilter<$PrismaModel = never> = {
    equals?: $Enums.RECURRINGPATTERN | EnumRECURRINGPATTERNFieldRefInput<$PrismaModel>
    in?: $Enums.RECURRINGPATTERN[] | ListEnumRECURRINGPATTERNFieldRefInput<$PrismaModel>
    notIn?: $Enums.RECURRINGPATTERN[] | ListEnumRECURRINGPATTERNFieldRefInput<$PrismaModel>
    not?: NestedEnumRECURRINGPATTERNFilter<$PrismaModel> | $Enums.RECURRINGPATTERN
  }

  export type NestedEnumRECURRINGPATTERNWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RECURRINGPATTERN | EnumRECURRINGPATTERNFieldRefInput<$PrismaModel>
    in?: $Enums.RECURRINGPATTERN[] | ListEnumRECURRINGPATTERNFieldRefInput<$PrismaModel>
    notIn?: $Enums.RECURRINGPATTERN[] | ListEnumRECURRINGPATTERNFieldRefInput<$PrismaModel>
    not?: NestedEnumRECURRINGPATTERNWithAggregatesFilter<$PrismaModel> | $Enums.RECURRINGPATTERN
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRECURRINGPATTERNFilter<$PrismaModel>
    _max?: NestedEnumRECURRINGPATTERNFilter<$PrismaModel>
  }

  export type NestedEnumTVChannelLanguagesFilter<$PrismaModel = never> = {
    equals?: $Enums.TVChannelLanguages | EnumTVChannelLanguagesFieldRefInput<$PrismaModel>
    in?: $Enums.TVChannelLanguages[] | ListEnumTVChannelLanguagesFieldRefInput<$PrismaModel>
    notIn?: $Enums.TVChannelLanguages[] | ListEnumTVChannelLanguagesFieldRefInput<$PrismaModel>
    not?: NestedEnumTVChannelLanguagesFilter<$PrismaModel> | $Enums.TVChannelLanguages
  }

  export type NestedEnumTVCHANNELTYPEFilter<$PrismaModel = never> = {
    equals?: $Enums.TVCHANNELTYPE | EnumTVCHANNELTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.TVCHANNELTYPE[] | ListEnumTVCHANNELTYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.TVCHANNELTYPE[] | ListEnumTVCHANNELTYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumTVCHANNELTYPEFilter<$PrismaModel> | $Enums.TVCHANNELTYPE
  }

  export type NestedEnumTVChannelLanguagesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TVChannelLanguages | EnumTVChannelLanguagesFieldRefInput<$PrismaModel>
    in?: $Enums.TVChannelLanguages[] | ListEnumTVChannelLanguagesFieldRefInput<$PrismaModel>
    notIn?: $Enums.TVChannelLanguages[] | ListEnumTVChannelLanguagesFieldRefInput<$PrismaModel>
    not?: NestedEnumTVChannelLanguagesWithAggregatesFilter<$PrismaModel> | $Enums.TVChannelLanguages
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTVChannelLanguagesFilter<$PrismaModel>
    _max?: NestedEnumTVChannelLanguagesFilter<$PrismaModel>
  }

  export type NestedEnumTVCHANNELTYPEWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TVCHANNELTYPE | EnumTVCHANNELTYPEFieldRefInput<$PrismaModel>
    in?: $Enums.TVCHANNELTYPE[] | ListEnumTVCHANNELTYPEFieldRefInput<$PrismaModel>
    notIn?: $Enums.TVCHANNELTYPE[] | ListEnumTVCHANNELTYPEFieldRefInput<$PrismaModel>
    not?: NestedEnumTVCHANNELTYPEWithAggregatesFilter<$PrismaModel> | $Enums.TVCHANNELTYPE
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTVCHANNELTYPEFilter<$PrismaModel>
    _max?: NestedEnumTVCHANNELTYPEFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumReservationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReservationStatus | EnumReservationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReservationStatus[] | ListEnumReservationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReservationStatus[] | ListEnumReservationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReservationStatusFilter<$PrismaModel> | $Enums.ReservationStatus
  }

  export type NestedEnumReservationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReservationStatus | EnumReservationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReservationStatus[] | ListEnumReservationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReservationStatus[] | ListEnumReservationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReservationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReservationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReservationStatusFilter<$PrismaModel>
    _max?: NestedEnumReservationStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ActivityCreateWithoutHotelInput = {
    id?: string
    name?: string
    name_esp?: string
    description?: string
    description_esp?: string
    image?: string
    profileImage?: string | null
    type?: string
    start: Date | string
    end: Date | string
    price: number
    cashOnly?: boolean
    freeOfCharge?: boolean
    location?: string
    isRecurring?: boolean
    recurrencePattern?: $Enums.RECURRINGPATTERN
    recurrenceDays?: ActivityCreaterecurrenceDaysInput | string[]
    recurrenceEndDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUncheckedCreateWithoutHotelInput = {
    id?: string
    name?: string
    name_esp?: string
    description?: string
    description_esp?: string
    image?: string
    profileImage?: string | null
    type?: string
    start: Date | string
    end: Date | string
    price: number
    cashOnly?: boolean
    freeOfCharge?: boolean
    location?: string
    isRecurring?: boolean
    recurrencePattern?: $Enums.RECURRINGPATTERN
    recurrenceDays?: ActivityCreaterecurrenceDaysInput | string[]
    recurrenceEndDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutHotelInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutHotelInput, ActivityUncheckedCreateWithoutHotelInput>
  }

  export type ActivityCreateManyHotelInputEnvelope = {
    data: ActivityCreateManyHotelInput | ActivityCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type TourCreateWithoutHotelInput = {
    id?: string
    name?: string
    name_esp?: string
    description?: string
    description_esp?: string
    image?: string
    price: number
    priceKids?: number
    category?: string
    offer?: boolean
    discount?: number
    whattobring?: string
    included?: TourCreateincludedInput | string[]
    pickuptime: Date | string
    maxPeople?: number
    minPeople?: number
    minAge?: number
    bestSeller?: boolean
    priceInfo?: string
    location?: string
    offered?: TourCreateofferedInput | string[]
    duration?: number
    videos?: TourCreatevideosInput | string[]
    images?: TourCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    pricecategory?: TourPriceCategoryCreateNestedManyWithoutTourInput
  }

  export type TourUncheckedCreateWithoutHotelInput = {
    id?: string
    name?: string
    name_esp?: string
    description?: string
    description_esp?: string
    image?: string
    price: number
    priceKids?: number
    category?: string
    offer?: boolean
    discount?: number
    whattobring?: string
    included?: TourCreateincludedInput | string[]
    pickuptime: Date | string
    maxPeople?: number
    minPeople?: number
    minAge?: number
    bestSeller?: boolean
    priceInfo?: string
    location?: string
    offered?: TourCreateofferedInput | string[]
    duration?: number
    videos?: TourCreatevideosInput | string[]
    images?: TourCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    pricecategory?: TourPriceCategoryUncheckedCreateNestedManyWithoutTourInput
  }

  export type TourCreateOrConnectWithoutHotelInput = {
    where: TourWhereUniqueInput
    create: XOR<TourCreateWithoutHotelInput, TourUncheckedCreateWithoutHotelInput>
  }

  export type TourCreateManyHotelInputEnvelope = {
    data: TourCreateManyHotelInput | TourCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type SpaCreateWithoutHotelInput = {
    id?: string
    name?: string
    name_esp?: string
    description?: string
    description_esp?: string
    type?: string
    videos?: SpaCreatevideosInput | string[]
    images?: SpaCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    pricecategory?: SpaPriceCategoryCreateNestedManyWithoutSpaInput
  }

  export type SpaUncheckedCreateWithoutHotelInput = {
    id?: string
    name?: string
    name_esp?: string
    description?: string
    description_esp?: string
    type?: string
    videos?: SpaCreatevideosInput | string[]
    images?: SpaCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    pricecategory?: SpaPriceCategoryUncheckedCreateNestedManyWithoutSpaInput
  }

  export type SpaCreateOrConnectWithoutHotelInput = {
    where: SpaWhereUniqueInput
    create: XOR<SpaCreateWithoutHotelInput, SpaUncheckedCreateWithoutHotelInput>
  }

  export type SpaCreateManyHotelInputEnvelope = {
    data: SpaCreateManyHotelInput | SpaCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type AmenitiesCreateWithoutHotelInput = {
    id?: string
    name: string
    description?: string
    icon?: string
    image?: string
    amenitiestype: $Enums.AMENITIESTYPE
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenitiesUncheckedCreateWithoutHotelInput = {
    id?: string
    name: string
    description?: string
    icon?: string
    image?: string
    amenitiestype: $Enums.AMENITIESTYPE
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenitiesCreateOrConnectWithoutHotelInput = {
    where: AmenitiesWhereUniqueInput
    create: XOR<AmenitiesCreateWithoutHotelInput, AmenitiesUncheckedCreateWithoutHotelInput>
  }

  export type AmenitiesCreateManyHotelInputEnvelope = {
    data: AmenitiesCreateManyHotelInput | AmenitiesCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type TVChannelsCreateWithoutHotelInput = {
    id?: string
    name: string
    name_esp?: string | null
    description: string
    description_esp?: string | null
    logo?: string | null
    channelNo: string
    languages?: $Enums.TVChannelLanguages
    channeltype?: $Enums.TVCHANNELTYPE
    category?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TVChannelsUncheckedCreateWithoutHotelInput = {
    id?: string
    name: string
    name_esp?: string | null
    description: string
    description_esp?: string | null
    logo?: string | null
    channelNo: string
    languages?: $Enums.TVChannelLanguages
    channeltype?: $Enums.TVCHANNELTYPE
    category?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TVChannelsCreateOrConnectWithoutHotelInput = {
    where: TVChannelsWhereUniqueInput
    create: XOR<TVChannelsCreateWithoutHotelInput, TVChannelsUncheckedCreateWithoutHotelInput>
  }

  export type TVChannelsCreateManyHotelInputEnvelope = {
    data: TVChannelsCreateManyHotelInput | TVChannelsCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type ActivityUpsertWithWhereUniqueWithoutHotelInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutHotelInput, ActivityUncheckedUpdateWithoutHotelInput>
    create: XOR<ActivityCreateWithoutHotelInput, ActivityUncheckedCreateWithoutHotelInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutHotelInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutHotelInput, ActivityUncheckedUpdateWithoutHotelInput>
  }

  export type ActivityUpdateManyWithWhereWithoutHotelInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutHotelInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: StringFilter<"Activity"> | string
    name?: StringFilter<"Activity"> | string
    name_esp?: StringFilter<"Activity"> | string
    description?: StringFilter<"Activity"> | string
    description_esp?: StringFilter<"Activity"> | string
    image?: StringFilter<"Activity"> | string
    profileImage?: StringNullableFilter<"Activity"> | string | null
    hotelId?: StringFilter<"Activity"> | string
    type?: StringFilter<"Activity"> | string
    start?: DateTimeFilter<"Activity"> | Date | string
    end?: DateTimeFilter<"Activity"> | Date | string
    price?: IntFilter<"Activity"> | number
    cashOnly?: BoolFilter<"Activity"> | boolean
    freeOfCharge?: BoolFilter<"Activity"> | boolean
    location?: StringFilter<"Activity"> | string
    isRecurring?: BoolFilter<"Activity"> | boolean
    recurrencePattern?: EnumRECURRINGPATTERNFilter<"Activity"> | $Enums.RECURRINGPATTERN
    recurrenceDays?: StringNullableListFilter<"Activity">
    recurrenceEndDate?: DateTimeFilter<"Activity"> | Date | string
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
  }

  export type TourUpsertWithWhereUniqueWithoutHotelInput = {
    where: TourWhereUniqueInput
    update: XOR<TourUpdateWithoutHotelInput, TourUncheckedUpdateWithoutHotelInput>
    create: XOR<TourCreateWithoutHotelInput, TourUncheckedCreateWithoutHotelInput>
  }

  export type TourUpdateWithWhereUniqueWithoutHotelInput = {
    where: TourWhereUniqueInput
    data: XOR<TourUpdateWithoutHotelInput, TourUncheckedUpdateWithoutHotelInput>
  }

  export type TourUpdateManyWithWhereWithoutHotelInput = {
    where: TourScalarWhereInput
    data: XOR<TourUpdateManyMutationInput, TourUncheckedUpdateManyWithoutHotelInput>
  }

  export type TourScalarWhereInput = {
    AND?: TourScalarWhereInput | TourScalarWhereInput[]
    OR?: TourScalarWhereInput[]
    NOT?: TourScalarWhereInput | TourScalarWhereInput[]
    id?: StringFilter<"Tour"> | string
    name?: StringFilter<"Tour"> | string
    name_esp?: StringFilter<"Tour"> | string
    description?: StringFilter<"Tour"> | string
    description_esp?: StringFilter<"Tour"> | string
    image?: StringFilter<"Tour"> | string
    hotelId?: StringFilter<"Tour"> | string
    price?: IntFilter<"Tour"> | number
    priceKids?: IntFilter<"Tour"> | number
    category?: StringFilter<"Tour"> | string
    offer?: BoolFilter<"Tour"> | boolean
    discount?: IntFilter<"Tour"> | number
    whattobring?: StringFilter<"Tour"> | string
    included?: StringNullableListFilter<"Tour">
    pickuptime?: DateTimeFilter<"Tour"> | Date | string
    maxPeople?: IntFilter<"Tour"> | number
    minPeople?: IntFilter<"Tour"> | number
    minAge?: IntFilter<"Tour"> | number
    bestSeller?: BoolFilter<"Tour"> | boolean
    priceInfo?: StringFilter<"Tour"> | string
    location?: StringFilter<"Tour"> | string
    offered?: StringNullableListFilter<"Tour">
    duration?: IntFilter<"Tour"> | number
    videos?: StringNullableListFilter<"Tour">
    images?: StringNullableListFilter<"Tour">
    createdAt?: DateTimeFilter<"Tour"> | Date | string
    updatedAt?: DateTimeFilter<"Tour"> | Date | string
  }

  export type SpaUpsertWithWhereUniqueWithoutHotelInput = {
    where: SpaWhereUniqueInput
    update: XOR<SpaUpdateWithoutHotelInput, SpaUncheckedUpdateWithoutHotelInput>
    create: XOR<SpaCreateWithoutHotelInput, SpaUncheckedCreateWithoutHotelInput>
  }

  export type SpaUpdateWithWhereUniqueWithoutHotelInput = {
    where: SpaWhereUniqueInput
    data: XOR<SpaUpdateWithoutHotelInput, SpaUncheckedUpdateWithoutHotelInput>
  }

  export type SpaUpdateManyWithWhereWithoutHotelInput = {
    where: SpaScalarWhereInput
    data: XOR<SpaUpdateManyMutationInput, SpaUncheckedUpdateManyWithoutHotelInput>
  }

  export type SpaScalarWhereInput = {
    AND?: SpaScalarWhereInput | SpaScalarWhereInput[]
    OR?: SpaScalarWhereInput[]
    NOT?: SpaScalarWhereInput | SpaScalarWhereInput[]
    id?: StringFilter<"Spa"> | string
    name?: StringFilter<"Spa"> | string
    name_esp?: StringFilter<"Spa"> | string
    description?: StringFilter<"Spa"> | string
    description_esp?: StringFilter<"Spa"> | string
    hotelId?: StringFilter<"Spa"> | string
    type?: StringFilter<"Spa"> | string
    videos?: StringNullableListFilter<"Spa">
    images?: StringNullableListFilter<"Spa">
    createdAt?: DateTimeFilter<"Spa"> | Date | string
    updatedAt?: DateTimeFilter<"Spa"> | Date | string
  }

  export type AmenitiesUpsertWithWhereUniqueWithoutHotelInput = {
    where: AmenitiesWhereUniqueInput
    update: XOR<AmenitiesUpdateWithoutHotelInput, AmenitiesUncheckedUpdateWithoutHotelInput>
    create: XOR<AmenitiesCreateWithoutHotelInput, AmenitiesUncheckedCreateWithoutHotelInput>
  }

  export type AmenitiesUpdateWithWhereUniqueWithoutHotelInput = {
    where: AmenitiesWhereUniqueInput
    data: XOR<AmenitiesUpdateWithoutHotelInput, AmenitiesUncheckedUpdateWithoutHotelInput>
  }

  export type AmenitiesUpdateManyWithWhereWithoutHotelInput = {
    where: AmenitiesScalarWhereInput
    data: XOR<AmenitiesUpdateManyMutationInput, AmenitiesUncheckedUpdateManyWithoutHotelInput>
  }

  export type AmenitiesScalarWhereInput = {
    AND?: AmenitiesScalarWhereInput | AmenitiesScalarWhereInput[]
    OR?: AmenitiesScalarWhereInput[]
    NOT?: AmenitiesScalarWhereInput | AmenitiesScalarWhereInput[]
    id?: StringFilter<"Amenities"> | string
    name?: StringFilter<"Amenities"> | string
    description?: StringFilter<"Amenities"> | string
    icon?: StringFilter<"Amenities"> | string
    image?: StringFilter<"Amenities"> | string
    amenitiestype?: EnumAMENITIESTYPEFilter<"Amenities"> | $Enums.AMENITIESTYPE
    hotelId?: StringFilter<"Amenities"> | string
    createdAt?: DateTimeFilter<"Amenities"> | Date | string
    updatedAt?: DateTimeFilter<"Amenities"> | Date | string
  }

  export type TVChannelsUpsertWithWhereUniqueWithoutHotelInput = {
    where: TVChannelsWhereUniqueInput
    update: XOR<TVChannelsUpdateWithoutHotelInput, TVChannelsUncheckedUpdateWithoutHotelInput>
    create: XOR<TVChannelsCreateWithoutHotelInput, TVChannelsUncheckedCreateWithoutHotelInput>
  }

  export type TVChannelsUpdateWithWhereUniqueWithoutHotelInput = {
    where: TVChannelsWhereUniqueInput
    data: XOR<TVChannelsUpdateWithoutHotelInput, TVChannelsUncheckedUpdateWithoutHotelInput>
  }

  export type TVChannelsUpdateManyWithWhereWithoutHotelInput = {
    where: TVChannelsScalarWhereInput
    data: XOR<TVChannelsUpdateManyMutationInput, TVChannelsUncheckedUpdateManyWithoutHotelInput>
  }

  export type TVChannelsScalarWhereInput = {
    AND?: TVChannelsScalarWhereInput | TVChannelsScalarWhereInput[]
    OR?: TVChannelsScalarWhereInput[]
    NOT?: TVChannelsScalarWhereInput | TVChannelsScalarWhereInput[]
    id?: StringFilter<"TVChannels"> | string
    name?: StringFilter<"TVChannels"> | string
    name_esp?: StringNullableFilter<"TVChannels"> | string | null
    description?: StringFilter<"TVChannels"> | string
    description_esp?: StringNullableFilter<"TVChannels"> | string | null
    logo?: StringNullableFilter<"TVChannels"> | string | null
    channelNo?: StringFilter<"TVChannels"> | string
    languages?: EnumTVChannelLanguagesFilter<"TVChannels"> | $Enums.TVChannelLanguages
    channeltype?: EnumTVCHANNELTYPEFilter<"TVChannels"> | $Enums.TVCHANNELTYPE
    category?: StringFilter<"TVChannels"> | string
    hotelId?: StringFilter<"TVChannels"> | string
    createdAt?: DateTimeFilter<"TVChannels"> | Date | string
    updatedAt?: DateTimeFilter<"TVChannels"> | Date | string
  }

  export type HotelCreateWithoutAmenitiesInput = {
    id?: string
    name: string
    description: string
    description_esp: string
    image: string
    country: string
    state: string
    city: string
    locationDescription: string
    locationDescription_esp: string
    images?: HotelCreateimagesInput | string[]
    videos?: HotelCreatevideosInput | string[]
    lat: number
    lng: number
    phone: string
    phone_reservation?: string | null
    phone_tollfree?: string | null
    email: string
    website?: string
    facebook?: string | null
    tripadvisor?: string | null
    instagram?: string | null
    youtube?: string | null
    whatsapp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutHotelInput
    tours?: TourCreateNestedManyWithoutHotelInput
    spa?: SpaCreateNestedManyWithoutHotelInput
    tvchannels?: TVChannelsCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutAmenitiesInput = {
    id?: string
    name: string
    description: string
    description_esp: string
    image: string
    country: string
    state: string
    city: string
    locationDescription: string
    locationDescription_esp: string
    images?: HotelCreateimagesInput | string[]
    videos?: HotelCreatevideosInput | string[]
    lat: number
    lng: number
    phone: string
    phone_reservation?: string | null
    phone_tollfree?: string | null
    email: string
    website?: string
    facebook?: string | null
    tripadvisor?: string | null
    instagram?: string | null
    youtube?: string | null
    whatsapp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutHotelInput
    tours?: TourUncheckedCreateNestedManyWithoutHotelInput
    spa?: SpaUncheckedCreateNestedManyWithoutHotelInput
    tvchannels?: TVChannelsUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutAmenitiesInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutAmenitiesInput, HotelUncheckedCreateWithoutAmenitiesInput>
  }

  export type HotelUpsertWithoutAmenitiesInput = {
    update: XOR<HotelUpdateWithoutAmenitiesInput, HotelUncheckedUpdateWithoutAmenitiesInput>
    create: XOR<HotelCreateWithoutAmenitiesInput, HotelUncheckedCreateWithoutAmenitiesInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutAmenitiesInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutAmenitiesInput, HotelUncheckedUpdateWithoutAmenitiesInput>
  }

  export type HotelUpdateWithoutAmenitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    locationDescription?: StringFieldUpdateOperationsInput | string
    locationDescription_esp?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    videos?: HotelUpdatevideosInput | string[]
    lat?: IntFieldUpdateOperationsInput | number
    lng?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    phone_reservation?: NullableStringFieldUpdateOperationsInput | string | null
    phone_tollfree?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tripadvisor?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutHotelNestedInput
    tours?: TourUpdateManyWithoutHotelNestedInput
    spa?: SpaUpdateManyWithoutHotelNestedInput
    tvchannels?: TVChannelsUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutAmenitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    locationDescription?: StringFieldUpdateOperationsInput | string
    locationDescription_esp?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    videos?: HotelUpdatevideosInput | string[]
    lat?: IntFieldUpdateOperationsInput | number
    lng?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    phone_reservation?: NullableStringFieldUpdateOperationsInput | string | null
    phone_tollfree?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tripadvisor?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutHotelNestedInput
    tours?: TourUncheckedUpdateManyWithoutHotelNestedInput
    spa?: SpaUncheckedUpdateManyWithoutHotelNestedInput
    tvchannels?: TVChannelsUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type TourCreateWithoutPricecategoryInput = {
    id?: string
    name?: string
    name_esp?: string
    description?: string
    description_esp?: string
    image?: string
    price: number
    priceKids?: number
    category?: string
    offer?: boolean
    discount?: number
    whattobring?: string
    included?: TourCreateincludedInput | string[]
    pickuptime: Date | string
    maxPeople?: number
    minPeople?: number
    minAge?: number
    bestSeller?: boolean
    priceInfo?: string
    location?: string
    offered?: TourCreateofferedInput | string[]
    duration?: number
    videos?: TourCreatevideosInput | string[]
    images?: TourCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    Hotel?: HotelCreateNestedOneWithoutToursInput
  }

  export type TourUncheckedCreateWithoutPricecategoryInput = {
    id?: string
    name?: string
    name_esp?: string
    description?: string
    description_esp?: string
    image?: string
    hotelId?: string
    price: number
    priceKids?: number
    category?: string
    offer?: boolean
    discount?: number
    whattobring?: string
    included?: TourCreateincludedInput | string[]
    pickuptime: Date | string
    maxPeople?: number
    minPeople?: number
    minAge?: number
    bestSeller?: boolean
    priceInfo?: string
    location?: string
    offered?: TourCreateofferedInput | string[]
    duration?: number
    videos?: TourCreatevideosInput | string[]
    images?: TourCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourCreateOrConnectWithoutPricecategoryInput = {
    where: TourWhereUniqueInput
    create: XOR<TourCreateWithoutPricecategoryInput, TourUncheckedCreateWithoutPricecategoryInput>
  }

  export type TourUpsertWithoutPricecategoryInput = {
    update: XOR<TourUpdateWithoutPricecategoryInput, TourUncheckedUpdateWithoutPricecategoryInput>
    create: XOR<TourCreateWithoutPricecategoryInput, TourUncheckedCreateWithoutPricecategoryInput>
    where?: TourWhereInput
  }

  export type TourUpdateToOneWithWhereWithoutPricecategoryInput = {
    where?: TourWhereInput
    data: XOR<TourUpdateWithoutPricecategoryInput, TourUncheckedUpdateWithoutPricecategoryInput>
  }

  export type TourUpdateWithoutPricecategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    priceKids?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    offer?: BoolFieldUpdateOperationsInput | boolean
    discount?: IntFieldUpdateOperationsInput | number
    whattobring?: StringFieldUpdateOperationsInput | string
    included?: TourUpdateincludedInput | string[]
    pickuptime?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPeople?: IntFieldUpdateOperationsInput | number
    minPeople?: IntFieldUpdateOperationsInput | number
    minAge?: IntFieldUpdateOperationsInput | number
    bestSeller?: BoolFieldUpdateOperationsInput | boolean
    priceInfo?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    offered?: TourUpdateofferedInput | string[]
    duration?: IntFieldUpdateOperationsInput | number
    videos?: TourUpdatevideosInput | string[]
    images?: TourUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hotel?: HotelUpdateOneRequiredWithoutToursNestedInput
  }

  export type TourUncheckedUpdateWithoutPricecategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    priceKids?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    offer?: BoolFieldUpdateOperationsInput | boolean
    discount?: IntFieldUpdateOperationsInput | number
    whattobring?: StringFieldUpdateOperationsInput | string
    included?: TourUpdateincludedInput | string[]
    pickuptime?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPeople?: IntFieldUpdateOperationsInput | number
    minPeople?: IntFieldUpdateOperationsInput | number
    minAge?: IntFieldUpdateOperationsInput | number
    bestSeller?: BoolFieldUpdateOperationsInput | boolean
    priceInfo?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    offered?: TourUpdateofferedInput | string[]
    duration?: IntFieldUpdateOperationsInput | number
    videos?: TourUpdatevideosInput | string[]
    images?: TourUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourPriceCategoryCreateWithoutTourInput = {
    id?: string
    sku: number
    price: number
    description?: string
    description_esp?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourPriceCategoryUncheckedCreateWithoutTourInput = {
    id?: string
    sku: number
    price: number
    description?: string
    description_esp?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourPriceCategoryCreateOrConnectWithoutTourInput = {
    where: TourPriceCategoryWhereUniqueInput
    create: XOR<TourPriceCategoryCreateWithoutTourInput, TourPriceCategoryUncheckedCreateWithoutTourInput>
  }

  export type TourPriceCategoryCreateManyTourInputEnvelope = {
    data: TourPriceCategoryCreateManyTourInput | TourPriceCategoryCreateManyTourInput[]
    skipDuplicates?: boolean
  }

  export type HotelCreateWithoutToursInput = {
    id?: string
    name: string
    description: string
    description_esp: string
    image: string
    country: string
    state: string
    city: string
    locationDescription: string
    locationDescription_esp: string
    images?: HotelCreateimagesInput | string[]
    videos?: HotelCreatevideosInput | string[]
    lat: number
    lng: number
    phone: string
    phone_reservation?: string | null
    phone_tollfree?: string | null
    email: string
    website?: string
    facebook?: string | null
    tripadvisor?: string | null
    instagram?: string | null
    youtube?: string | null
    whatsapp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutHotelInput
    spa?: SpaCreateNestedManyWithoutHotelInput
    amenities?: AmenitiesCreateNestedManyWithoutHotelInput
    tvchannels?: TVChannelsCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutToursInput = {
    id?: string
    name: string
    description: string
    description_esp: string
    image: string
    country: string
    state: string
    city: string
    locationDescription: string
    locationDescription_esp: string
    images?: HotelCreateimagesInput | string[]
    videos?: HotelCreatevideosInput | string[]
    lat: number
    lng: number
    phone: string
    phone_reservation?: string | null
    phone_tollfree?: string | null
    email: string
    website?: string
    facebook?: string | null
    tripadvisor?: string | null
    instagram?: string | null
    youtube?: string | null
    whatsapp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutHotelInput
    spa?: SpaUncheckedCreateNestedManyWithoutHotelInput
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutHotelInput
    tvchannels?: TVChannelsUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutToursInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutToursInput, HotelUncheckedCreateWithoutToursInput>
  }

  export type TourPriceCategoryUpsertWithWhereUniqueWithoutTourInput = {
    where: TourPriceCategoryWhereUniqueInput
    update: XOR<TourPriceCategoryUpdateWithoutTourInput, TourPriceCategoryUncheckedUpdateWithoutTourInput>
    create: XOR<TourPriceCategoryCreateWithoutTourInput, TourPriceCategoryUncheckedCreateWithoutTourInput>
  }

  export type TourPriceCategoryUpdateWithWhereUniqueWithoutTourInput = {
    where: TourPriceCategoryWhereUniqueInput
    data: XOR<TourPriceCategoryUpdateWithoutTourInput, TourPriceCategoryUncheckedUpdateWithoutTourInput>
  }

  export type TourPriceCategoryUpdateManyWithWhereWithoutTourInput = {
    where: TourPriceCategoryScalarWhereInput
    data: XOR<TourPriceCategoryUpdateManyMutationInput, TourPriceCategoryUncheckedUpdateManyWithoutTourInput>
  }

  export type TourPriceCategoryScalarWhereInput = {
    AND?: TourPriceCategoryScalarWhereInput | TourPriceCategoryScalarWhereInput[]
    OR?: TourPriceCategoryScalarWhereInput[]
    NOT?: TourPriceCategoryScalarWhereInput | TourPriceCategoryScalarWhereInput[]
    id?: StringFilter<"TourPriceCategory"> | string
    sku?: IntFilter<"TourPriceCategory"> | number
    price?: IntFilter<"TourPriceCategory"> | number
    description?: StringFilter<"TourPriceCategory"> | string
    description_esp?: StringFilter<"TourPriceCategory"> | string
    tourId?: StringFilter<"TourPriceCategory"> | string
    createdAt?: DateTimeFilter<"TourPriceCategory"> | Date | string
    updatedAt?: DateTimeFilter<"TourPriceCategory"> | Date | string
  }

  export type HotelUpsertWithoutToursInput = {
    update: XOR<HotelUpdateWithoutToursInput, HotelUncheckedUpdateWithoutToursInput>
    create: XOR<HotelCreateWithoutToursInput, HotelUncheckedCreateWithoutToursInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutToursInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutToursInput, HotelUncheckedUpdateWithoutToursInput>
  }

  export type HotelUpdateWithoutToursInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    locationDescription?: StringFieldUpdateOperationsInput | string
    locationDescription_esp?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    videos?: HotelUpdatevideosInput | string[]
    lat?: IntFieldUpdateOperationsInput | number
    lng?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    phone_reservation?: NullableStringFieldUpdateOperationsInput | string | null
    phone_tollfree?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tripadvisor?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutHotelNestedInput
    spa?: SpaUpdateManyWithoutHotelNestedInput
    amenities?: AmenitiesUpdateManyWithoutHotelNestedInput
    tvchannels?: TVChannelsUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutToursInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    locationDescription?: StringFieldUpdateOperationsInput | string
    locationDescription_esp?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    videos?: HotelUpdatevideosInput | string[]
    lat?: IntFieldUpdateOperationsInput | number
    lng?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    phone_reservation?: NullableStringFieldUpdateOperationsInput | string | null
    phone_tollfree?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tripadvisor?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutHotelNestedInput
    spa?: SpaUncheckedUpdateManyWithoutHotelNestedInput
    amenities?: AmenitiesUncheckedUpdateManyWithoutHotelNestedInput
    tvchannels?: TVChannelsUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type HotelCreateWithoutActivitiesInput = {
    id?: string
    name: string
    description: string
    description_esp: string
    image: string
    country: string
    state: string
    city: string
    locationDescription: string
    locationDescription_esp: string
    images?: HotelCreateimagesInput | string[]
    videos?: HotelCreatevideosInput | string[]
    lat: number
    lng: number
    phone: string
    phone_reservation?: string | null
    phone_tollfree?: string | null
    email: string
    website?: string
    facebook?: string | null
    tripadvisor?: string | null
    instagram?: string | null
    youtube?: string | null
    whatsapp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tours?: TourCreateNestedManyWithoutHotelInput
    spa?: SpaCreateNestedManyWithoutHotelInput
    amenities?: AmenitiesCreateNestedManyWithoutHotelInput
    tvchannels?: TVChannelsCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutActivitiesInput = {
    id?: string
    name: string
    description: string
    description_esp: string
    image: string
    country: string
    state: string
    city: string
    locationDescription: string
    locationDescription_esp: string
    images?: HotelCreateimagesInput | string[]
    videos?: HotelCreatevideosInput | string[]
    lat: number
    lng: number
    phone: string
    phone_reservation?: string | null
    phone_tollfree?: string | null
    email: string
    website?: string
    facebook?: string | null
    tripadvisor?: string | null
    instagram?: string | null
    youtube?: string | null
    whatsapp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tours?: TourUncheckedCreateNestedManyWithoutHotelInput
    spa?: SpaUncheckedCreateNestedManyWithoutHotelInput
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutHotelInput
    tvchannels?: TVChannelsUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutActivitiesInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutActivitiesInput, HotelUncheckedCreateWithoutActivitiesInput>
  }

  export type HotelUpsertWithoutActivitiesInput = {
    update: XOR<HotelUpdateWithoutActivitiesInput, HotelUncheckedUpdateWithoutActivitiesInput>
    create: XOR<HotelCreateWithoutActivitiesInput, HotelUncheckedCreateWithoutActivitiesInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutActivitiesInput, HotelUncheckedUpdateWithoutActivitiesInput>
  }

  export type HotelUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    locationDescription?: StringFieldUpdateOperationsInput | string
    locationDescription_esp?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    videos?: HotelUpdatevideosInput | string[]
    lat?: IntFieldUpdateOperationsInput | number
    lng?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    phone_reservation?: NullableStringFieldUpdateOperationsInput | string | null
    phone_tollfree?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tripadvisor?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tours?: TourUpdateManyWithoutHotelNestedInput
    spa?: SpaUpdateManyWithoutHotelNestedInput
    amenities?: AmenitiesUpdateManyWithoutHotelNestedInput
    tvchannels?: TVChannelsUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    locationDescription?: StringFieldUpdateOperationsInput | string
    locationDescription_esp?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    videos?: HotelUpdatevideosInput | string[]
    lat?: IntFieldUpdateOperationsInput | number
    lng?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    phone_reservation?: NullableStringFieldUpdateOperationsInput | string | null
    phone_tollfree?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tripadvisor?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tours?: TourUncheckedUpdateManyWithoutHotelNestedInput
    spa?: SpaUncheckedUpdateManyWithoutHotelNestedInput
    amenities?: AmenitiesUncheckedUpdateManyWithoutHotelNestedInput
    tvchannels?: TVChannelsUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type SpaCreateWithoutPricecategoryInput = {
    id?: string
    name?: string
    name_esp?: string
    description?: string
    description_esp?: string
    type?: string
    videos?: SpaCreatevideosInput | string[]
    images?: SpaCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    Hotel?: HotelCreateNestedOneWithoutSpaInput
  }

  export type SpaUncheckedCreateWithoutPricecategoryInput = {
    id?: string
    name?: string
    name_esp?: string
    description?: string
    description_esp?: string
    hotelId?: string
    type?: string
    videos?: SpaCreatevideosInput | string[]
    images?: SpaCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpaCreateOrConnectWithoutPricecategoryInput = {
    where: SpaWhereUniqueInput
    create: XOR<SpaCreateWithoutPricecategoryInput, SpaUncheckedCreateWithoutPricecategoryInput>
  }

  export type SpaUpsertWithoutPricecategoryInput = {
    update: XOR<SpaUpdateWithoutPricecategoryInput, SpaUncheckedUpdateWithoutPricecategoryInput>
    create: XOR<SpaCreateWithoutPricecategoryInput, SpaUncheckedCreateWithoutPricecategoryInput>
    where?: SpaWhereInput
  }

  export type SpaUpdateToOneWithWhereWithoutPricecategoryInput = {
    where?: SpaWhereInput
    data: XOR<SpaUpdateWithoutPricecategoryInput, SpaUncheckedUpdateWithoutPricecategoryInput>
  }

  export type SpaUpdateWithoutPricecategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    videos?: SpaUpdatevideosInput | string[]
    images?: SpaUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hotel?: HotelUpdateOneWithoutSpaNestedInput
  }

  export type SpaUncheckedUpdateWithoutPricecategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    hotelId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    videos?: SpaUpdatevideosInput | string[]
    images?: SpaUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpaPriceCategoryCreateWithoutSpaInput = {
    id?: string
    sku: number
    price: number
    description?: string
    description_esp?: string
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpaPriceCategoryUncheckedCreateWithoutSpaInput = {
    id?: string
    sku: number
    price: number
    description?: string
    description_esp?: string
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpaPriceCategoryCreateOrConnectWithoutSpaInput = {
    where: SpaPriceCategoryWhereUniqueInput
    create: XOR<SpaPriceCategoryCreateWithoutSpaInput, SpaPriceCategoryUncheckedCreateWithoutSpaInput>
  }

  export type SpaPriceCategoryCreateManySpaInputEnvelope = {
    data: SpaPriceCategoryCreateManySpaInput | SpaPriceCategoryCreateManySpaInput[]
    skipDuplicates?: boolean
  }

  export type HotelCreateWithoutSpaInput = {
    id?: string
    name: string
    description: string
    description_esp: string
    image: string
    country: string
    state: string
    city: string
    locationDescription: string
    locationDescription_esp: string
    images?: HotelCreateimagesInput | string[]
    videos?: HotelCreatevideosInput | string[]
    lat: number
    lng: number
    phone: string
    phone_reservation?: string | null
    phone_tollfree?: string | null
    email: string
    website?: string
    facebook?: string | null
    tripadvisor?: string | null
    instagram?: string | null
    youtube?: string | null
    whatsapp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutHotelInput
    tours?: TourCreateNestedManyWithoutHotelInput
    amenities?: AmenitiesCreateNestedManyWithoutHotelInput
    tvchannels?: TVChannelsCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutSpaInput = {
    id?: string
    name: string
    description: string
    description_esp: string
    image: string
    country: string
    state: string
    city: string
    locationDescription: string
    locationDescription_esp: string
    images?: HotelCreateimagesInput | string[]
    videos?: HotelCreatevideosInput | string[]
    lat: number
    lng: number
    phone: string
    phone_reservation?: string | null
    phone_tollfree?: string | null
    email: string
    website?: string
    facebook?: string | null
    tripadvisor?: string | null
    instagram?: string | null
    youtube?: string | null
    whatsapp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutHotelInput
    tours?: TourUncheckedCreateNestedManyWithoutHotelInput
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutHotelInput
    tvchannels?: TVChannelsUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutSpaInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutSpaInput, HotelUncheckedCreateWithoutSpaInput>
  }

  export type SpaPriceCategoryUpsertWithWhereUniqueWithoutSpaInput = {
    where: SpaPriceCategoryWhereUniqueInput
    update: XOR<SpaPriceCategoryUpdateWithoutSpaInput, SpaPriceCategoryUncheckedUpdateWithoutSpaInput>
    create: XOR<SpaPriceCategoryCreateWithoutSpaInput, SpaPriceCategoryUncheckedCreateWithoutSpaInput>
  }

  export type SpaPriceCategoryUpdateWithWhereUniqueWithoutSpaInput = {
    where: SpaPriceCategoryWhereUniqueInput
    data: XOR<SpaPriceCategoryUpdateWithoutSpaInput, SpaPriceCategoryUncheckedUpdateWithoutSpaInput>
  }

  export type SpaPriceCategoryUpdateManyWithWhereWithoutSpaInput = {
    where: SpaPriceCategoryScalarWhereInput
    data: XOR<SpaPriceCategoryUpdateManyMutationInput, SpaPriceCategoryUncheckedUpdateManyWithoutSpaInput>
  }

  export type SpaPriceCategoryScalarWhereInput = {
    AND?: SpaPriceCategoryScalarWhereInput | SpaPriceCategoryScalarWhereInput[]
    OR?: SpaPriceCategoryScalarWhereInput[]
    NOT?: SpaPriceCategoryScalarWhereInput | SpaPriceCategoryScalarWhereInput[]
    id?: StringFilter<"SpaPriceCategory"> | string
    sku?: IntFilter<"SpaPriceCategory"> | number
    price?: IntFilter<"SpaPriceCategory"> | number
    description?: StringFilter<"SpaPriceCategory"> | string
    description_esp?: StringFilter<"SpaPriceCategory"> | string
    duration?: IntFilter<"SpaPriceCategory"> | number
    spaId?: StringFilter<"SpaPriceCategory"> | string
    createdAt?: DateTimeFilter<"SpaPriceCategory"> | Date | string
    updatedAt?: DateTimeFilter<"SpaPriceCategory"> | Date | string
  }

  export type HotelUpsertWithoutSpaInput = {
    update: XOR<HotelUpdateWithoutSpaInput, HotelUncheckedUpdateWithoutSpaInput>
    create: XOR<HotelCreateWithoutSpaInput, HotelUncheckedCreateWithoutSpaInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutSpaInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutSpaInput, HotelUncheckedUpdateWithoutSpaInput>
  }

  export type HotelUpdateWithoutSpaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    locationDescription?: StringFieldUpdateOperationsInput | string
    locationDescription_esp?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    videos?: HotelUpdatevideosInput | string[]
    lat?: IntFieldUpdateOperationsInput | number
    lng?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    phone_reservation?: NullableStringFieldUpdateOperationsInput | string | null
    phone_tollfree?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tripadvisor?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutHotelNestedInput
    tours?: TourUpdateManyWithoutHotelNestedInput
    amenities?: AmenitiesUpdateManyWithoutHotelNestedInput
    tvchannels?: TVChannelsUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutSpaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    locationDescription?: StringFieldUpdateOperationsInput | string
    locationDescription_esp?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    videos?: HotelUpdatevideosInput | string[]
    lat?: IntFieldUpdateOperationsInput | number
    lng?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    phone_reservation?: NullableStringFieldUpdateOperationsInput | string | null
    phone_tollfree?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tripadvisor?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutHotelNestedInput
    tours?: TourUncheckedUpdateManyWithoutHotelNestedInput
    amenities?: AmenitiesUncheckedUpdateManyWithoutHotelNestedInput
    tvchannels?: TVChannelsUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type HotelCreateWithoutTvchannelsInput = {
    id?: string
    name: string
    description: string
    description_esp: string
    image: string
    country: string
    state: string
    city: string
    locationDescription: string
    locationDescription_esp: string
    images?: HotelCreateimagesInput | string[]
    videos?: HotelCreatevideosInput | string[]
    lat: number
    lng: number
    phone: string
    phone_reservation?: string | null
    phone_tollfree?: string | null
    email: string
    website?: string
    facebook?: string | null
    tripadvisor?: string | null
    instagram?: string | null
    youtube?: string | null
    whatsapp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutHotelInput
    tours?: TourCreateNestedManyWithoutHotelInput
    spa?: SpaCreateNestedManyWithoutHotelInput
    amenities?: AmenitiesCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutTvchannelsInput = {
    id?: string
    name: string
    description: string
    description_esp: string
    image: string
    country: string
    state: string
    city: string
    locationDescription: string
    locationDescription_esp: string
    images?: HotelCreateimagesInput | string[]
    videos?: HotelCreatevideosInput | string[]
    lat: number
    lng: number
    phone: string
    phone_reservation?: string | null
    phone_tollfree?: string | null
    email: string
    website?: string
    facebook?: string | null
    tripadvisor?: string | null
    instagram?: string | null
    youtube?: string | null
    whatsapp?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutHotelInput
    tours?: TourUncheckedCreateNestedManyWithoutHotelInput
    spa?: SpaUncheckedCreateNestedManyWithoutHotelInput
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutTvchannelsInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutTvchannelsInput, HotelUncheckedCreateWithoutTvchannelsInput>
  }

  export type HotelUpsertWithoutTvchannelsInput = {
    update: XOR<HotelUpdateWithoutTvchannelsInput, HotelUncheckedUpdateWithoutTvchannelsInput>
    create: XOR<HotelCreateWithoutTvchannelsInput, HotelUncheckedCreateWithoutTvchannelsInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutTvchannelsInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutTvchannelsInput, HotelUncheckedUpdateWithoutTvchannelsInput>
  }

  export type HotelUpdateWithoutTvchannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    locationDescription?: StringFieldUpdateOperationsInput | string
    locationDescription_esp?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    videos?: HotelUpdatevideosInput | string[]
    lat?: IntFieldUpdateOperationsInput | number
    lng?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    phone_reservation?: NullableStringFieldUpdateOperationsInput | string | null
    phone_tollfree?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tripadvisor?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutHotelNestedInput
    tours?: TourUpdateManyWithoutHotelNestedInput
    spa?: SpaUpdateManyWithoutHotelNestedInput
    amenities?: AmenitiesUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutTvchannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    locationDescription?: StringFieldUpdateOperationsInput | string
    locationDescription_esp?: StringFieldUpdateOperationsInput | string
    images?: HotelUpdateimagesInput | string[]
    videos?: HotelUpdatevideosInput | string[]
    lat?: IntFieldUpdateOperationsInput | number
    lng?: IntFieldUpdateOperationsInput | number
    phone?: StringFieldUpdateOperationsInput | string
    phone_reservation?: NullableStringFieldUpdateOperationsInput | string | null
    phone_tollfree?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tripadvisor?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    youtube?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutHotelNestedInput
    tours?: TourUncheckedUpdateManyWithoutHotelNestedInput
    spa?: SpaUncheckedUpdateManyWithoutHotelNestedInput
    amenities?: AmenitiesUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type CategoryCreateWithoutRestaurantInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postition?: number
    dishes?: DishCreateNestedManyWithoutCategoryInput
    subcategories?: SubcategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutRestaurantInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postition?: number
    dishes?: DishUncheckedCreateNestedManyWithoutCategoryInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutRestaurantInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutRestaurantInput, CategoryUncheckedCreateWithoutRestaurantInput>
  }

  export type CategoryCreateManyRestaurantInputEnvelope = {
    data: CategoryCreateManyRestaurantInput | CategoryCreateManyRestaurantInput[]
    skipDuplicates?: boolean
  }

  export type DishCreateWithoutRestaurantInput = {
    id?: string
    sku: number
    name: string
    name_esp: string
    description: string
    description_esp: string
    price: number
    unit?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availableAtDayOfWeek?: number
    dietaryInfo?: DishCreatedietaryInfoInput | string[]
    allergens?: DishCreateallergensInput | string[]
    ingredients?: DishCreateingredientsInput | string[]
    prepTime?: number | null
    isPopular?: boolean
    isNew?: boolean
    course_number?: number
    category: CategoryCreateNestedOneWithoutDishesInput
    subcategory?: SubcategoryCreateNestedOneWithoutDishesInput
    subSubcategory?: SubSubcategoryCreateNestedOneWithoutDishesInput
    menu?: MenuCreateNestedOneWithoutDishesInput
  }

  export type DishUncheckedCreateWithoutRestaurantInput = {
    id?: string
    sku: number
    name: string
    name_esp: string
    description: string
    description_esp: string
    price: number
    unit?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId: string
    subcategoryId?: string | null
    subSubcategoryId?: string | null
    availableAtDayOfWeek?: number
    dietaryInfo?: DishCreatedietaryInfoInput | string[]
    allergens?: DishCreateallergensInput | string[]
    ingredients?: DishCreateingredientsInput | string[]
    prepTime?: number | null
    isPopular?: boolean
    isNew?: boolean
    menuId?: string | null
    course_number?: number
  }

  export type DishCreateOrConnectWithoutRestaurantInput = {
    where: DishWhereUniqueInput
    create: XOR<DishCreateWithoutRestaurantInput, DishUncheckedCreateWithoutRestaurantInput>
  }

  export type DishCreateManyRestaurantInputEnvelope = {
    data: DishCreateManyRestaurantInput | DishCreateManyRestaurantInput[]
    skipDuplicates?: boolean
  }

  export type MenuCreateWithoutRestaurantInput = {
    id?: string
    position?: number
    name: string
    name_esp: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    dishes?: DishCreateNestedManyWithoutMenuInput
  }

  export type MenuUncheckedCreateWithoutRestaurantInput = {
    id?: string
    position?: number
    name: string
    name_esp: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    dishes?: DishUncheckedCreateNestedManyWithoutMenuInput
  }

  export type MenuCreateOrConnectWithoutRestaurantInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutRestaurantInput, MenuUncheckedCreateWithoutRestaurantInput>
  }

  export type MenuCreateManyRestaurantInputEnvelope = {
    data: MenuCreateManyRestaurantInput | MenuCreateManyRestaurantInput[]
    skipDuplicates?: boolean
  }

  export type TableCreateWithoutRestaurantInput = {
    id?: string
    number: number
    capacity: number
    location?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateWithoutRestaurantInput = {
    id?: string
    number: number
    capacity: number
    location?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableCreateOrConnectWithoutRestaurantInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutRestaurantInput, TableUncheckedCreateWithoutRestaurantInput>
  }

  export type TableCreateManyRestaurantInputEnvelope = {
    data: TableCreateManyRestaurantInput | TableCreateManyRestaurantInput[]
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutRestaurantInput = {
    id?: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    partySize: number
    status?: $Enums.ReservationStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutReservationsInput
    table?: TableCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutRestaurantInput = {
    id?: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    partySize: number
    status?: $Enums.ReservationStatus
    notes?: string | null
    customerId: string
    tableId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationCreateOrConnectWithoutRestaurantInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutRestaurantInput, ReservationUncheckedCreateWithoutRestaurantInput>
  }

  export type ReservationCreateManyRestaurantInputEnvelope = {
    data: ReservationCreateManyRestaurantInput | ReservationCreateManyRestaurantInput[]
    skipDuplicates?: boolean
  }

  export type OpeningHoursCreateWithoutRestaurantInput = {
    id?: string
    dayOfWeek: number
    openTime: string
    closeTime: string
    isClosed?: boolean
  }

  export type OpeningHoursUncheckedCreateWithoutRestaurantInput = {
    id?: string
    dayOfWeek: number
    openTime: string
    closeTime: string
    isClosed?: boolean
  }

  export type OpeningHoursCreateOrConnectWithoutRestaurantInput = {
    where: OpeningHoursWhereUniqueInput
    create: XOR<OpeningHoursCreateWithoutRestaurantInput, OpeningHoursUncheckedCreateWithoutRestaurantInput>
  }

  export type OpeningHoursCreateManyRestaurantInputEnvelope = {
    data: OpeningHoursCreateManyRestaurantInput | OpeningHoursCreateManyRestaurantInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithWhereUniqueWithoutRestaurantInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutRestaurantInput, CategoryUncheckedUpdateWithoutRestaurantInput>
    create: XOR<CategoryCreateWithoutRestaurantInput, CategoryUncheckedCreateWithoutRestaurantInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutRestaurantInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutRestaurantInput, CategoryUncheckedUpdateWithoutRestaurantInput>
  }

  export type CategoryUpdateManyWithWhereWithoutRestaurantInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutRestaurantInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    name_esp?: StringNullableFilter<"Category"> | string | null
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    description_esp?: StringNullableFilter<"Category"> | string | null
    image?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    restaurantId?: StringFilter<"Category"> | string
    postition?: IntFilter<"Category"> | number
  }

  export type DishUpsertWithWhereUniqueWithoutRestaurantInput = {
    where: DishWhereUniqueInput
    update: XOR<DishUpdateWithoutRestaurantInput, DishUncheckedUpdateWithoutRestaurantInput>
    create: XOR<DishCreateWithoutRestaurantInput, DishUncheckedCreateWithoutRestaurantInput>
  }

  export type DishUpdateWithWhereUniqueWithoutRestaurantInput = {
    where: DishWhereUniqueInput
    data: XOR<DishUpdateWithoutRestaurantInput, DishUncheckedUpdateWithoutRestaurantInput>
  }

  export type DishUpdateManyWithWhereWithoutRestaurantInput = {
    where: DishScalarWhereInput
    data: XOR<DishUpdateManyMutationInput, DishUncheckedUpdateManyWithoutRestaurantInput>
  }

  export type DishScalarWhereInput = {
    AND?: DishScalarWhereInput | DishScalarWhereInput[]
    OR?: DishScalarWhereInput[]
    NOT?: DishScalarWhereInput | DishScalarWhereInput[]
    id?: StringFilter<"Dish"> | string
    sku?: IntFilter<"Dish"> | number
    name?: StringFilter<"Dish"> | string
    name_esp?: StringFilter<"Dish"> | string
    description?: StringFilter<"Dish"> | string
    description_esp?: StringFilter<"Dish"> | string
    price?: FloatFilter<"Dish"> | number
    unit?: StringNullableFilter<"Dish"> | string | null
    image?: StringNullableFilter<"Dish"> | string | null
    createdAt?: DateTimeFilter<"Dish"> | Date | string
    updatedAt?: DateTimeFilter<"Dish"> | Date | string
    restaurantId?: StringFilter<"Dish"> | string
    categoryId?: StringFilter<"Dish"> | string
    subcategoryId?: StringNullableFilter<"Dish"> | string | null
    subSubcategoryId?: StringNullableFilter<"Dish"> | string | null
    availableAtDayOfWeek?: IntFilter<"Dish"> | number
    dietaryInfo?: StringNullableListFilter<"Dish">
    allergens?: StringNullableListFilter<"Dish">
    ingredients?: StringNullableListFilter<"Dish">
    prepTime?: IntNullableFilter<"Dish"> | number | null
    isPopular?: BoolFilter<"Dish"> | boolean
    isNew?: BoolFilter<"Dish"> | boolean
    menuId?: StringNullableFilter<"Dish"> | string | null
    course_number?: IntFilter<"Dish"> | number
  }

  export type MenuUpsertWithWhereUniqueWithoutRestaurantInput = {
    where: MenuWhereUniqueInput
    update: XOR<MenuUpdateWithoutRestaurantInput, MenuUncheckedUpdateWithoutRestaurantInput>
    create: XOR<MenuCreateWithoutRestaurantInput, MenuUncheckedCreateWithoutRestaurantInput>
  }

  export type MenuUpdateWithWhereUniqueWithoutRestaurantInput = {
    where: MenuWhereUniqueInput
    data: XOR<MenuUpdateWithoutRestaurantInput, MenuUncheckedUpdateWithoutRestaurantInput>
  }

  export type MenuUpdateManyWithWhereWithoutRestaurantInput = {
    where: MenuScalarWhereInput
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyWithoutRestaurantInput>
  }

  export type MenuScalarWhereInput = {
    AND?: MenuScalarWhereInput | MenuScalarWhereInput[]
    OR?: MenuScalarWhereInput[]
    NOT?: MenuScalarWhereInput | MenuScalarWhereInput[]
    id?: StringFilter<"Menu"> | string
    position?: IntFilter<"Menu"> | number
    name?: StringFilter<"Menu"> | string
    name_esp?: StringFilter<"Menu"> | string
    description?: StringNullableFilter<"Menu"> | string | null
    description_esp?: StringNullableFilter<"Menu"> | string | null
    image?: StringNullableFilter<"Menu"> | string | null
    price?: FloatFilter<"Menu"> | number
    restaurantId?: StringFilter<"Menu"> | string
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
    isActive?: BoolFilter<"Menu"> | boolean
  }

  export type TableUpsertWithWhereUniqueWithoutRestaurantInput = {
    where: TableWhereUniqueInput
    update: XOR<TableUpdateWithoutRestaurantInput, TableUncheckedUpdateWithoutRestaurantInput>
    create: XOR<TableCreateWithoutRestaurantInput, TableUncheckedCreateWithoutRestaurantInput>
  }

  export type TableUpdateWithWhereUniqueWithoutRestaurantInput = {
    where: TableWhereUniqueInput
    data: XOR<TableUpdateWithoutRestaurantInput, TableUncheckedUpdateWithoutRestaurantInput>
  }

  export type TableUpdateManyWithWhereWithoutRestaurantInput = {
    where: TableScalarWhereInput
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyWithoutRestaurantInput>
  }

  export type TableScalarWhereInput = {
    AND?: TableScalarWhereInput | TableScalarWhereInput[]
    OR?: TableScalarWhereInput[]
    NOT?: TableScalarWhereInput | TableScalarWhereInput[]
    id?: StringFilter<"Table"> | string
    number?: IntFilter<"Table"> | number
    capacity?: IntFilter<"Table"> | number
    location?: StringNullableFilter<"Table"> | string | null
    isActive?: BoolFilter<"Table"> | boolean
    restaurantId?: StringFilter<"Table"> | string
    createdAt?: DateTimeFilter<"Table"> | Date | string
    updatedAt?: DateTimeFilter<"Table"> | Date | string
  }

  export type ReservationUpsertWithWhereUniqueWithoutRestaurantInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutRestaurantInput, ReservationUncheckedUpdateWithoutRestaurantInput>
    create: XOR<ReservationCreateWithoutRestaurantInput, ReservationUncheckedCreateWithoutRestaurantInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutRestaurantInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutRestaurantInput, ReservationUncheckedUpdateWithoutRestaurantInput>
  }

  export type ReservationUpdateManyWithWhereWithoutRestaurantInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutRestaurantInput>
  }

  export type ReservationScalarWhereInput = {
    AND?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    OR?: ReservationScalarWhereInput[]
    NOT?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    id?: StringFilter<"Reservation"> | string
    date?: DateTimeFilter<"Reservation"> | Date | string
    startTime?: DateTimeFilter<"Reservation"> | Date | string
    endTime?: DateTimeFilter<"Reservation"> | Date | string
    partySize?: IntFilter<"Reservation"> | number
    status?: EnumReservationStatusFilter<"Reservation"> | $Enums.ReservationStatus
    notes?: StringNullableFilter<"Reservation"> | string | null
    customerId?: StringFilter<"Reservation"> | string
    tableId?: StringNullableFilter<"Reservation"> | string | null
    restaurantId?: StringFilter<"Reservation"> | string
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeFilter<"Reservation"> | Date | string
  }

  export type OpeningHoursUpsertWithWhereUniqueWithoutRestaurantInput = {
    where: OpeningHoursWhereUniqueInput
    update: XOR<OpeningHoursUpdateWithoutRestaurantInput, OpeningHoursUncheckedUpdateWithoutRestaurantInput>
    create: XOR<OpeningHoursCreateWithoutRestaurantInput, OpeningHoursUncheckedCreateWithoutRestaurantInput>
  }

  export type OpeningHoursUpdateWithWhereUniqueWithoutRestaurantInput = {
    where: OpeningHoursWhereUniqueInput
    data: XOR<OpeningHoursUpdateWithoutRestaurantInput, OpeningHoursUncheckedUpdateWithoutRestaurantInput>
  }

  export type OpeningHoursUpdateManyWithWhereWithoutRestaurantInput = {
    where: OpeningHoursScalarWhereInput
    data: XOR<OpeningHoursUpdateManyMutationInput, OpeningHoursUncheckedUpdateManyWithoutRestaurantInput>
  }

  export type OpeningHoursScalarWhereInput = {
    AND?: OpeningHoursScalarWhereInput | OpeningHoursScalarWhereInput[]
    OR?: OpeningHoursScalarWhereInput[]
    NOT?: OpeningHoursScalarWhereInput | OpeningHoursScalarWhereInput[]
    id?: StringFilter<"OpeningHours"> | string
    dayOfWeek?: IntFilter<"OpeningHours"> | number
    openTime?: StringFilter<"OpeningHours"> | string
    closeTime?: StringFilter<"OpeningHours"> | string
    isClosed?: BoolFilter<"OpeningHours"> | boolean
    restaurantId?: StringFilter<"OpeningHours"> | string
  }

  export type RestaurantCreateWithoutMenusInput = {
    id?: string
    name?: string
    description?: string | null
    descriptionshort?: string | null
    description_esp?: string | null
    descriptionshort_esp?: string | null
    image?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listorder?: number
    categories?: CategoryCreateNestedManyWithoutRestaurantInput
    dishes?: DishCreateNestedManyWithoutRestaurantInput
    tables?: TableCreateNestedManyWithoutRestaurantInput
    reservations?: ReservationCreateNestedManyWithoutRestaurantInput
    openingHours?: OpeningHoursCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUncheckedCreateWithoutMenusInput = {
    id?: string
    name?: string
    description?: string | null
    descriptionshort?: string | null
    description_esp?: string | null
    descriptionshort_esp?: string | null
    image?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listorder?: number
    categories?: CategoryUncheckedCreateNestedManyWithoutRestaurantInput
    dishes?: DishUncheckedCreateNestedManyWithoutRestaurantInput
    tables?: TableUncheckedCreateNestedManyWithoutRestaurantInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutRestaurantInput
    openingHours?: OpeningHoursUncheckedCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantCreateOrConnectWithoutMenusInput = {
    where: RestaurantWhereUniqueInput
    create: XOR<RestaurantCreateWithoutMenusInput, RestaurantUncheckedCreateWithoutMenusInput>
  }

  export type DishCreateWithoutMenuInput = {
    id?: string
    sku: number
    name: string
    name_esp: string
    description: string
    description_esp: string
    price: number
    unit?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availableAtDayOfWeek?: number
    dietaryInfo?: DishCreatedietaryInfoInput | string[]
    allergens?: DishCreateallergensInput | string[]
    ingredients?: DishCreateingredientsInput | string[]
    prepTime?: number | null
    isPopular?: boolean
    isNew?: boolean
    course_number?: number
    restaurant: RestaurantCreateNestedOneWithoutDishesInput
    category: CategoryCreateNestedOneWithoutDishesInput
    subcategory?: SubcategoryCreateNestedOneWithoutDishesInput
    subSubcategory?: SubSubcategoryCreateNestedOneWithoutDishesInput
  }

  export type DishUncheckedCreateWithoutMenuInput = {
    id?: string
    sku: number
    name: string
    name_esp: string
    description: string
    description_esp: string
    price: number
    unit?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    restaurantId: string
    categoryId: string
    subcategoryId?: string | null
    subSubcategoryId?: string | null
    availableAtDayOfWeek?: number
    dietaryInfo?: DishCreatedietaryInfoInput | string[]
    allergens?: DishCreateallergensInput | string[]
    ingredients?: DishCreateingredientsInput | string[]
    prepTime?: number | null
    isPopular?: boolean
    isNew?: boolean
    course_number?: number
  }

  export type DishCreateOrConnectWithoutMenuInput = {
    where: DishWhereUniqueInput
    create: XOR<DishCreateWithoutMenuInput, DishUncheckedCreateWithoutMenuInput>
  }

  export type DishCreateManyMenuInputEnvelope = {
    data: DishCreateManyMenuInput | DishCreateManyMenuInput[]
    skipDuplicates?: boolean
  }

  export type RestaurantUpsertWithoutMenusInput = {
    update: XOR<RestaurantUpdateWithoutMenusInput, RestaurantUncheckedUpdateWithoutMenusInput>
    create: XOR<RestaurantCreateWithoutMenusInput, RestaurantUncheckedCreateWithoutMenusInput>
    where?: RestaurantWhereInput
  }

  export type RestaurantUpdateToOneWithWhereWithoutMenusInput = {
    where?: RestaurantWhereInput
    data: XOR<RestaurantUpdateWithoutMenusInput, RestaurantUncheckedUpdateWithoutMenusInput>
  }

  export type RestaurantUpdateWithoutMenusInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listorder?: IntFieldUpdateOperationsInput | number
    categories?: CategoryUpdateManyWithoutRestaurantNestedInput
    dishes?: DishUpdateManyWithoutRestaurantNestedInput
    tables?: TableUpdateManyWithoutRestaurantNestedInput
    reservations?: ReservationUpdateManyWithoutRestaurantNestedInput
    openingHours?: OpeningHoursUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateWithoutMenusInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listorder?: IntFieldUpdateOperationsInput | number
    categories?: CategoryUncheckedUpdateManyWithoutRestaurantNestedInput
    dishes?: DishUncheckedUpdateManyWithoutRestaurantNestedInput
    tables?: TableUncheckedUpdateManyWithoutRestaurantNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutRestaurantNestedInput
    openingHours?: OpeningHoursUncheckedUpdateManyWithoutRestaurantNestedInput
  }

  export type DishUpsertWithWhereUniqueWithoutMenuInput = {
    where: DishWhereUniqueInput
    update: XOR<DishUpdateWithoutMenuInput, DishUncheckedUpdateWithoutMenuInput>
    create: XOR<DishCreateWithoutMenuInput, DishUncheckedCreateWithoutMenuInput>
  }

  export type DishUpdateWithWhereUniqueWithoutMenuInput = {
    where: DishWhereUniqueInput
    data: XOR<DishUpdateWithoutMenuInput, DishUncheckedUpdateWithoutMenuInput>
  }

  export type DishUpdateManyWithWhereWithoutMenuInput = {
    where: DishScalarWhereInput
    data: XOR<DishUpdateManyMutationInput, DishUncheckedUpdateManyWithoutMenuInput>
  }

  export type RestaurantCreateWithoutTablesInput = {
    id?: string
    name?: string
    description?: string | null
    descriptionshort?: string | null
    description_esp?: string | null
    descriptionshort_esp?: string | null
    image?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listorder?: number
    categories?: CategoryCreateNestedManyWithoutRestaurantInput
    dishes?: DishCreateNestedManyWithoutRestaurantInput
    menus?: MenuCreateNestedManyWithoutRestaurantInput
    reservations?: ReservationCreateNestedManyWithoutRestaurantInput
    openingHours?: OpeningHoursCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUncheckedCreateWithoutTablesInput = {
    id?: string
    name?: string
    description?: string | null
    descriptionshort?: string | null
    description_esp?: string | null
    descriptionshort_esp?: string | null
    image?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listorder?: number
    categories?: CategoryUncheckedCreateNestedManyWithoutRestaurantInput
    dishes?: DishUncheckedCreateNestedManyWithoutRestaurantInput
    menus?: MenuUncheckedCreateNestedManyWithoutRestaurantInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutRestaurantInput
    openingHours?: OpeningHoursUncheckedCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantCreateOrConnectWithoutTablesInput = {
    where: RestaurantWhereUniqueInput
    create: XOR<RestaurantCreateWithoutTablesInput, RestaurantUncheckedCreateWithoutTablesInput>
  }

  export type ReservationCreateWithoutTableInput = {
    id?: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    partySize: number
    status?: $Enums.ReservationStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutReservationsInput
    restaurant: RestaurantCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutTableInput = {
    id?: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    partySize: number
    status?: $Enums.ReservationStatus
    notes?: string | null
    customerId: string
    restaurantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationCreateOrConnectWithoutTableInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutTableInput, ReservationUncheckedCreateWithoutTableInput>
  }

  export type ReservationCreateManyTableInputEnvelope = {
    data: ReservationCreateManyTableInput | ReservationCreateManyTableInput[]
    skipDuplicates?: boolean
  }

  export type RestaurantUpsertWithoutTablesInput = {
    update: XOR<RestaurantUpdateWithoutTablesInput, RestaurantUncheckedUpdateWithoutTablesInput>
    create: XOR<RestaurantCreateWithoutTablesInput, RestaurantUncheckedCreateWithoutTablesInput>
    where?: RestaurantWhereInput
  }

  export type RestaurantUpdateToOneWithWhereWithoutTablesInput = {
    where?: RestaurantWhereInput
    data: XOR<RestaurantUpdateWithoutTablesInput, RestaurantUncheckedUpdateWithoutTablesInput>
  }

  export type RestaurantUpdateWithoutTablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listorder?: IntFieldUpdateOperationsInput | number
    categories?: CategoryUpdateManyWithoutRestaurantNestedInput
    dishes?: DishUpdateManyWithoutRestaurantNestedInput
    menus?: MenuUpdateManyWithoutRestaurantNestedInput
    reservations?: ReservationUpdateManyWithoutRestaurantNestedInput
    openingHours?: OpeningHoursUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateWithoutTablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listorder?: IntFieldUpdateOperationsInput | number
    categories?: CategoryUncheckedUpdateManyWithoutRestaurantNestedInput
    dishes?: DishUncheckedUpdateManyWithoutRestaurantNestedInput
    menus?: MenuUncheckedUpdateManyWithoutRestaurantNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutRestaurantNestedInput
    openingHours?: OpeningHoursUncheckedUpdateManyWithoutRestaurantNestedInput
  }

  export type ReservationUpsertWithWhereUniqueWithoutTableInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutTableInput, ReservationUncheckedUpdateWithoutTableInput>
    create: XOR<ReservationCreateWithoutTableInput, ReservationUncheckedCreateWithoutTableInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutTableInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutTableInput, ReservationUncheckedUpdateWithoutTableInput>
  }

  export type ReservationUpdateManyWithWhereWithoutTableInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutTableInput>
  }

  export type ReservationCreateWithoutCustomerInput = {
    id?: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    partySize: number
    status?: $Enums.ReservationStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    table?: TableCreateNestedOneWithoutReservationsInput
    restaurant: RestaurantCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutCustomerInput = {
    id?: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    partySize: number
    status?: $Enums.ReservationStatus
    notes?: string | null
    tableId?: string | null
    restaurantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationCreateOrConnectWithoutCustomerInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutCustomerInput, ReservationUncheckedCreateWithoutCustomerInput>
  }

  export type ReservationCreateManyCustomerInputEnvelope = {
    data: ReservationCreateManyCustomerInput | ReservationCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type ReservationUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutCustomerInput, ReservationUncheckedUpdateWithoutCustomerInput>
    create: XOR<ReservationCreateWithoutCustomerInput, ReservationUncheckedCreateWithoutCustomerInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutCustomerInput, ReservationUncheckedUpdateWithoutCustomerInput>
  }

  export type ReservationUpdateManyWithWhereWithoutCustomerInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerCreateWithoutReservationsInput = {
    id?: string
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUncheckedCreateWithoutReservationsInput = {
    id?: string
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerCreateOrConnectWithoutReservationsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutReservationsInput, CustomerUncheckedCreateWithoutReservationsInput>
  }

  export type TableCreateWithoutReservationsInput = {
    id?: string
    number: number
    capacity: number
    location?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    restaurant: RestaurantCreateNestedOneWithoutTablesInput
  }

  export type TableUncheckedCreateWithoutReservationsInput = {
    id?: string
    number: number
    capacity: number
    location?: string | null
    isActive?: boolean
    restaurantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TableCreateOrConnectWithoutReservationsInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutReservationsInput, TableUncheckedCreateWithoutReservationsInput>
  }

  export type RestaurantCreateWithoutReservationsInput = {
    id?: string
    name?: string
    description?: string | null
    descriptionshort?: string | null
    description_esp?: string | null
    descriptionshort_esp?: string | null
    image?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listorder?: number
    categories?: CategoryCreateNestedManyWithoutRestaurantInput
    dishes?: DishCreateNestedManyWithoutRestaurantInput
    menus?: MenuCreateNestedManyWithoutRestaurantInput
    tables?: TableCreateNestedManyWithoutRestaurantInput
    openingHours?: OpeningHoursCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUncheckedCreateWithoutReservationsInput = {
    id?: string
    name?: string
    description?: string | null
    descriptionshort?: string | null
    description_esp?: string | null
    descriptionshort_esp?: string | null
    image?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listorder?: number
    categories?: CategoryUncheckedCreateNestedManyWithoutRestaurantInput
    dishes?: DishUncheckedCreateNestedManyWithoutRestaurantInput
    menus?: MenuUncheckedCreateNestedManyWithoutRestaurantInput
    tables?: TableUncheckedCreateNestedManyWithoutRestaurantInput
    openingHours?: OpeningHoursUncheckedCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantCreateOrConnectWithoutReservationsInput = {
    where: RestaurantWhereUniqueInput
    create: XOR<RestaurantCreateWithoutReservationsInput, RestaurantUncheckedCreateWithoutReservationsInput>
  }

  export type CustomerUpsertWithoutReservationsInput = {
    update: XOR<CustomerUpdateWithoutReservationsInput, CustomerUncheckedUpdateWithoutReservationsInput>
    create: XOR<CustomerCreateWithoutReservationsInput, CustomerUncheckedCreateWithoutReservationsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutReservationsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutReservationsInput, CustomerUncheckedUpdateWithoutReservationsInput>
  }

  export type CustomerUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TableUpsertWithoutReservationsInput = {
    update: XOR<TableUpdateWithoutReservationsInput, TableUncheckedUpdateWithoutReservationsInput>
    create: XOR<TableCreateWithoutReservationsInput, TableUncheckedCreateWithoutReservationsInput>
    where?: TableWhereInput
  }

  export type TableUpdateToOneWithWhereWithoutReservationsInput = {
    where?: TableWhereInput
    data: XOR<TableUpdateWithoutReservationsInput, TableUncheckedUpdateWithoutReservationsInput>
  }

  export type TableUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    restaurant?: RestaurantUpdateOneRequiredWithoutTablesNestedInput
  }

  export type TableUncheckedUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    restaurantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RestaurantUpsertWithoutReservationsInput = {
    update: XOR<RestaurantUpdateWithoutReservationsInput, RestaurantUncheckedUpdateWithoutReservationsInput>
    create: XOR<RestaurantCreateWithoutReservationsInput, RestaurantUncheckedCreateWithoutReservationsInput>
    where?: RestaurantWhereInput
  }

  export type RestaurantUpdateToOneWithWhereWithoutReservationsInput = {
    where?: RestaurantWhereInput
    data: XOR<RestaurantUpdateWithoutReservationsInput, RestaurantUncheckedUpdateWithoutReservationsInput>
  }

  export type RestaurantUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listorder?: IntFieldUpdateOperationsInput | number
    categories?: CategoryUpdateManyWithoutRestaurantNestedInput
    dishes?: DishUpdateManyWithoutRestaurantNestedInput
    menus?: MenuUpdateManyWithoutRestaurantNestedInput
    tables?: TableUpdateManyWithoutRestaurantNestedInput
    openingHours?: OpeningHoursUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listorder?: IntFieldUpdateOperationsInput | number
    categories?: CategoryUncheckedUpdateManyWithoutRestaurantNestedInput
    dishes?: DishUncheckedUpdateManyWithoutRestaurantNestedInput
    menus?: MenuUncheckedUpdateManyWithoutRestaurantNestedInput
    tables?: TableUncheckedUpdateManyWithoutRestaurantNestedInput
    openingHours?: OpeningHoursUncheckedUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantCreateWithoutCategoriesInput = {
    id?: string
    name?: string
    description?: string | null
    descriptionshort?: string | null
    description_esp?: string | null
    descriptionshort_esp?: string | null
    image?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listorder?: number
    dishes?: DishCreateNestedManyWithoutRestaurantInput
    menus?: MenuCreateNestedManyWithoutRestaurantInput
    tables?: TableCreateNestedManyWithoutRestaurantInput
    reservations?: ReservationCreateNestedManyWithoutRestaurantInput
    openingHours?: OpeningHoursCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUncheckedCreateWithoutCategoriesInput = {
    id?: string
    name?: string
    description?: string | null
    descriptionshort?: string | null
    description_esp?: string | null
    descriptionshort_esp?: string | null
    image?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listorder?: number
    dishes?: DishUncheckedCreateNestedManyWithoutRestaurantInput
    menus?: MenuUncheckedCreateNestedManyWithoutRestaurantInput
    tables?: TableUncheckedCreateNestedManyWithoutRestaurantInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutRestaurantInput
    openingHours?: OpeningHoursUncheckedCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantCreateOrConnectWithoutCategoriesInput = {
    where: RestaurantWhereUniqueInput
    create: XOR<RestaurantCreateWithoutCategoriesInput, RestaurantUncheckedCreateWithoutCategoriesInput>
  }

  export type DishCreateWithoutCategoryInput = {
    id?: string
    sku: number
    name: string
    name_esp: string
    description: string
    description_esp: string
    price: number
    unit?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availableAtDayOfWeek?: number
    dietaryInfo?: DishCreatedietaryInfoInput | string[]
    allergens?: DishCreateallergensInput | string[]
    ingredients?: DishCreateingredientsInput | string[]
    prepTime?: number | null
    isPopular?: boolean
    isNew?: boolean
    course_number?: number
    restaurant: RestaurantCreateNestedOneWithoutDishesInput
    subcategory?: SubcategoryCreateNestedOneWithoutDishesInput
    subSubcategory?: SubSubcategoryCreateNestedOneWithoutDishesInput
    menu?: MenuCreateNestedOneWithoutDishesInput
  }

  export type DishUncheckedCreateWithoutCategoryInput = {
    id?: string
    sku: number
    name: string
    name_esp: string
    description: string
    description_esp: string
    price: number
    unit?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    restaurantId: string
    subcategoryId?: string | null
    subSubcategoryId?: string | null
    availableAtDayOfWeek?: number
    dietaryInfo?: DishCreatedietaryInfoInput | string[]
    allergens?: DishCreateallergensInput | string[]
    ingredients?: DishCreateingredientsInput | string[]
    prepTime?: number | null
    isPopular?: boolean
    isNew?: boolean
    menuId?: string | null
    course_number?: number
  }

  export type DishCreateOrConnectWithoutCategoryInput = {
    where: DishWhereUniqueInput
    create: XOR<DishCreateWithoutCategoryInput, DishUncheckedCreateWithoutCategoryInput>
  }

  export type DishCreateManyCategoryInputEnvelope = {
    data: DishCreateManyCategoryInput | DishCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type SubcategoryCreateWithoutCategoryInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postition?: number
    dishes?: DishCreateNestedManyWithoutSubcategoryInput
    subSubcategories?: SubSubcategoryCreateNestedManyWithoutSubcategoryInput
  }

  export type SubcategoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postition?: number
    dishes?: DishUncheckedCreateNestedManyWithoutSubcategoryInput
    subSubcategories?: SubSubcategoryUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type SubcategoryCreateOrConnectWithoutCategoryInput = {
    where: SubcategoryWhereUniqueInput
    create: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput>
  }

  export type SubcategoryCreateManyCategoryInputEnvelope = {
    data: SubcategoryCreateManyCategoryInput | SubcategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type RestaurantUpsertWithoutCategoriesInput = {
    update: XOR<RestaurantUpdateWithoutCategoriesInput, RestaurantUncheckedUpdateWithoutCategoriesInput>
    create: XOR<RestaurantCreateWithoutCategoriesInput, RestaurantUncheckedCreateWithoutCategoriesInput>
    where?: RestaurantWhereInput
  }

  export type RestaurantUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: RestaurantWhereInput
    data: XOR<RestaurantUpdateWithoutCategoriesInput, RestaurantUncheckedUpdateWithoutCategoriesInput>
  }

  export type RestaurantUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listorder?: IntFieldUpdateOperationsInput | number
    dishes?: DishUpdateManyWithoutRestaurantNestedInput
    menus?: MenuUpdateManyWithoutRestaurantNestedInput
    tables?: TableUpdateManyWithoutRestaurantNestedInput
    reservations?: ReservationUpdateManyWithoutRestaurantNestedInput
    openingHours?: OpeningHoursUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listorder?: IntFieldUpdateOperationsInput | number
    dishes?: DishUncheckedUpdateManyWithoutRestaurantNestedInput
    menus?: MenuUncheckedUpdateManyWithoutRestaurantNestedInput
    tables?: TableUncheckedUpdateManyWithoutRestaurantNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutRestaurantNestedInput
    openingHours?: OpeningHoursUncheckedUpdateManyWithoutRestaurantNestedInput
  }

  export type DishUpsertWithWhereUniqueWithoutCategoryInput = {
    where: DishWhereUniqueInput
    update: XOR<DishUpdateWithoutCategoryInput, DishUncheckedUpdateWithoutCategoryInput>
    create: XOR<DishCreateWithoutCategoryInput, DishUncheckedCreateWithoutCategoryInput>
  }

  export type DishUpdateWithWhereUniqueWithoutCategoryInput = {
    where: DishWhereUniqueInput
    data: XOR<DishUpdateWithoutCategoryInput, DishUncheckedUpdateWithoutCategoryInput>
  }

  export type DishUpdateManyWithWhereWithoutCategoryInput = {
    where: DishScalarWhereInput
    data: XOR<DishUpdateManyMutationInput, DishUncheckedUpdateManyWithoutCategoryInput>
  }

  export type SubcategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: SubcategoryWhereUniqueInput
    update: XOR<SubcategoryUpdateWithoutCategoryInput, SubcategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput>
  }

  export type SubcategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: SubcategoryWhereUniqueInput
    data: XOR<SubcategoryUpdateWithoutCategoryInput, SubcategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type SubcategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: SubcategoryScalarWhereInput
    data: XOR<SubcategoryUpdateManyMutationInput, SubcategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type SubcategoryScalarWhereInput = {
    AND?: SubcategoryScalarWhereInput | SubcategoryScalarWhereInput[]
    OR?: SubcategoryScalarWhereInput[]
    NOT?: SubcategoryScalarWhereInput | SubcategoryScalarWhereInput[]
    id?: StringFilter<"Subcategory"> | string
    name?: StringFilter<"Subcategory"> | string
    name_esp?: StringNullableFilter<"Subcategory"> | string | null
    slug?: StringFilter<"Subcategory"> | string
    description?: StringNullableFilter<"Subcategory"> | string | null
    description_esp?: StringNullableFilter<"Subcategory"> | string | null
    image?: StringNullableFilter<"Subcategory"> | string | null
    createdAt?: DateTimeFilter<"Subcategory"> | Date | string
    updatedAt?: DateTimeFilter<"Subcategory"> | Date | string
    parentCategoryId?: StringFilter<"Subcategory"> | string
    postition?: IntFilter<"Subcategory"> | number
  }

  export type CategoryCreateWithoutSubcategoriesInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postition?: number
    restaurant: RestaurantCreateNestedOneWithoutCategoriesInput
    dishes?: DishCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutSubcategoriesInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    restaurantId: string
    postition?: number
    dishes?: DishUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutSubcategoriesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutSubcategoriesInput, CategoryUncheckedCreateWithoutSubcategoriesInput>
  }

  export type DishCreateWithoutSubcategoryInput = {
    id?: string
    sku: number
    name: string
    name_esp: string
    description: string
    description_esp: string
    price: number
    unit?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availableAtDayOfWeek?: number
    dietaryInfo?: DishCreatedietaryInfoInput | string[]
    allergens?: DishCreateallergensInput | string[]
    ingredients?: DishCreateingredientsInput | string[]
    prepTime?: number | null
    isPopular?: boolean
    isNew?: boolean
    course_number?: number
    restaurant: RestaurantCreateNestedOneWithoutDishesInput
    category: CategoryCreateNestedOneWithoutDishesInput
    subSubcategory?: SubSubcategoryCreateNestedOneWithoutDishesInput
    menu?: MenuCreateNestedOneWithoutDishesInput
  }

  export type DishUncheckedCreateWithoutSubcategoryInput = {
    id?: string
    sku: number
    name: string
    name_esp: string
    description: string
    description_esp: string
    price: number
    unit?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    restaurantId: string
    categoryId: string
    subSubcategoryId?: string | null
    availableAtDayOfWeek?: number
    dietaryInfo?: DishCreatedietaryInfoInput | string[]
    allergens?: DishCreateallergensInput | string[]
    ingredients?: DishCreateingredientsInput | string[]
    prepTime?: number | null
    isPopular?: boolean
    isNew?: boolean
    menuId?: string | null
    course_number?: number
  }

  export type DishCreateOrConnectWithoutSubcategoryInput = {
    where: DishWhereUniqueInput
    create: XOR<DishCreateWithoutSubcategoryInput, DishUncheckedCreateWithoutSubcategoryInput>
  }

  export type DishCreateManySubcategoryInputEnvelope = {
    data: DishCreateManySubcategoryInput | DishCreateManySubcategoryInput[]
    skipDuplicates?: boolean
  }

  export type SubSubcategoryCreateWithoutSubcategoryInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postition?: number
    dishes?: DishCreateNestedManyWithoutSubSubcategoryInput
  }

  export type SubSubcategoryUncheckedCreateWithoutSubcategoryInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postition?: number
    dishes?: DishUncheckedCreateNestedManyWithoutSubSubcategoryInput
  }

  export type SubSubcategoryCreateOrConnectWithoutSubcategoryInput = {
    where: SubSubcategoryWhereUniqueInput
    create: XOR<SubSubcategoryCreateWithoutSubcategoryInput, SubSubcategoryUncheckedCreateWithoutSubcategoryInput>
  }

  export type SubSubcategoryCreateManySubcategoryInputEnvelope = {
    data: SubSubcategoryCreateManySubcategoryInput | SubSubcategoryCreateManySubcategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutSubcategoriesInput = {
    update: XOR<CategoryUpdateWithoutSubcategoriesInput, CategoryUncheckedUpdateWithoutSubcategoriesInput>
    create: XOR<CategoryCreateWithoutSubcategoriesInput, CategoryUncheckedCreateWithoutSubcategoriesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutSubcategoriesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutSubcategoriesInput, CategoryUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type CategoryUpdateWithoutSubcategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postition?: IntFieldUpdateOperationsInput | number
    restaurant?: RestaurantUpdateOneRequiredWithoutCategoriesNestedInput
    dishes?: DishUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutSubcategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    postition?: IntFieldUpdateOperationsInput | number
    dishes?: DishUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type DishUpsertWithWhereUniqueWithoutSubcategoryInput = {
    where: DishWhereUniqueInput
    update: XOR<DishUpdateWithoutSubcategoryInput, DishUncheckedUpdateWithoutSubcategoryInput>
    create: XOR<DishCreateWithoutSubcategoryInput, DishUncheckedCreateWithoutSubcategoryInput>
  }

  export type DishUpdateWithWhereUniqueWithoutSubcategoryInput = {
    where: DishWhereUniqueInput
    data: XOR<DishUpdateWithoutSubcategoryInput, DishUncheckedUpdateWithoutSubcategoryInput>
  }

  export type DishUpdateManyWithWhereWithoutSubcategoryInput = {
    where: DishScalarWhereInput
    data: XOR<DishUpdateManyMutationInput, DishUncheckedUpdateManyWithoutSubcategoryInput>
  }

  export type SubSubcategoryUpsertWithWhereUniqueWithoutSubcategoryInput = {
    where: SubSubcategoryWhereUniqueInput
    update: XOR<SubSubcategoryUpdateWithoutSubcategoryInput, SubSubcategoryUncheckedUpdateWithoutSubcategoryInput>
    create: XOR<SubSubcategoryCreateWithoutSubcategoryInput, SubSubcategoryUncheckedCreateWithoutSubcategoryInput>
  }

  export type SubSubcategoryUpdateWithWhereUniqueWithoutSubcategoryInput = {
    where: SubSubcategoryWhereUniqueInput
    data: XOR<SubSubcategoryUpdateWithoutSubcategoryInput, SubSubcategoryUncheckedUpdateWithoutSubcategoryInput>
  }

  export type SubSubcategoryUpdateManyWithWhereWithoutSubcategoryInput = {
    where: SubSubcategoryScalarWhereInput
    data: XOR<SubSubcategoryUpdateManyMutationInput, SubSubcategoryUncheckedUpdateManyWithoutSubcategoryInput>
  }

  export type SubSubcategoryScalarWhereInput = {
    AND?: SubSubcategoryScalarWhereInput | SubSubcategoryScalarWhereInput[]
    OR?: SubSubcategoryScalarWhereInput[]
    NOT?: SubSubcategoryScalarWhereInput | SubSubcategoryScalarWhereInput[]
    id?: StringFilter<"SubSubcategory"> | string
    name?: StringFilter<"SubSubcategory"> | string
    name_esp?: StringNullableFilter<"SubSubcategory"> | string | null
    slug?: StringFilter<"SubSubcategory"> | string
    description?: StringNullableFilter<"SubSubcategory"> | string | null
    description_esp?: StringNullableFilter<"SubSubcategory"> | string | null
    image?: StringNullableFilter<"SubSubcategory"> | string | null
    createdAt?: DateTimeFilter<"SubSubcategory"> | Date | string
    updatedAt?: DateTimeFilter<"SubSubcategory"> | Date | string
    parentSubcategoryId?: StringFilter<"SubSubcategory"> | string
    postition?: IntFilter<"SubSubcategory"> | number
  }

  export type SubcategoryCreateWithoutSubSubcategoriesInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postition?: number
    category: CategoryCreateNestedOneWithoutSubcategoriesInput
    dishes?: DishCreateNestedManyWithoutSubcategoryInput
  }

  export type SubcategoryUncheckedCreateWithoutSubSubcategoriesInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentCategoryId: string
    postition?: number
    dishes?: DishUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type SubcategoryCreateOrConnectWithoutSubSubcategoriesInput = {
    where: SubcategoryWhereUniqueInput
    create: XOR<SubcategoryCreateWithoutSubSubcategoriesInput, SubcategoryUncheckedCreateWithoutSubSubcategoriesInput>
  }

  export type DishCreateWithoutSubSubcategoryInput = {
    id?: string
    sku: number
    name: string
    name_esp: string
    description: string
    description_esp: string
    price: number
    unit?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availableAtDayOfWeek?: number
    dietaryInfo?: DishCreatedietaryInfoInput | string[]
    allergens?: DishCreateallergensInput | string[]
    ingredients?: DishCreateingredientsInput | string[]
    prepTime?: number | null
    isPopular?: boolean
    isNew?: boolean
    course_number?: number
    restaurant: RestaurantCreateNestedOneWithoutDishesInput
    category: CategoryCreateNestedOneWithoutDishesInput
    subcategory?: SubcategoryCreateNestedOneWithoutDishesInput
    menu?: MenuCreateNestedOneWithoutDishesInput
  }

  export type DishUncheckedCreateWithoutSubSubcategoryInput = {
    id?: string
    sku: number
    name: string
    name_esp: string
    description: string
    description_esp: string
    price: number
    unit?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    restaurantId: string
    categoryId: string
    subcategoryId?: string | null
    availableAtDayOfWeek?: number
    dietaryInfo?: DishCreatedietaryInfoInput | string[]
    allergens?: DishCreateallergensInput | string[]
    ingredients?: DishCreateingredientsInput | string[]
    prepTime?: number | null
    isPopular?: boolean
    isNew?: boolean
    menuId?: string | null
    course_number?: number
  }

  export type DishCreateOrConnectWithoutSubSubcategoryInput = {
    where: DishWhereUniqueInput
    create: XOR<DishCreateWithoutSubSubcategoryInput, DishUncheckedCreateWithoutSubSubcategoryInput>
  }

  export type DishCreateManySubSubcategoryInputEnvelope = {
    data: DishCreateManySubSubcategoryInput | DishCreateManySubSubcategoryInput[]
    skipDuplicates?: boolean
  }

  export type SubcategoryUpsertWithoutSubSubcategoriesInput = {
    update: XOR<SubcategoryUpdateWithoutSubSubcategoriesInput, SubcategoryUncheckedUpdateWithoutSubSubcategoriesInput>
    create: XOR<SubcategoryCreateWithoutSubSubcategoriesInput, SubcategoryUncheckedCreateWithoutSubSubcategoriesInput>
    where?: SubcategoryWhereInput
  }

  export type SubcategoryUpdateToOneWithWhereWithoutSubSubcategoriesInput = {
    where?: SubcategoryWhereInput
    data: XOR<SubcategoryUpdateWithoutSubSubcategoriesInput, SubcategoryUncheckedUpdateWithoutSubSubcategoriesInput>
  }

  export type SubcategoryUpdateWithoutSubSubcategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postition?: IntFieldUpdateOperationsInput | number
    category?: CategoryUpdateOneRequiredWithoutSubcategoriesNestedInput
    dishes?: DishUpdateManyWithoutSubcategoryNestedInput
  }

  export type SubcategoryUncheckedUpdateWithoutSubSubcategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentCategoryId?: StringFieldUpdateOperationsInput | string
    postition?: IntFieldUpdateOperationsInput | number
    dishes?: DishUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type DishUpsertWithWhereUniqueWithoutSubSubcategoryInput = {
    where: DishWhereUniqueInput
    update: XOR<DishUpdateWithoutSubSubcategoryInput, DishUncheckedUpdateWithoutSubSubcategoryInput>
    create: XOR<DishCreateWithoutSubSubcategoryInput, DishUncheckedCreateWithoutSubSubcategoryInput>
  }

  export type DishUpdateWithWhereUniqueWithoutSubSubcategoryInput = {
    where: DishWhereUniqueInput
    data: XOR<DishUpdateWithoutSubSubcategoryInput, DishUncheckedUpdateWithoutSubSubcategoryInput>
  }

  export type DishUpdateManyWithWhereWithoutSubSubcategoryInput = {
    where: DishScalarWhereInput
    data: XOR<DishUpdateManyMutationInput, DishUncheckedUpdateManyWithoutSubSubcategoryInput>
  }

  export type RestaurantCreateWithoutDishesInput = {
    id?: string
    name?: string
    description?: string | null
    descriptionshort?: string | null
    description_esp?: string | null
    descriptionshort_esp?: string | null
    image?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listorder?: number
    categories?: CategoryCreateNestedManyWithoutRestaurantInput
    menus?: MenuCreateNestedManyWithoutRestaurantInput
    tables?: TableCreateNestedManyWithoutRestaurantInput
    reservations?: ReservationCreateNestedManyWithoutRestaurantInput
    openingHours?: OpeningHoursCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUncheckedCreateWithoutDishesInput = {
    id?: string
    name?: string
    description?: string | null
    descriptionshort?: string | null
    description_esp?: string | null
    descriptionshort_esp?: string | null
    image?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listorder?: number
    categories?: CategoryUncheckedCreateNestedManyWithoutRestaurantInput
    menus?: MenuUncheckedCreateNestedManyWithoutRestaurantInput
    tables?: TableUncheckedCreateNestedManyWithoutRestaurantInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutRestaurantInput
    openingHours?: OpeningHoursUncheckedCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantCreateOrConnectWithoutDishesInput = {
    where: RestaurantWhereUniqueInput
    create: XOR<RestaurantCreateWithoutDishesInput, RestaurantUncheckedCreateWithoutDishesInput>
  }

  export type CategoryCreateWithoutDishesInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postition?: number
    restaurant: RestaurantCreateNestedOneWithoutCategoriesInput
    subcategories?: SubcategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutDishesInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    restaurantId: string
    postition?: number
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutDishesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutDishesInput, CategoryUncheckedCreateWithoutDishesInput>
  }

  export type SubcategoryCreateWithoutDishesInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postition?: number
    category: CategoryCreateNestedOneWithoutSubcategoriesInput
    subSubcategories?: SubSubcategoryCreateNestedManyWithoutSubcategoryInput
  }

  export type SubcategoryUncheckedCreateWithoutDishesInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentCategoryId: string
    postition?: number
    subSubcategories?: SubSubcategoryUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type SubcategoryCreateOrConnectWithoutDishesInput = {
    where: SubcategoryWhereUniqueInput
    create: XOR<SubcategoryCreateWithoutDishesInput, SubcategoryUncheckedCreateWithoutDishesInput>
  }

  export type SubSubcategoryCreateWithoutDishesInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postition?: number
    subcategory: SubcategoryCreateNestedOneWithoutSubSubcategoriesInput
  }

  export type SubSubcategoryUncheckedCreateWithoutDishesInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentSubcategoryId: string
    postition?: number
  }

  export type SubSubcategoryCreateOrConnectWithoutDishesInput = {
    where: SubSubcategoryWhereUniqueInput
    create: XOR<SubSubcategoryCreateWithoutDishesInput, SubSubcategoryUncheckedCreateWithoutDishesInput>
  }

  export type MenuCreateWithoutDishesInput = {
    id?: string
    position?: number
    name: string
    name_esp: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    restaurant: RestaurantCreateNestedOneWithoutMenusInput
  }

  export type MenuUncheckedCreateWithoutDishesInput = {
    id?: string
    position?: number
    name: string
    name_esp: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    price: number
    restaurantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type MenuCreateOrConnectWithoutDishesInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutDishesInput, MenuUncheckedCreateWithoutDishesInput>
  }

  export type RestaurantUpsertWithoutDishesInput = {
    update: XOR<RestaurantUpdateWithoutDishesInput, RestaurantUncheckedUpdateWithoutDishesInput>
    create: XOR<RestaurantCreateWithoutDishesInput, RestaurantUncheckedCreateWithoutDishesInput>
    where?: RestaurantWhereInput
  }

  export type RestaurantUpdateToOneWithWhereWithoutDishesInput = {
    where?: RestaurantWhereInput
    data: XOR<RestaurantUpdateWithoutDishesInput, RestaurantUncheckedUpdateWithoutDishesInput>
  }

  export type RestaurantUpdateWithoutDishesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listorder?: IntFieldUpdateOperationsInput | number
    categories?: CategoryUpdateManyWithoutRestaurantNestedInput
    menus?: MenuUpdateManyWithoutRestaurantNestedInput
    tables?: TableUpdateManyWithoutRestaurantNestedInput
    reservations?: ReservationUpdateManyWithoutRestaurantNestedInput
    openingHours?: OpeningHoursUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateWithoutDishesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listorder?: IntFieldUpdateOperationsInput | number
    categories?: CategoryUncheckedUpdateManyWithoutRestaurantNestedInput
    menus?: MenuUncheckedUpdateManyWithoutRestaurantNestedInput
    tables?: TableUncheckedUpdateManyWithoutRestaurantNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutRestaurantNestedInput
    openingHours?: OpeningHoursUncheckedUpdateManyWithoutRestaurantNestedInput
  }

  export type CategoryUpsertWithoutDishesInput = {
    update: XOR<CategoryUpdateWithoutDishesInput, CategoryUncheckedUpdateWithoutDishesInput>
    create: XOR<CategoryCreateWithoutDishesInput, CategoryUncheckedCreateWithoutDishesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutDishesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutDishesInput, CategoryUncheckedUpdateWithoutDishesInput>
  }

  export type CategoryUpdateWithoutDishesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postition?: IntFieldUpdateOperationsInput | number
    restaurant?: RestaurantUpdateOneRequiredWithoutCategoriesNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutDishesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    postition?: IntFieldUpdateOperationsInput | number
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type SubcategoryUpsertWithoutDishesInput = {
    update: XOR<SubcategoryUpdateWithoutDishesInput, SubcategoryUncheckedUpdateWithoutDishesInput>
    create: XOR<SubcategoryCreateWithoutDishesInput, SubcategoryUncheckedCreateWithoutDishesInput>
    where?: SubcategoryWhereInput
  }

  export type SubcategoryUpdateToOneWithWhereWithoutDishesInput = {
    where?: SubcategoryWhereInput
    data: XOR<SubcategoryUpdateWithoutDishesInput, SubcategoryUncheckedUpdateWithoutDishesInput>
  }

  export type SubcategoryUpdateWithoutDishesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postition?: IntFieldUpdateOperationsInput | number
    category?: CategoryUpdateOneRequiredWithoutSubcategoriesNestedInput
    subSubcategories?: SubSubcategoryUpdateManyWithoutSubcategoryNestedInput
  }

  export type SubcategoryUncheckedUpdateWithoutDishesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentCategoryId?: StringFieldUpdateOperationsInput | string
    postition?: IntFieldUpdateOperationsInput | number
    subSubcategories?: SubSubcategoryUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type SubSubcategoryUpsertWithoutDishesInput = {
    update: XOR<SubSubcategoryUpdateWithoutDishesInput, SubSubcategoryUncheckedUpdateWithoutDishesInput>
    create: XOR<SubSubcategoryCreateWithoutDishesInput, SubSubcategoryUncheckedCreateWithoutDishesInput>
    where?: SubSubcategoryWhereInput
  }

  export type SubSubcategoryUpdateToOneWithWhereWithoutDishesInput = {
    where?: SubSubcategoryWhereInput
    data: XOR<SubSubcategoryUpdateWithoutDishesInput, SubSubcategoryUncheckedUpdateWithoutDishesInput>
  }

  export type SubSubcategoryUpdateWithoutDishesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postition?: IntFieldUpdateOperationsInput | number
    subcategory?: SubcategoryUpdateOneRequiredWithoutSubSubcategoriesNestedInput
  }

  export type SubSubcategoryUncheckedUpdateWithoutDishesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentSubcategoryId?: StringFieldUpdateOperationsInput | string
    postition?: IntFieldUpdateOperationsInput | number
  }

  export type MenuUpsertWithoutDishesInput = {
    update: XOR<MenuUpdateWithoutDishesInput, MenuUncheckedUpdateWithoutDishesInput>
    create: XOR<MenuCreateWithoutDishesInput, MenuUncheckedCreateWithoutDishesInput>
    where?: MenuWhereInput
  }

  export type MenuUpdateToOneWithWhereWithoutDishesInput = {
    where?: MenuWhereInput
    data: XOR<MenuUpdateWithoutDishesInput, MenuUncheckedUpdateWithoutDishesInput>
  }

  export type MenuUpdateWithoutDishesInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    restaurant?: RestaurantUpdateOneRequiredWithoutMenusNestedInput
  }

  export type MenuUncheckedUpdateWithoutDishesInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    restaurantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RestaurantCreateWithoutOpeningHoursInput = {
    id?: string
    name?: string
    description?: string | null
    descriptionshort?: string | null
    description_esp?: string | null
    descriptionshort_esp?: string | null
    image?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listorder?: number
    categories?: CategoryCreateNestedManyWithoutRestaurantInput
    dishes?: DishCreateNestedManyWithoutRestaurantInput
    menus?: MenuCreateNestedManyWithoutRestaurantInput
    tables?: TableCreateNestedManyWithoutRestaurantInput
    reservations?: ReservationCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantUncheckedCreateWithoutOpeningHoursInput = {
    id?: string
    name?: string
    description?: string | null
    descriptionshort?: string | null
    description_esp?: string | null
    descriptionshort_esp?: string | null
    image?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listorder?: number
    categories?: CategoryUncheckedCreateNestedManyWithoutRestaurantInput
    dishes?: DishUncheckedCreateNestedManyWithoutRestaurantInput
    menus?: MenuUncheckedCreateNestedManyWithoutRestaurantInput
    tables?: TableUncheckedCreateNestedManyWithoutRestaurantInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutRestaurantInput
  }

  export type RestaurantCreateOrConnectWithoutOpeningHoursInput = {
    where: RestaurantWhereUniqueInput
    create: XOR<RestaurantCreateWithoutOpeningHoursInput, RestaurantUncheckedCreateWithoutOpeningHoursInput>
  }

  export type RestaurantUpsertWithoutOpeningHoursInput = {
    update: XOR<RestaurantUpdateWithoutOpeningHoursInput, RestaurantUncheckedUpdateWithoutOpeningHoursInput>
    create: XOR<RestaurantCreateWithoutOpeningHoursInput, RestaurantUncheckedCreateWithoutOpeningHoursInput>
    where?: RestaurantWhereInput
  }

  export type RestaurantUpdateToOneWithWhereWithoutOpeningHoursInput = {
    where?: RestaurantWhereInput
    data: XOR<RestaurantUpdateWithoutOpeningHoursInput, RestaurantUncheckedUpdateWithoutOpeningHoursInput>
  }

  export type RestaurantUpdateWithoutOpeningHoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listorder?: IntFieldUpdateOperationsInput | number
    categories?: CategoryUpdateManyWithoutRestaurantNestedInput
    dishes?: DishUpdateManyWithoutRestaurantNestedInput
    menus?: MenuUpdateManyWithoutRestaurantNestedInput
    tables?: TableUpdateManyWithoutRestaurantNestedInput
    reservations?: ReservationUpdateManyWithoutRestaurantNestedInput
  }

  export type RestaurantUncheckedUpdateWithoutOpeningHoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionshort_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listorder?: IntFieldUpdateOperationsInput | number
    categories?: CategoryUncheckedUpdateManyWithoutRestaurantNestedInput
    dishes?: DishUncheckedUpdateManyWithoutRestaurantNestedInput
    menus?: MenuUncheckedUpdateManyWithoutRestaurantNestedInput
    tables?: TableUncheckedUpdateManyWithoutRestaurantNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutRestaurantNestedInput
  }

  export type ActivityCreateManyHotelInput = {
    id?: string
    name?: string
    name_esp?: string
    description?: string
    description_esp?: string
    image?: string
    profileImage?: string | null
    type?: string
    start: Date | string
    end: Date | string
    price: number
    cashOnly?: boolean
    freeOfCharge?: boolean
    location?: string
    isRecurring?: boolean
    recurrencePattern?: $Enums.RECURRINGPATTERN
    recurrenceDays?: ActivityCreaterecurrenceDaysInput | string[]
    recurrenceEndDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourCreateManyHotelInput = {
    id?: string
    name?: string
    name_esp?: string
    description?: string
    description_esp?: string
    image?: string
    price: number
    priceKids?: number
    category?: string
    offer?: boolean
    discount?: number
    whattobring?: string
    included?: TourCreateincludedInput | string[]
    pickuptime: Date | string
    maxPeople?: number
    minPeople?: number
    minAge?: number
    bestSeller?: boolean
    priceInfo?: string
    location?: string
    offered?: TourCreateofferedInput | string[]
    duration?: number
    videos?: TourCreatevideosInput | string[]
    images?: TourCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpaCreateManyHotelInput = {
    id?: string
    name?: string
    name_esp?: string
    description?: string
    description_esp?: string
    type?: string
    videos?: SpaCreatevideosInput | string[]
    images?: SpaCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenitiesCreateManyHotelInput = {
    id?: string
    name: string
    description?: string
    icon?: string
    image?: string
    amenitiestype: $Enums.AMENITIESTYPE
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TVChannelsCreateManyHotelInput = {
    id?: string
    name: string
    name_esp?: string | null
    description: string
    description_esp?: string | null
    logo?: string | null
    channelNo: string
    languages?: $Enums.TVChannelLanguages
    channeltype?: $Enums.TVCHANNELTYPE
    category?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    cashOnly?: BoolFieldUpdateOperationsInput | boolean
    freeOfCharge?: BoolFieldUpdateOperationsInput | boolean
    location?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrencePattern?: EnumRECURRINGPATTERNFieldUpdateOperationsInput | $Enums.RECURRINGPATTERN
    recurrenceDays?: ActivityUpdaterecurrenceDaysInput | string[]
    recurrenceEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    cashOnly?: BoolFieldUpdateOperationsInput | boolean
    freeOfCharge?: BoolFieldUpdateOperationsInput | boolean
    location?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrencePattern?: EnumRECURRINGPATTERNFieldUpdateOperationsInput | $Enums.RECURRINGPATTERN
    recurrenceDays?: ActivityUpdaterecurrenceDaysInput | string[]
    recurrenceEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    cashOnly?: BoolFieldUpdateOperationsInput | boolean
    freeOfCharge?: BoolFieldUpdateOperationsInput | boolean
    location?: StringFieldUpdateOperationsInput | string
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurrencePattern?: EnumRECURRINGPATTERNFieldUpdateOperationsInput | $Enums.RECURRINGPATTERN
    recurrenceDays?: ActivityUpdaterecurrenceDaysInput | string[]
    recurrenceEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    priceKids?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    offer?: BoolFieldUpdateOperationsInput | boolean
    discount?: IntFieldUpdateOperationsInput | number
    whattobring?: StringFieldUpdateOperationsInput | string
    included?: TourUpdateincludedInput | string[]
    pickuptime?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPeople?: IntFieldUpdateOperationsInput | number
    minPeople?: IntFieldUpdateOperationsInput | number
    minAge?: IntFieldUpdateOperationsInput | number
    bestSeller?: BoolFieldUpdateOperationsInput | boolean
    priceInfo?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    offered?: TourUpdateofferedInput | string[]
    duration?: IntFieldUpdateOperationsInput | number
    videos?: TourUpdatevideosInput | string[]
    images?: TourUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricecategory?: TourPriceCategoryUpdateManyWithoutTourNestedInput
  }

  export type TourUncheckedUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    priceKids?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    offer?: BoolFieldUpdateOperationsInput | boolean
    discount?: IntFieldUpdateOperationsInput | number
    whattobring?: StringFieldUpdateOperationsInput | string
    included?: TourUpdateincludedInput | string[]
    pickuptime?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPeople?: IntFieldUpdateOperationsInput | number
    minPeople?: IntFieldUpdateOperationsInput | number
    minAge?: IntFieldUpdateOperationsInput | number
    bestSeller?: BoolFieldUpdateOperationsInput | boolean
    priceInfo?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    offered?: TourUpdateofferedInput | string[]
    duration?: IntFieldUpdateOperationsInput | number
    videos?: TourUpdatevideosInput | string[]
    images?: TourUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricecategory?: TourPriceCategoryUncheckedUpdateManyWithoutTourNestedInput
  }

  export type TourUncheckedUpdateManyWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    priceKids?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    offer?: BoolFieldUpdateOperationsInput | boolean
    discount?: IntFieldUpdateOperationsInput | number
    whattobring?: StringFieldUpdateOperationsInput | string
    included?: TourUpdateincludedInput | string[]
    pickuptime?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPeople?: IntFieldUpdateOperationsInput | number
    minPeople?: IntFieldUpdateOperationsInput | number
    minAge?: IntFieldUpdateOperationsInput | number
    bestSeller?: BoolFieldUpdateOperationsInput | boolean
    priceInfo?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    offered?: TourUpdateofferedInput | string[]
    duration?: IntFieldUpdateOperationsInput | number
    videos?: TourUpdatevideosInput | string[]
    images?: TourUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpaUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    videos?: SpaUpdatevideosInput | string[]
    images?: SpaUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricecategory?: SpaPriceCategoryUpdateManyWithoutSpaNestedInput
  }

  export type SpaUncheckedUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    videos?: SpaUpdatevideosInput | string[]
    images?: SpaUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricecategory?: SpaPriceCategoryUncheckedUpdateManyWithoutSpaNestedInput
  }

  export type SpaUncheckedUpdateManyWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    videos?: SpaUpdatevideosInput | string[]
    images?: SpaUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenitiesUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    amenitiestype?: EnumAMENITIESTYPEFieldUpdateOperationsInput | $Enums.AMENITIESTYPE
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenitiesUncheckedUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    amenitiestype?: EnumAMENITIESTYPEFieldUpdateOperationsInput | $Enums.AMENITIESTYPE
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenitiesUncheckedUpdateManyWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    amenitiestype?: EnumAMENITIESTYPEFieldUpdateOperationsInput | $Enums.AMENITIESTYPE
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TVChannelsUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    channelNo?: StringFieldUpdateOperationsInput | string
    languages?: EnumTVChannelLanguagesFieldUpdateOperationsInput | $Enums.TVChannelLanguages
    channeltype?: EnumTVCHANNELTYPEFieldUpdateOperationsInput | $Enums.TVCHANNELTYPE
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TVChannelsUncheckedUpdateWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    channelNo?: StringFieldUpdateOperationsInput | string
    languages?: EnumTVChannelLanguagesFieldUpdateOperationsInput | $Enums.TVChannelLanguages
    channeltype?: EnumTVCHANNELTYPEFieldUpdateOperationsInput | $Enums.TVCHANNELTYPE
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TVChannelsUncheckedUpdateManyWithoutHotelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    channelNo?: StringFieldUpdateOperationsInput | string
    languages?: EnumTVChannelLanguagesFieldUpdateOperationsInput | $Enums.TVChannelLanguages
    channeltype?: EnumTVCHANNELTYPEFieldUpdateOperationsInput | $Enums.TVCHANNELTYPE
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourPriceCategoryCreateManyTourInput = {
    id?: string
    sku: number
    price: number
    description?: string
    description_esp?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourPriceCategoryUpdateWithoutTourInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourPriceCategoryUncheckedUpdateWithoutTourInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourPriceCategoryUncheckedUpdateManyWithoutTourInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpaPriceCategoryCreateManySpaInput = {
    id?: string
    sku: number
    price: number
    description?: string
    description_esp?: string
    duration: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpaPriceCategoryUpdateWithoutSpaInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpaPriceCategoryUncheckedUpdateWithoutSpaInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpaPriceCategoryUncheckedUpdateManyWithoutSpaInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateManyRestaurantInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postition?: number
  }

  export type DishCreateManyRestaurantInput = {
    id?: string
    sku: number
    name: string
    name_esp: string
    description: string
    description_esp: string
    price: number
    unit?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId: string
    subcategoryId?: string | null
    subSubcategoryId?: string | null
    availableAtDayOfWeek?: number
    dietaryInfo?: DishCreatedietaryInfoInput | string[]
    allergens?: DishCreateallergensInput | string[]
    ingredients?: DishCreateingredientsInput | string[]
    prepTime?: number | null
    isPopular?: boolean
    isNew?: boolean
    menuId?: string | null
    course_number?: number
  }

  export type MenuCreateManyRestaurantInput = {
    id?: string
    position?: number
    name: string
    name_esp: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type TableCreateManyRestaurantInput = {
    id?: string
    number: number
    capacity: number
    location?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationCreateManyRestaurantInput = {
    id?: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    partySize: number
    status?: $Enums.ReservationStatus
    notes?: string | null
    customerId: string
    tableId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpeningHoursCreateManyRestaurantInput = {
    id?: string
    dayOfWeek: number
    openTime: string
    closeTime: string
    isClosed?: boolean
  }

  export type CategoryUpdateWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postition?: IntFieldUpdateOperationsInput | number
    dishes?: DishUpdateManyWithoutCategoryNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postition?: IntFieldUpdateOperationsInput | number
    dishes?: DishUncheckedUpdateManyWithoutCategoryNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postition?: IntFieldUpdateOperationsInput | number
  }

  export type DishUpdateWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availableAtDayOfWeek?: IntFieldUpdateOperationsInput | number
    dietaryInfo?: DishUpdatedietaryInfoInput | string[]
    allergens?: DishUpdateallergensInput | string[]
    ingredients?: DishUpdateingredientsInput | string[]
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    course_number?: IntFieldUpdateOperationsInput | number
    category?: CategoryUpdateOneRequiredWithoutDishesNestedInput
    subcategory?: SubcategoryUpdateOneWithoutDishesNestedInput
    subSubcategory?: SubSubcategoryUpdateOneWithoutDishesNestedInput
    menu?: MenuUpdateOneWithoutDishesNestedInput
  }

  export type DishUncheckedUpdateWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: StringFieldUpdateOperationsInput | string
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subSubcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    availableAtDayOfWeek?: IntFieldUpdateOperationsInput | number
    dietaryInfo?: DishUpdatedietaryInfoInput | string[]
    allergens?: DishUpdateallergensInput | string[]
    ingredients?: DishUpdateingredientsInput | string[]
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    menuId?: NullableStringFieldUpdateOperationsInput | string | null
    course_number?: IntFieldUpdateOperationsInput | number
  }

  export type DishUncheckedUpdateManyWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: StringFieldUpdateOperationsInput | string
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subSubcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    availableAtDayOfWeek?: IntFieldUpdateOperationsInput | number
    dietaryInfo?: DishUpdatedietaryInfoInput | string[]
    allergens?: DishUpdateallergensInput | string[]
    ingredients?: DishUpdateingredientsInput | string[]
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    menuId?: NullableStringFieldUpdateOperationsInput | string | null
    course_number?: IntFieldUpdateOperationsInput | number
  }

  export type MenuUpdateWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dishes?: DishUpdateManyWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dishes?: DishUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateManyWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TableUpdateWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateManyWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUpdateWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    partySize?: IntFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutReservationsNestedInput
    table?: TableUpdateOneWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    partySize?: IntFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    partySize?: IntFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpeningHoursUpdateWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OpeningHoursUncheckedUpdateWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OpeningHoursUncheckedUpdateManyWithoutRestaurantInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    openTime?: StringFieldUpdateOperationsInput | string
    closeTime?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DishCreateManyMenuInput = {
    id?: string
    sku: number
    name: string
    name_esp: string
    description: string
    description_esp: string
    price: number
    unit?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    restaurantId: string
    categoryId: string
    subcategoryId?: string | null
    subSubcategoryId?: string | null
    availableAtDayOfWeek?: number
    dietaryInfo?: DishCreatedietaryInfoInput | string[]
    allergens?: DishCreateallergensInput | string[]
    ingredients?: DishCreateingredientsInput | string[]
    prepTime?: number | null
    isPopular?: boolean
    isNew?: boolean
    course_number?: number
  }

  export type DishUpdateWithoutMenuInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availableAtDayOfWeek?: IntFieldUpdateOperationsInput | number
    dietaryInfo?: DishUpdatedietaryInfoInput | string[]
    allergens?: DishUpdateallergensInput | string[]
    ingredients?: DishUpdateingredientsInput | string[]
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    course_number?: IntFieldUpdateOperationsInput | number
    restaurant?: RestaurantUpdateOneRequiredWithoutDishesNestedInput
    category?: CategoryUpdateOneRequiredWithoutDishesNestedInput
    subcategory?: SubcategoryUpdateOneWithoutDishesNestedInput
    subSubcategory?: SubSubcategoryUpdateOneWithoutDishesNestedInput
  }

  export type DishUncheckedUpdateWithoutMenuInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subSubcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    availableAtDayOfWeek?: IntFieldUpdateOperationsInput | number
    dietaryInfo?: DishUpdatedietaryInfoInput | string[]
    allergens?: DishUpdateallergensInput | string[]
    ingredients?: DishUpdateingredientsInput | string[]
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    course_number?: IntFieldUpdateOperationsInput | number
  }

  export type DishUncheckedUpdateManyWithoutMenuInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subSubcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    availableAtDayOfWeek?: IntFieldUpdateOperationsInput | number
    dietaryInfo?: DishUpdatedietaryInfoInput | string[]
    allergens?: DishUpdateallergensInput | string[]
    ingredients?: DishUpdateingredientsInput | string[]
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    course_number?: IntFieldUpdateOperationsInput | number
  }

  export type ReservationCreateManyTableInput = {
    id?: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    partySize: number
    status?: $Enums.ReservationStatus
    notes?: string | null
    customerId: string
    restaurantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationUpdateWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    partySize?: IntFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutReservationsNestedInput
    restaurant?: RestaurantUpdateOneRequiredWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    partySize?: IntFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    partySize?: IntFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationCreateManyCustomerInput = {
    id?: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    partySize: number
    status?: $Enums.ReservationStatus
    notes?: string | null
    tableId?: string | null
    restaurantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    partySize?: IntFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    table?: TableUpdateOneWithoutReservationsNestedInput
    restaurant?: RestaurantUpdateOneRequiredWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    partySize?: IntFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    restaurantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    partySize?: IntFieldUpdateOperationsInput | number
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    restaurantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DishCreateManyCategoryInput = {
    id?: string
    sku: number
    name: string
    name_esp: string
    description: string
    description_esp: string
    price: number
    unit?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    restaurantId: string
    subcategoryId?: string | null
    subSubcategoryId?: string | null
    availableAtDayOfWeek?: number
    dietaryInfo?: DishCreatedietaryInfoInput | string[]
    allergens?: DishCreateallergensInput | string[]
    ingredients?: DishCreateingredientsInput | string[]
    prepTime?: number | null
    isPopular?: boolean
    isNew?: boolean
    menuId?: string | null
    course_number?: number
  }

  export type SubcategoryCreateManyCategoryInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postition?: number
  }

  export type DishUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availableAtDayOfWeek?: IntFieldUpdateOperationsInput | number
    dietaryInfo?: DishUpdatedietaryInfoInput | string[]
    allergens?: DishUpdateallergensInput | string[]
    ingredients?: DishUpdateingredientsInput | string[]
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    course_number?: IntFieldUpdateOperationsInput | number
    restaurant?: RestaurantUpdateOneRequiredWithoutDishesNestedInput
    subcategory?: SubcategoryUpdateOneWithoutDishesNestedInput
    subSubcategory?: SubSubcategoryUpdateOneWithoutDishesNestedInput
    menu?: MenuUpdateOneWithoutDishesNestedInput
  }

  export type DishUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subSubcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    availableAtDayOfWeek?: IntFieldUpdateOperationsInput | number
    dietaryInfo?: DishUpdatedietaryInfoInput | string[]
    allergens?: DishUpdateallergensInput | string[]
    ingredients?: DishUpdateingredientsInput | string[]
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    menuId?: NullableStringFieldUpdateOperationsInput | string | null
    course_number?: IntFieldUpdateOperationsInput | number
  }

  export type DishUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subSubcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    availableAtDayOfWeek?: IntFieldUpdateOperationsInput | number
    dietaryInfo?: DishUpdatedietaryInfoInput | string[]
    allergens?: DishUpdateallergensInput | string[]
    ingredients?: DishUpdateingredientsInput | string[]
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    menuId?: NullableStringFieldUpdateOperationsInput | string | null
    course_number?: IntFieldUpdateOperationsInput | number
  }

  export type SubcategoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postition?: IntFieldUpdateOperationsInput | number
    dishes?: DishUpdateManyWithoutSubcategoryNestedInput
    subSubcategories?: SubSubcategoryUpdateManyWithoutSubcategoryNestedInput
  }

  export type SubcategoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postition?: IntFieldUpdateOperationsInput | number
    dishes?: DishUncheckedUpdateManyWithoutSubcategoryNestedInput
    subSubcategories?: SubSubcategoryUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type SubcategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postition?: IntFieldUpdateOperationsInput | number
  }

  export type DishCreateManySubcategoryInput = {
    id?: string
    sku: number
    name: string
    name_esp: string
    description: string
    description_esp: string
    price: number
    unit?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    restaurantId: string
    categoryId: string
    subSubcategoryId?: string | null
    availableAtDayOfWeek?: number
    dietaryInfo?: DishCreatedietaryInfoInput | string[]
    allergens?: DishCreateallergensInput | string[]
    ingredients?: DishCreateingredientsInput | string[]
    prepTime?: number | null
    isPopular?: boolean
    isNew?: boolean
    menuId?: string | null
    course_number?: number
  }

  export type SubSubcategoryCreateManySubcategoryInput = {
    id?: string
    name: string
    name_esp?: string | null
    slug: string
    description?: string | null
    description_esp?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    postition?: number
  }

  export type DishUpdateWithoutSubcategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availableAtDayOfWeek?: IntFieldUpdateOperationsInput | number
    dietaryInfo?: DishUpdatedietaryInfoInput | string[]
    allergens?: DishUpdateallergensInput | string[]
    ingredients?: DishUpdateingredientsInput | string[]
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    course_number?: IntFieldUpdateOperationsInput | number
    restaurant?: RestaurantUpdateOneRequiredWithoutDishesNestedInput
    category?: CategoryUpdateOneRequiredWithoutDishesNestedInput
    subSubcategory?: SubSubcategoryUpdateOneWithoutDishesNestedInput
    menu?: MenuUpdateOneWithoutDishesNestedInput
  }

  export type DishUncheckedUpdateWithoutSubcategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    subSubcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    availableAtDayOfWeek?: IntFieldUpdateOperationsInput | number
    dietaryInfo?: DishUpdatedietaryInfoInput | string[]
    allergens?: DishUpdateallergensInput | string[]
    ingredients?: DishUpdateingredientsInput | string[]
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    menuId?: NullableStringFieldUpdateOperationsInput | string | null
    course_number?: IntFieldUpdateOperationsInput | number
  }

  export type DishUncheckedUpdateManyWithoutSubcategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    subSubcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    availableAtDayOfWeek?: IntFieldUpdateOperationsInput | number
    dietaryInfo?: DishUpdatedietaryInfoInput | string[]
    allergens?: DishUpdateallergensInput | string[]
    ingredients?: DishUpdateingredientsInput | string[]
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    menuId?: NullableStringFieldUpdateOperationsInput | string | null
    course_number?: IntFieldUpdateOperationsInput | number
  }

  export type SubSubcategoryUpdateWithoutSubcategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postition?: IntFieldUpdateOperationsInput | number
    dishes?: DishUpdateManyWithoutSubSubcategoryNestedInput
  }

  export type SubSubcategoryUncheckedUpdateWithoutSubcategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postition?: IntFieldUpdateOperationsInput | number
    dishes?: DishUncheckedUpdateManyWithoutSubSubcategoryNestedInput
  }

  export type SubSubcategoryUncheckedUpdateManyWithoutSubcategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    description_esp?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postition?: IntFieldUpdateOperationsInput | number
  }

  export type DishCreateManySubSubcategoryInput = {
    id?: string
    sku: number
    name: string
    name_esp: string
    description: string
    description_esp: string
    price: number
    unit?: string | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    restaurantId: string
    categoryId: string
    subcategoryId?: string | null
    availableAtDayOfWeek?: number
    dietaryInfo?: DishCreatedietaryInfoInput | string[]
    allergens?: DishCreateallergensInput | string[]
    ingredients?: DishCreateingredientsInput | string[]
    prepTime?: number | null
    isPopular?: boolean
    isNew?: boolean
    menuId?: string | null
    course_number?: number
  }

  export type DishUpdateWithoutSubSubcategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availableAtDayOfWeek?: IntFieldUpdateOperationsInput | number
    dietaryInfo?: DishUpdatedietaryInfoInput | string[]
    allergens?: DishUpdateallergensInput | string[]
    ingredients?: DishUpdateingredientsInput | string[]
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    course_number?: IntFieldUpdateOperationsInput | number
    restaurant?: RestaurantUpdateOneRequiredWithoutDishesNestedInput
    category?: CategoryUpdateOneRequiredWithoutDishesNestedInput
    subcategory?: SubcategoryUpdateOneWithoutDishesNestedInput
    menu?: MenuUpdateOneWithoutDishesNestedInput
  }

  export type DishUncheckedUpdateWithoutSubSubcategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    availableAtDayOfWeek?: IntFieldUpdateOperationsInput | number
    dietaryInfo?: DishUpdatedietaryInfoInput | string[]
    allergens?: DishUpdateallergensInput | string[]
    ingredients?: DishUpdateingredientsInput | string[]
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    menuId?: NullableStringFieldUpdateOperationsInput | string | null
    course_number?: IntFieldUpdateOperationsInput | number
  }

  export type DishUncheckedUpdateManyWithoutSubSubcategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    name_esp?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    description_esp?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    restaurantId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    availableAtDayOfWeek?: IntFieldUpdateOperationsInput | number
    dietaryInfo?: DishUpdatedietaryInfoInput | string[]
    allergens?: DishUpdateallergensInput | string[]
    ingredients?: DishUpdateingredientsInput | string[]
    prepTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    menuId?: NullableStringFieldUpdateOperationsInput | string | null
    course_number?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}